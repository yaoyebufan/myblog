/*
Navicat MySQL Data Transfer

Source Server         : 服务器
Source Server Version : 50731
Source Host           : 152.136.30.116:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50731
File Encoding         : 65001

Date: 2021-01-13 23:39:49
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for admins
-- ----------------------------
DROP TABLE IF EXISTS `admins`;
CREATE TABLE `admins` (
  `admin_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '管理员ID',
  `admin_name` varchar(20) NOT NULL COMMENT '管理员名',
  `admin_password` varchar(15) NOT NULL COMMENT '管理员密码',
  `admin_photo` varchar(255) NOT NULL COMMENT '管理员头像',
  `admin_email` varchar(30) NOT NULL COMMENT '管理员邮箱',
  `admin_phone` varchar(11) NOT NULL COMMENT '管理员手机号',
  `admin_create_time` datetime NOT NULL COMMENT '注册时间',
  `admin_login_time` datetime NOT NULL COMMENT '上次登录时间',
  `admin_status` int(1) NOT NULL COMMENT '管理员状态',
  PRIMARY KEY (`admin_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of admins
-- ----------------------------
INSERT INTO `admins` VALUES ('1', '孙跃', '1', '../images/4e8c76ef-2b9c-49d8-979d-9c722e3dc1ec.jpg', '1', '1', '2020-07-28 22:28:39', '2020-07-28 22:28:48', '1');

-- ----------------------------
-- Table structure for article_label
-- ----------------------------
DROP TABLE IF EXISTS `article_label`;
CREATE TABLE `article_label` (
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `label_id` bigint(20) NOT NULL COMMENT '文章标签连接表ID',
  PRIMARY KEY (`article_id`,`label_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of article_label
-- ----------------------------
INSERT INTO `article_label` VALUES ('25', '12');
INSERT INTO `article_label` VALUES ('26', '12');
INSERT INTO `article_label` VALUES ('27', '12');
INSERT INTO `article_label` VALUES ('28', '12');
INSERT INTO `article_label` VALUES ('29', '12');
INSERT INTO `article_label` VALUES ('30', '12');
INSERT INTO `article_label` VALUES ('31', '12');
INSERT INTO `article_label` VALUES ('32', '12');
INSERT INTO `article_label` VALUES ('33', '12');
INSERT INTO `article_label` VALUES ('34', '12');
INSERT INTO `article_label` VALUES ('35', '12');
INSERT INTO `article_label` VALUES ('35', '16');
INSERT INTO `article_label` VALUES ('36', '12');
INSERT INTO `article_label` VALUES ('36', '14');
INSERT INTO `article_label` VALUES ('37', '12');
INSERT INTO `article_label` VALUES ('37', '15');
INSERT INTO `article_label` VALUES ('38', '10');
INSERT INTO `article_label` VALUES ('38', '12');
INSERT INTO `article_label` VALUES ('40', '18');
INSERT INTO `article_label` VALUES ('41', '18');
INSERT INTO `article_label` VALUES ('42', '18');
INSERT INTO `article_label` VALUES ('43', '18');
INSERT INTO `article_label` VALUES ('44', '18');
INSERT INTO `article_label` VALUES ('45', '18');
INSERT INTO `article_label` VALUES ('46', '18');
INSERT INTO `article_label` VALUES ('47', '11');
INSERT INTO `article_label` VALUES ('48', '11');
INSERT INTO `article_label` VALUES ('49', '11');
INSERT INTO `article_label` VALUES ('50', '11');
INSERT INTO `article_label` VALUES ('51', '17');
INSERT INTO `article_label` VALUES ('52', '17');
INSERT INTO `article_label` VALUES ('53', '17');
INSERT INTO `article_label` VALUES ('54', '17');
INSERT INTO `article_label` VALUES ('55', '17');
INSERT INTO `article_label` VALUES ('56', '17');
INSERT INTO `article_label` VALUES ('57', '17');
INSERT INTO `article_label` VALUES ('58', '17');
INSERT INTO `article_label` VALUES ('59', '18');
INSERT INTO `article_label` VALUES ('60', '18');
INSERT INTO `article_label` VALUES ('61', '18');
INSERT INTO `article_label` VALUES ('62', '14');
INSERT INTO `article_label` VALUES ('62', '18');
INSERT INTO `article_label` VALUES ('63', '18');
INSERT INTO `article_label` VALUES ('64', '18');
INSERT INTO `article_label` VALUES ('65', '18');
INSERT INTO `article_label` VALUES ('66', '14');
INSERT INTO `article_label` VALUES ('66', '18');
INSERT INTO `article_label` VALUES ('67', '18');
INSERT INTO `article_label` VALUES ('68', '10');
INSERT INTO `article_label` VALUES ('68', '12');
INSERT INTO `article_label` VALUES ('68', '14');
INSERT INTO `article_label` VALUES ('68', '18');
INSERT INTO `article_label` VALUES ('69', '11');
INSERT INTO `article_label` VALUES ('69', '19');
INSERT INTO `article_label` VALUES ('70', '11');
INSERT INTO `article_label` VALUES ('71', '11');
INSERT INTO `article_label` VALUES ('71', '19');
INSERT INTO `article_label` VALUES ('72', '11');
INSERT INTO `article_label` VALUES ('72', '19');
INSERT INTO `article_label` VALUES ('73', '14');
INSERT INTO `article_label` VALUES ('74', '20');
INSERT INTO `article_label` VALUES ('75', '20');
INSERT INTO `article_label` VALUES ('76', '20');
INSERT INTO `article_label` VALUES ('77', '20');
INSERT INTO `article_label` VALUES ('78', '20');
INSERT INTO `article_label` VALUES ('79', '20');
INSERT INTO `article_label` VALUES ('80', '20');
INSERT INTO `article_label` VALUES ('81', '20');
INSERT INTO `article_label` VALUES ('82', '20');
INSERT INTO `article_label` VALUES ('83', '19');
INSERT INTO `article_label` VALUES ('83', '20');
INSERT INTO `article_label` VALUES ('84', '20');
INSERT INTO `article_label` VALUES ('85', '19');
INSERT INTO `article_label` VALUES ('85', '20');
INSERT INTO `article_label` VALUES ('86', '19');
INSERT INTO `article_label` VALUES ('86', '22');

-- ----------------------------
-- Table structure for article_sort
-- ----------------------------
DROP TABLE IF EXISTS `article_sort`;
CREATE TABLE `article_sort` (
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `sort_id` bigint(20) NOT NULL COMMENT '文章分类连接表ID',
  PRIMARY KEY (`article_id`,`sort_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of article_sort
-- ----------------------------
INSERT INTO `article_sort` VALUES ('25', '12');
INSERT INTO `article_sort` VALUES ('26', '12');
INSERT INTO `article_sort` VALUES ('27', '12');
INSERT INTO `article_sort` VALUES ('28', '12');
INSERT INTO `article_sort` VALUES ('29', '12');
INSERT INTO `article_sort` VALUES ('30', '12');
INSERT INTO `article_sort` VALUES ('31', '12');
INSERT INTO `article_sort` VALUES ('32', '12');
INSERT INTO `article_sort` VALUES ('33', '12');
INSERT INTO `article_sort` VALUES ('34', '12');
INSERT INTO `article_sort` VALUES ('34', '13');
INSERT INTO `article_sort` VALUES ('35', '12');
INSERT INTO `article_sort` VALUES ('36', '12');
INSERT INTO `article_sort` VALUES ('37', '12');
INSERT INTO `article_sort` VALUES ('38', '12');
INSERT INTO `article_sort` VALUES ('40', '12');
INSERT INTO `article_sort` VALUES ('41', '12');
INSERT INTO `article_sort` VALUES ('42', '12');
INSERT INTO `article_sort` VALUES ('43', '12');
INSERT INTO `article_sort` VALUES ('44', '12');
INSERT INTO `article_sort` VALUES ('45', '12');
INSERT INTO `article_sort` VALUES ('46', '12');
INSERT INTO `article_sort` VALUES ('47', '18');
INSERT INTO `article_sort` VALUES ('48', '18');
INSERT INTO `article_sort` VALUES ('49', '18');
INSERT INTO `article_sort` VALUES ('50', '18');
INSERT INTO `article_sort` VALUES ('51', '17');
INSERT INTO `article_sort` VALUES ('52', '17');
INSERT INTO `article_sort` VALUES ('53', '17');
INSERT INTO `article_sort` VALUES ('54', '17');
INSERT INTO `article_sort` VALUES ('55', '17');
INSERT INTO `article_sort` VALUES ('56', '17');
INSERT INTO `article_sort` VALUES ('57', '17');
INSERT INTO `article_sort` VALUES ('58', '17');
INSERT INTO `article_sort` VALUES ('59', '12');
INSERT INTO `article_sort` VALUES ('60', '12');
INSERT INTO `article_sort` VALUES ('61', '12');
INSERT INTO `article_sort` VALUES ('62', '12');
INSERT INTO `article_sort` VALUES ('63', '12');
INSERT INTO `article_sort` VALUES ('64', '12');
INSERT INTO `article_sort` VALUES ('65', '12');
INSERT INTO `article_sort` VALUES ('66', '12');
INSERT INTO `article_sort` VALUES ('67', '12');
INSERT INTO `article_sort` VALUES ('68', '12');
INSERT INTO `article_sort` VALUES ('69', '13');
INSERT INTO `article_sort` VALUES ('69', '19');
INSERT INTO `article_sort` VALUES ('70', '13');
INSERT INTO `article_sort` VALUES ('71', '13');
INSERT INTO `article_sort` VALUES ('71', '19');
INSERT INTO `article_sort` VALUES ('72', '13');
INSERT INTO `article_sort` VALUES ('72', '19');
INSERT INTO `article_sort` VALUES ('73', '20');
INSERT INTO `article_sort` VALUES ('74', '21');
INSERT INTO `article_sort` VALUES ('75', '21');
INSERT INTO `article_sort` VALUES ('76', '21');
INSERT INTO `article_sort` VALUES ('77', '21');
INSERT INTO `article_sort` VALUES ('78', '21');
INSERT INTO `article_sort` VALUES ('79', '21');
INSERT INTO `article_sort` VALUES ('80', '21');
INSERT INTO `article_sort` VALUES ('81', '21');
INSERT INTO `article_sort` VALUES ('82', '21');
INSERT INTO `article_sort` VALUES ('83', '21');
INSERT INTO `article_sort` VALUES ('84', '21');
INSERT INTO `article_sort` VALUES ('85', '19');
INSERT INTO `article_sort` VALUES ('86', '19');

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `article_title` text NOT NULL COMMENT '文章标题',
  `article_resource` varchar(150) DEFAULT NULL COMMENT '文章外链',
  `article_content_md` longtext COMMENT 'md格式',
  `article_content` longtext NOT NULL COMMENT '文章内容',
  `article_views` bigint(20) DEFAULT NULL COMMENT '文章浏览量',
  `article_likes` bigint(20) DEFAULT NULL COMMENT '文章点赞数',
  `article_comments` bigint(20) DEFAULT NULL COMMENT '文章评论数',
  `article_create_time` datetime NOT NULL COMMENT '文章创建时间',
  `article_update_time` datetime NOT NULL COMMENT '文章修改时间',
  `article_status` int(1) NOT NULL COMMENT '文章状态',
  PRIMARY KEY (`article_id`)
) ENGINE=InnoDB AUTO_INCREMENT=87 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES ('25', '1', 'Linux 简介', 'https://www.funtl.com/zh/linux/', '> 概述\r\n\r\nLinux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。\r\n\r\nLinux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution\r\n\r\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。\r\n\r\n> Linux 的目录结构\r\n\r\n| 目录 | 说明  |\r\n| ------------ | ------------ |\r\n|  bin |  存放二进制可执行文件(ls,cat,mkdir等) |\r\n|  boot | 存放用于系统引导时使用的各种文件  |\r\n|  dev |  用于存放设备文件 |\r\n|  etc |  存放系统配置文件 |\r\n|  home | 存放所有用户文件的根目录  |\r\n|  lib | 存放跟文件系统中的程序运行所需要的共享库及内核模块  |\r\n|  mnt | 系统管理员安装临时文件系统的安装点  |\r\n|  opt | 额外安装的可选应用程序包所放置的位置  |\r\n|  proc | 虚拟文件系统，存放当前内存的映射  |\r\n| root |  超级用户目录 |\r\n| sbin  |  存放二进制可执行文件，只有root才能访问 |\r\n| tmp  |  用于存放各种临时文件 |\r\n| usr  |  用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 |\r\n| var  |  用于存放运行时需要改变数据的文件 |\r\n\r\n\r\n\r\n\r\n\r\n', '<blockquote>\r\n<p>概述</p>\r\n</blockquote>\r\n<p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。</p>\r\n<p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p>\r\n<p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p>\r\n<blockquote>\r\n<p>Linux 的目录结构</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>目录</th>\r\n<th>说明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>bin</td>\r\n<td>存放二进制可执行文件(ls,cat,mkdir等)</td>\r\n</tr>\r\n<tr>\r\n<td>boot</td>\r\n<td>存放用于系统引导时使用的各种文件</td>\r\n</tr>\r\n<tr>\r\n<td>dev</td>\r\n<td>用于存放设备文件</td>\r\n</tr>\r\n<tr>\r\n<td>etc</td>\r\n<td>存放系统配置文件</td>\r\n</tr>\r\n<tr>\r\n<td>home</td>\r\n<td>存放所有用户文件的根目录</td>\r\n</tr>\r\n<tr>\r\n<td>lib</td>\r\n<td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td>\r\n</tr>\r\n<tr>\r\n<td>mnt</td>\r\n<td>系统管理员安装临时文件系统的安装点</td>\r\n</tr>\r\n<tr>\r\n<td>opt</td>\r\n<td>额外安装的可选应用程序包所放置的位置</td>\r\n</tr>\r\n<tr>\r\n<td>proc</td>\r\n<td>虚拟文件系统，存放当前内存的映射</td>\r\n</tr>\r\n<tr>\r\n<td>root</td>\r\n<td>超级用户目录</td>\r\n</tr>\r\n<tr>\r\n<td>sbin</td>\r\n<td>存放二进制可执行文件，只有root才能访问</td>\r\n</tr>\r\n<tr>\r\n<td>tmp</td>\r\n<td>用于存放各种临时文件</td>\r\n</tr>\r\n<tr>\r\n<td>usr</td>\r\n<td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td>\r\n</tr>\r\n<tr>\r\n<td>var</td>\r\n<td>用于存放运行时需要改变数据的文件</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n', null, null, null, '2020-09-17 22:49:47', '2020-09-17 22:53:55', '1');
INSERT INTO `articles` VALUES ('26', '1', 'Linux 操作文件目录', '', '> 概述\r\n\r\n## ls：显示文件和目录列表\r\n语法:`ls [-alrtAFR] [name...]`\r\n参数:-l（列出文件的详细信息） -a（列出当前目录所有文件，包含隐藏文件）\r\n## mkdir：创建目录\r\n语法:`mkdir [-p] dirName`\r\n参数:-p（父目录不存在情况下先生成父目录）\r\n## cd：切换目录\r\n语法:`cd [dirName]`\r\n## touch：生成一个空文件\r\n## echo：生成一个带内容文件\r\nem：`echo abcd > 1.txt，echo 1234 >> 1.txt`\r\n## cat：显示文本文件内容\r\n语法:`cat [-AbeEnstTuv] [--help] [--version] fileName`\r\n## cp：复制文件或目录\r\n语法:`cp [options] source dest`\r\n## rm：删除文件\r\n语法:`rm [options] name...`\r\n参数:-f（强制删除文件或目录）-r（同时删除该目录下的所有文件）\r\n## mv：移动文件或目录\r\n语法:`mv [options] source dest`\r\n## find：在文件系统中查找指定的文件\r\n参数:-name（文件名）\r\n## grep：在指定的文本文件中查找指定的字符串\r\n## tree：用于以树状图列出目录的内容\r\n## pwd：显示当前工作目录\r\n## ln：建立软链接\r\n## more：分页显示文本文件内容\r\n## head：显示文件开头内容\r\n## tail：显示文件结尾内容\r\n参数:-f（跟踪输出）', '<blockquote>\r\n<p>概述</p>\r\n</blockquote>\r\n<h2 id=\"h2-ls-\"><a name=\"ls：显示文件和目录列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ls：显示文件和目录列表</h2><p>语法:<code>ls [-alrtAFR] [name...]</code><br>参数:-l（列出文件的详细信息） -a（列出当前目录所有文件，包含隐藏文件）\r\n<h2 id=\"h2-mkdir-\"><a name=\"mkdir：创建目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>mkdir：创建目录</h2><p>语法:<code>mkdir [-p] dirName</code><br>参数:-p（父目录不存在情况下先生成父目录）\r\n<h2 id=\"h2-cd-\"><a name=\"cd：切换目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>cd：切换目录</h2><p>语法:<code>cd [dirName]</code></p>\r\n<h2 id=\"h2-touch-\"><a name=\"touch：生成一个空文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>touch：生成一个空文件</h2><h2 id=\"h2-echo-\"><a name=\"echo：生成一个带内容文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>echo：生成一个带内容文件</h2><p>em：<code>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</code></p>\r\n<h2 id=\"h2-cat-\"><a name=\"cat：显示文本文件内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>cat：显示文本文件内容</h2><p>语法:<code>cat [-AbeEnstTuv] [--help] [--version] fileName</code></p>\r\n<h2 id=\"h2-cp-\"><a name=\"cp：复制文件或目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>cp：复制文件或目录</h2><p>语法:<code>cp [options] source dest</code></p>\r\n<h2 id=\"h2-rm-\"><a name=\"rm：删除文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>rm：删除文件</h2><p>语法:<code>rm [options] name...</code><br>参数:-f（强制删除文件或目录）-r（同时删除该目录下的所有文件）\r\n<h2 id=\"h2-mv-\"><a name=\"mv：移动文件或目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>mv：移动文件或目录</h2><p>语法:<code>mv [options] source dest</code></p>\r\n<h2 id=\"h2-find-\"><a name=\"find：在文件系统中查找指定的文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>find：在文件系统中查找指定的文件</h2><p>参数:-name（文件名）</p>\r\n<h2 id=\"h2-grep-\"><a name=\"grep：在指定的文本文件中查找指定的字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>grep：在指定的文本文件中查找指定的字符串</h2><h2 id=\"h2-tree-\"><a name=\"tree：用于以树状图列出目录的内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>tree：用于以树状图列出目录的内容</h2><h2 id=\"h2-pwd-\"><a name=\"pwd：显示当前工作目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>pwd：显示当前工作目录</h2><h2 id=\"h2-ln-\"><a name=\"ln：建立软链接\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ln：建立软链接</h2><h2 id=\"h2-more-\"><a name=\"more：分页显示文本文件内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>more：分页显示文本文件内容</h2><h2 id=\"h2-head-\"><a name=\"head：显示文件开头内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>head：显示文件开头内容</h2><h2 id=\"h2-tail-\"><a name=\"tail：显示文件结尾内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>tail：显示文件结尾内容</h2><p>参数:-f（跟踪输出）</p>\r\n', null, null, null, '2020-09-23 21:44:07', '2020-09-24 22:25:10', '1');
INSERT INTO `articles` VALUES ('27', '1', 'Linux 系统管理命令', '', '> 概述\r\n\r\n     stat：显示指定文件的相关信息,比ls命令显示内容更多\r\n     who：显示在线登录用户\r\n     hostname：显示主机名称\r\n     uname：显示系统信息\r\n     top：显示当前系统中耗费资源最多的进程\r\n     ps：显示瞬间的进程状态\r\n     du：显示指定的文件（目录）已使用的磁盘空间的总量\r\n     df:显示文件系统磁盘空间的使用情况\r\n     free:显示当前内存和交换空间的使用情况\r\n     ifconfig:显示网络接口信息\r\n     ping:测试网络的连通性\r\n     netstat:显示网络状态信息\r\n     clear:清屏\r\n     kill:杀死一个进程', '<blockquote>\r\n<p>概述</p>\r\n</blockquote>\r\n<pre><code> stat：显示指定文件的相关信息,比ls命令显示内容更多\r\n who：显示在线登录用户\r\n hostname：显示主机名称\r\n uname：显示系统信息\r\n top：显示当前系统中耗费资源最多的进程\r\n ps：显示瞬间的进程状态\r\n du：显示指定的文件（目录）已使用的磁盘空间的总量\r\n df:显示文件系统磁盘空间的使用情况\r\n free:显示当前内存和交换空间的使用情况\r\n ifconfig:显示网络接口信息\r\n ping:测试网络的连通性\r\n netstat:显示网络状态信息\r\n clear:清屏\r\n kill:杀死一个进程\r\n</code></pre>', null, null, null, '2020-09-23 22:09:56', '2020-09-24 22:23:55', '1');
INSERT INTO `articles` VALUES ('28', '1', 'Linux 开关机命令', '', '> 概述：shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。\r\n\r\n## 命令：shutdown\r\n### 语法\r\n`shutdown [-t seconds] [-rkhncfF] time [message]`\r\n### 参数\r\n-t seconds（设定在几秒钟之后进行关机程序）\r\n-k（并不会真的关机，只是将警告讯息传送给所有只用者）\r\n-r（关机后重新开机（重启））\r\n-h（关机后停机）\r\n-n（不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机）\r\n-c（取消目前已经进行中的关机动作）\r\n-f（关机时，不做 fcsk 动作(检查 Linux 档系统)）\r\n-F（关机时，强迫进行 fsck 动作）\r\ntime（设定关机的时间）\r\nmessage（传送给所有使用者的警告讯息）\r\n## 重启\r\n`reboot`\r\n\r\n`shutdown -r now`\r\n## 关机\r\n`shutdown -h now`', '<blockquote>\r\n<p>概述：shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>\r\n</blockquote>\r\n<h2 id=\"h2--shutdown\"><a name=\"命令：shutdown\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命令：shutdown</h2><h3 id=\"h3-u8BEDu6CD5\"><a name=\"语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法</h3><p><code>shutdown [-t seconds] [-rkhncfF] time [message]</code></p>\r\n<h3 id=\"h3-u53C2u6570\"><a name=\"参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参数</h3><p>-t seconds（设定在几秒钟之后进行关机程序）<br>-k（并不会真的关机，只是将警告讯息传送给所有只用者）<br>-r（关机后重新开机（重启））<br>-h（关机后停机）<br>-n（不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机）<br>-c（取消目前已经进行中的关机动作）<br>-f（关机时，不做 fcsk 动作(检查 Linux 档系统)）<br>-F（关机时，强迫进行 fsck 动作）<br>time（设定关机的时间）<br>message（传送给所有使用者的警告讯息）\r\n<h2 id=\"h2-u91CDu542F\"><a name=\"重启\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>重启</h2><p><code>reboot</code></p>\r\n<p><code>shutdown -r now</code></p>\r\n<h2 id=\"h2-u5173u673A\"><a name=\"关机\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关机</h2><p><code>shutdown -h now</code></p>\r\n', null, null, null, '2020-09-23 22:18:59', '2020-09-24 22:23:23', '1');
INSERT INTO `articles` VALUES ('29', '1', 'Linux 压缩命令', '', '## tar\r\n### 语法\r\n`tar [-cxzjvf] 压缩打包文档的名称 欲打包目录`\r\n### 参数\r\n-c（建立一个归档文件的参数指令）\r\n-x（解开一个归档文件的参数指令）\r\n-z（是否需要用 gzip 压缩）\r\n-j（是否需要用 bzip2 压缩）\r\n-v（压缩的过程中显示文件）\r\n-f（使用档名，在 f 之后要立即接档名）\r\n-tf（查看归档文件里面的文件）\r\n###例子\r\n压缩文件夹：tar -zcvf test.tar.gz test\\\r\n解压文件夹：tar -zxvf test.tar.gz\r\n## gzip\r\n###语法\r\n`gzip [选项] 压缩（解压缩）的文件名`\r\n### 参数\r\n-d（解压缩）\r\n-l（对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字）\r\n-v（对每一个压缩和解压的文件，显示文件名和压缩比）\r\n-num（用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6）\r\n\r\n*说明：压缩文件后缀为 gz*\r\n## bzip2\r\n### 语法\r\n`bzip2 [-cdz]`\r\n### 参数\r\nd（解压缩）\r\n-z（压缩参数）\r\n-num（用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6）\r\n\r\n*说明：压缩文件后缀为 bz2*', '<h2 id=\"h2-tar\"><a name=\"tar\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>tar</h2><h3 id=\"h3-u8BEDu6CD5\"><a name=\"语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法</h3><p><code>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</code></p>\r\n<h3 id=\"h3-u53C2u6570\"><a name=\"参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参数</h3><p>-c（建立一个归档文件的参数指令）<br>-x（解开一个归档文件的参数指令）<br>-z（是否需要用 gzip 压缩）<br>-j（是否需要用 bzip2 压缩）<br>-v（压缩的过程中显示文件）<br>-f（使用档名，在 f 之后要立即接档名）<br>-tf（查看归档文件里面的文件）\r\n<h3 id=\"h3-u4F8Bu5B50\"><a name=\"例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>例子</h3><p>压缩文件夹：tar -zcvf test.tar.gz test\\<br>解压文件夹：tar -zxvf test.tar.gz\r\n<h2 id=\"h2-gzip\"><a name=\"gzip\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>gzip</h2><h3 id=\"h3-u8BEDu6CD5\"><a name=\"语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法</h3><p><code>gzip [选项] 压缩（解压缩）的文件名</code></p>\r\n<h3 id=\"h3-u53C2u6570\"><a name=\"参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参数</h3><p>-d（解压缩）<br>-l（对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字）<br>-v（对每一个压缩和解压的文件，显示文件名和压缩比）<br>-num（用指定的数字num调整压缩的速度，-1或—fast表示最快压缩方法（低压缩比），-9或—best表示最慢压缩方法（高压缩比）。系统缺省值为6）\r\n<p><em>说明：压缩文件后缀为 gz</em></p>\r\n<h2 id=\"h2-bzip2\"><a name=\"bzip2\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>bzip2</h2><h3 id=\"h3-u8BEDu6CD5\"><a name=\"语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法</h3><p><code>bzip2 [-cdz]</code></p>\r\n<h3 id=\"h3-u53C2u6570\"><a name=\"参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参数</h3><p>d（解压缩）<br>-z（压缩参数）<br>-num（用指定的数字num调整压缩的速度，-1或—fast表示最快压缩方法（低压缩比），-9或—best表示最慢压缩方法（高压缩比）。系统缺省值为6）\r\n<p><em>说明：压缩文件后缀为 bz2</em></p>\r\n', null, null, null, '2020-09-23 22:25:41', '2020-09-24 22:22:45', '1');
INSERT INTO `articles` VALUES ('30', '1', 'Linux 编辑器', '', '##vim\r\n##运行模式\r\n编辑模式：等待编辑命令输入\r\n\r\n插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息\r\n\r\n命令模式：在编辑模式下，输入 : 进行命令模式\r\n\r\n##命令\r\n:q 直接退出vi\r\n\r\n:wq 保存后退出vi ，并可以新建文件\r\n\r\n:q! 强制退出\r\n\r\n:w file 将当前内容保存成某个文件\r\n\r\n:set number 在编辑文件显示行号\r\n\r\n:set nonumber 在编辑文件不显示行号\r\n\r\n##nano\r\nnano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。\r\n\r\n##命令\r\n保存：ctrl + o\r\n搜索：ctrl + w\r\n上一页：ctrl + y\r\n下一页：ctrl + v\r\n退出：ctrl + x', '<h2 id=\"h2-vim\"><a name=\"vim\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>vim</h2><h2 id=\"h2-u8FD0u884Cu6A21u5F0F\"><a name=\"运行模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行模式</h2><p>编辑模式：等待编辑命令输入</p>\r\n<p>插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息</p>\r\n<p>命令模式：在编辑模式下，输入 : 进行命令模式</p>\r\n<h2 id=\"h2-u547Du4EE4\"><a name=\"命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命令</h2><p>:q 直接退出vi</p>\r\n<p>:wq 保存后退出vi ，并可以新建文件</p>\r\n<p>:q! 强制退出</p>\r\n<p>:w file 将当前内容保存成某个文件</p>\r\n<p>:set number 在编辑文件显示行号</p>\r\n<p>:set nonumber 在编辑文件不显示行号</p>\r\n<h2 id=\"h2-nano\"><a name=\"nano\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>nano</h2><p>nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。</p>\r\n<h2 id=\"h2-u547Du4EE4\"><a name=\"命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命令</h2><p>保存：ctrl + o<br>搜索：ctrl + w<br>上一页：ctrl + y<br>下一页：ctrl + v<br>退出：ctrl + x\r\n', null, null, null, '2020-09-23 22:29:21', '2020-09-23 22:46:59', '1');
INSERT INTO `articles` VALUES ('31', '1', 'Linux 软件包管理', 'https://www.funtl.com/zh/linux/Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86.html', '> 概述：APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 /etc/apt/ 目录下的 sources.list 文件。\r\n\r\n##修改数据源\r\n由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下：\r\n\r\n##查看系统版本\r\n`lsb_release -a`\r\n输出结果为\r\n\r\n    No LSB modules are available.\r\n    Distributor ID:	Ubuntu\r\n    Description:	Ubuntu 16.04 LTS\r\n    Release:	16.04\r\n    Codename:	xenial\r\n注意： Codename 为 xenial，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称\r\n\r\n##编辑数据源\r\n`vi /etc/apt/sources.list`\r\n删除全部内容并修改为\r\n\r\n    deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\r\n    deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\r\n    deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\r\n    deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\r\n##更新数据源\r\n`apt-get update`\r\n##常用 APT 命令\r\n##安装软件包\r\n`apt-get install packagename`\r\n##删除软件包\r\n`apt-get remove packagename`\r\n##更新软件包列表\r\n`apt-get update`\r\n##升级有可用更新的系统（慎用）\r\n`apt-get upgrade`\r\n##其它 APT 命令\r\n##搜索\r\n`apt-cache search package`\r\n##获取包信息\r\n`apt-cache show package`\r\n##删除包及配置文件\r\n`apt-get remove package --purge`\r\n##了解使用依赖\r\n`apt-cache depends package`\r\n##查看被哪些包依赖\r\n`apt-cache rdepends package`\r\n##安装相关的编译环境\r\n`apt-get build-dep package`\r\n##下载源代码\r\n`apt-get source package`\r\n##清理无用的包\r\n`apt-get clean && apt-get autoclean`\r\n##检查是否有损坏的依赖\r\n`apt-get check`', '<blockquote>\r\n<p>概述：APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 /etc/apt/ 目录下的 sources.list 文件。</p>\r\n</blockquote>\r\n<h2 id=\"h2-u4FEEu6539u6570u636Eu6E90\"><a name=\"修改数据源\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>修改数据源</h2><p>由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下：</p>\r\n<h2 id=\"h2-u67E5u770Bu7CFBu7EDFu7248u672C\"><a name=\"查看系统版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看系统版本</h2><p><code>lsb_release -a</code><br>输出结果为\r\n<pre><code>No LSB modules are available.\r\nDistributor ID:    Ubuntu\r\nDescription:    Ubuntu 16.04 LTS\r\nRelease:    16.04\r\nCodename:    xenial\r\n</code></pre><p>注意： Codename 为 xenial，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称</p>\r\n<h2 id=\"h2-u7F16u8F91u6570u636Eu6E90\"><a name=\"编辑数据源\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>编辑数据源</h2><p><code>vi /etc/apt/sources.list</code><br>删除全部内容并修改为\r\n<pre><code>deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\r\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\r\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\r\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\r\n</code></pre><h2 id=\"h2-u66F4u65B0u6570u636Eu6E90\"><a name=\"更新数据源\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新数据源</h2><p><code>apt-get update</code></p>\r\n<h2 id=\"h2--apt-\"><a name=\"常用 APT 命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用 APT 命令</h2><h2 id=\"h2-u5B89u88C5u8F6Fu4EF6u5305\"><a name=\"安装软件包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装软件包</h2><p><code>apt-get install packagename</code></p>\r\n<h2 id=\"h2-u5220u9664u8F6Fu4EF6u5305\"><a name=\"删除软件包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除软件包</h2><p><code>apt-get remove packagename</code></p>\r\n<h2 id=\"h2-u66F4u65B0u8F6Fu4EF6u5305u5217u8868\"><a name=\"更新软件包列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新软件包列表</h2><p><code>apt-get update</code></p>\r\n<h2 id=\"h2--\"><a name=\"升级有可用更新的系统（慎用）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>升级有可用更新的系统（慎用）</h2><p><code>apt-get upgrade</code></p>\r\n<h2 id=\"h2--apt-\"><a name=\"其它 APT 命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其它 APT 命令</h2><h2 id=\"h2-u641Cu7D22\"><a name=\"搜索\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>搜索</h2><p><code>apt-cache search package</code></p>\r\n<h2 id=\"h2-u83B7u53D6u5305u4FE1u606F\"><a name=\"获取包信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取包信息</h2><p><code>apt-cache show package</code></p>\r\n<h2 id=\"h2-u5220u9664u5305u53CAu914Du7F6Eu6587u4EF6\"><a name=\"删除包及配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除包及配置文件</h2><p><code>apt-get remove package --purge</code></p>\r\n<h2 id=\"h2-u4E86u89E3u4F7Fu7528u4F9Du8D56\"><a name=\"了解使用依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>了解使用依赖</h2><p><code>apt-cache depends package</code></p>\r\n<h2 id=\"h2-u67E5u770Bu88ABu54EAu4E9Bu5305u4F9Du8D56\"><a name=\"查看被哪些包依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看被哪些包依赖</h2><p><code>apt-cache rdepends package</code></p>\r\n<h2 id=\"h2-u5B89u88C5u76F8u5173u7684u7F16u8BD1u73AFu5883\"><a name=\"安装相关的编译环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装相关的编译环境</h2><p><code>apt-get build-dep package</code></p>\r\n<h2 id=\"h2-u4E0Bu8F7Du6E90u4EE3u7801\"><a name=\"下载源代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载源代码</h2><p><code>apt-get source package</code></p>\r\n<h2 id=\"h2-u6E05u7406u65E0u7528u7684u5305\"><a name=\"清理无用的包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>清理无用的包</h2><p><code>apt-get clean &amp;&amp; apt-get autoclean</code></p>\r\n<h2 id=\"h2-u68C0u67E5u662Fu5426u6709u635Fu574Fu7684u4F9Du8D56\"><a name=\"检查是否有损坏的依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>检查是否有损坏的依赖</h2><p><code>apt-get check</code></p>\r\n', null, null, null, '2020-09-23 22:36:03', '2020-09-24 22:21:23', '1');
INSERT INTO `articles` VALUES ('32', '1', 'Linux 用户和组管理', '', '> 概述：Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。\r\n\r\n##使用 Root 用户\r\n在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。\r\n\r\n##设置 Root 账户密码\r\n`sudo passwd root`\r\n##切换到 Root\r\n`su`\r\n##设置允许远程登录 Root\r\n`nano /etc/ssh/sshd_config`\r\n\r\n## Authentication:\r\n\r\n\r\n    LoginGraceTime 120\r\n    PermitRootLogin without-password     //注释此行\r\n    PermitRootLogin yes                             //加入此行\r\n    StrictModes yes\r\n\r\n重启服务\r\n`service ssh restart`\r\n##用户账户说明\r\n##普通用户\r\n普通用户在系统上的任务是进行普通操作\r\n\r\n##超级管理员\r\n管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。\r\n\r\n##安装时创建的系统用户\r\n此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。\r\n\r\n##组账户说明\r\n##私有组\r\n当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。\r\n\r\n##标准组\r\n当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。\r\n\r\n##账户系统文件说明\r\n##/etc/passwd\r\n每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：\r\n\r\n    root:x:0:0:root:/root:/bin/bash\r\n\r\n用户名： 就是账号，用来对应 UID，root UID 是 0。\r\n口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。\r\n用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。\r\n组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。\r\n注释： 注释账号\r\n宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast\r\n命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash\r\n##/etc/shadow\r\n为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：\r\n\r\n    root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::\r\n\r\n账号名称： 需要和 /etc/passwd 一致。\r\n密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：\r\n`    -rw------- 1 root root 1560 Oct 26 17:20 passwd-`\r\n只有root能都读写\r\n最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数\r\n密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数\r\n密码最大时间间隔： 从1970-1-1起，必须更改的口令天数\r\n密码到期警告时间： 在口令过期之前几天通知\r\n密码到期后账号宽限时间\r\n密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数\r\n保留\r\n##/etc/group\r\n用户组的配置文件\r\n\r\n    root:x:0:\r\n\r\n用户组名称\r\n用户组密码： 给用户组管理员使用，通常不用\r\nGID： 用户组的ID\r\n此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。\r\n##/etc/gshadow\r\n该文件用户定义用户组口令，组管理员等信息只有root用户可读。\r\n\r\n`root:\\*::`\r\n\r\n用户组名\r\n密码列\r\n用户组管理员的账号\r\n用户组所属账号\r\n##账户管理常用命令\r\n##增加用户\r\n\r\n\r\n    useradd 用户名\r\n    useradd -u (UID号)\r\n    useradd -p (口令)\r\n    useradd -g (分组)\r\n    useradd -s (SHELL)\r\n    useradd -d (用户目录)\r\n如：useradd sunyue\r\n\r\n增加用户名为 lusifer 的账户\r\n\r\n##修改用户\r\n\r\n\r\n    usermod -u (新UID)\r\n    usermod -d (用户目录)\r\n    usermod -g (组名)\r\n    usermod -s (SHELL)\r\n    usermod -p (新口令)\r\n    usermod -l (新登录名)\r\n    usermod -L (锁定用户账号密码)\r\n    usermod -U (解锁用户账号)\r\n如：usermod -u 1024 -g group2 -G root sunyue\r\n\r\n将 sunyue 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组\r\n\r\n##删除用户\r\n`userdel 用户名 (删除用户账号)`\r\n`userdel -r 删除账号时同时删除目录`\r\n如：userdel -r sunyue\r\n\r\n删除用户名为 sunyue 的账户并同时删除 sunyue 的用户目录\r\n\r\n##组账户维护\r\n\r\n\r\n    groupadd 组账户名 (创建新组)\r\n    groupadd -g 指定组GID\r\n    groupmod -g 更改组的GID\r\n    groupmod -n 更改组账户名\r\n    groupdel 组账户名 (删除指定组账户)\r\n##口令维护\r\n\r\n\r\n    passwd 用户账户名 (设置用户口令)\r\n    passwd -l 用户账户名 (锁定用户账户)\r\n    passwd -u 用户账户名 (解锁用户账户)\r\n    passwd -d 用户账户名 (删除账户口令)\r\n    gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)\r\n    gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)\r\n    gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员)\r\n##用户和组状态\r\n\r\n\r\n    su 用户名(切换用户账户)\r\n    id 用户名(显示用户的UID，GID)\r\n    whoami (显示当前用户名称)\r\n    groups (显示用户所属组)', '<blockquote>\r\n<p>概述：Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。</p>\r\n</blockquote>\r\n<h2 id=\"h2--root-\"><a name=\"使用 Root 用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用 Root 用户</h2><p>在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。</p>\r\n<h2 id=\"h2--root-\"><a name=\"设置 Root 账户密码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置 Root 账户密码</h2><p><code>sudo passwd root</code></p>\r\n<h2 id=\"h2--root\"><a name=\"切换到 Root\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>切换到 Root</h2><p><code>su</code></p>\r\n<h2 id=\"h2--root\"><a name=\"设置允许远程登录 Root\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置允许远程登录 Root</h2><p><code>nano /etc/ssh/sshd_config</code></p>\r\n<h2 id=\"h2-authentication-\"><a name=\"Authentication:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Authentication:</h2><pre><code>LoginGraceTime 120\r\nPermitRootLogin without-password     //注释此行\r\nPermitRootLogin yes                             //加入此行\r\nStrictModes yes\r\n</code></pre><p>重启服务<br><code>service ssh restart</code></p>\r\n<h2 id=\"h2-u7528u6237u8D26u6237u8BF4u660E\"><a name=\"用户账户说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>用户账户说明</h2><h2 id=\"h2-u666Eu901Au7528u6237\"><a name=\"普通用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>普通用户</h2><p>普通用户在系统上的任务是进行普通操作</p>\r\n<h2 id=\"h2-u8D85u7EA7u7BA1u7406u5458\"><a name=\"超级管理员\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>超级管理员</h2><p>管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。</p>\r\n<h2 id=\"h2-u5B89u88C5u65F6u521Bu5EFAu7684u7CFBu7EDFu7528u6237\"><a name=\"安装时创建的系统用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装时创建的系统用户</h2><p>此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。</p>\r\n<h2 id=\"h2-u7EC4u8D26u6237u8BF4u660E\"><a name=\"组账户说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>组账户说明</h2><h2 id=\"h2-u79C1u6709u7EC4\"><a name=\"私有组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>私有组</h2><p>当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。</p>\r\n<h2 id=\"h2-u6807u51C6u7EC4\"><a name=\"标准组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>标准组</h2><p>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。</p>\r\n<h2 id=\"h2-u8D26u6237u7CFBu7EDFu6587u4EF6u8BF4u660E\"><a name=\"账户系统文件说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>账户系统文件说明</h2><h2 id=\"h2--etc-passwd\"><a name=\"/etc/passwd\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>/etc/passwd</h2><p>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：</p>\r\n<pre><code>root:x:0:0:root:/root:/bin/bash\r\n</code></pre><p>用户名： 就是账号，用来对应 UID，root UID 是 0。<br>口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。<br>用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。<br>组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。<br>注释： 注释账号<br>宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast<br>命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash\r\n<h2 id=\"h2--etc-shadow\"><a name=\"/etc/shadow\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>/etc/shadow</h2><p>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：</p>\r\n<pre><code>root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::\r\n</code></pre><p>账号名称： 需要和 /etc/passwd 一致。<br>密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：<br><code>-rw------- 1 root root 1560 Oct 26 17:20 passwd-</code><br>只有root能都读写<br>最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数<br>密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数<br>密码最大时间间隔： 从1970-1-1起，必须更改的口令天数<br>密码到期警告时间： 在口令过期之前几天通知<br>密码到期后账号宽限时间<br>密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数<br>保留\r\n<h2 id=\"h2--etc-group\"><a name=\"/etc/group\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>/etc/group</h2><p>用户组的配置文件</p>\r\n<pre><code>root:x:0:\r\n</code></pre><p>用户组名称<br>用户组密码： 给用户组管理员使用，通常不用<br>GID： 用户组的ID<br>此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。\r\n<h2 id=\"h2--etc-gshadow\"><a name=\"/etc/gshadow\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>/etc/gshadow</h2><p>该文件用户定义用户组口令，组管理员等信息只有root用户可读。</p>\r\n<p><code>root:\\*::</code></p>\r\n<p>用户组名<br>密码列<br>用户组管理员的账号<br>用户组所属账号\r\n<h2 id=\"h2-u8D26u6237u7BA1u7406u5E38u7528u547Du4EE4\"><a name=\"账户管理常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>账户管理常用命令</h2><h2 id=\"h2-u589Eu52A0u7528u6237\"><a name=\"增加用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>增加用户</h2><pre><code>useradd 用户名\r\nuseradd -u (UID号)\r\nuseradd -p (口令)\r\nuseradd -g (分组)\r\nuseradd -s (SHELL)\r\nuseradd -d (用户目录)\r\n</code></pre><p>如：useradd sunyue</p>\r\n<p>增加用户名为 lusifer 的账户</p>\r\n<h2 id=\"h2-u4FEEu6539u7528u6237\"><a name=\"修改用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>修改用户</h2><pre><code>usermod -u (新UID)\r\nusermod -d (用户目录)\r\nusermod -g (组名)\r\nusermod -s (SHELL)\r\nusermod -p (新口令)\r\nusermod -l (新登录名)\r\nusermod -L (锁定用户账号密码)\r\nusermod -U (解锁用户账号)\r\n</code></pre><p>如：usermod -u 1024 -g group2 -G root sunyue</p>\r\n<p>将 sunyue 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组</p>\r\n<h2 id=\"h2-u5220u9664u7528u6237\"><a name=\"删除用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除用户</h2><p><code>userdel 用户名 (删除用户账号)</code><br><code>userdel -r 删除账号时同时删除目录</code><br>如：userdel -r sunyue\r\n<p>删除用户名为 sunyue 的账户并同时删除 sunyue 的用户目录</p>\r\n<h2 id=\"h2-u7EC4u8D26u6237u7EF4u62A4\"><a name=\"组账户维护\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>组账户维护</h2><pre><code>groupadd 组账户名 (创建新组)\r\ngroupadd -g 指定组GID\r\ngroupmod -g 更改组的GID\r\ngroupmod -n 更改组账户名\r\ngroupdel 组账户名 (删除指定组账户)\r\n</code></pre><h2 id=\"h2-u53E3u4EE4u7EF4u62A4\"><a name=\"口令维护\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>口令维护</h2><pre><code>passwd 用户账户名 (设置用户口令)\r\npasswd -l 用户账户名 (锁定用户账户)\r\npasswd -u 用户账户名 (解锁用户账户)\r\npasswd -d 用户账户名 (删除账户口令)\r\ngpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)\r\ngpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)\r\ngpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员)\r\n</code></pre><h2 id=\"h2-u7528u6237u548Cu7EC4u72B6u6001\"><a name=\"用户和组状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>用户和组状态</h2><pre><code>su 用户名(切换用户账户)\r\nid 用户名(显示用户的UID，GID)\r\nwhoami (显示当前用户名称)\r\ngroups (显示用户所属组)\r\n</code></pre>', null, null, null, '2020-09-23 22:37:37', '2020-09-24 22:19:01', '1');
INSERT INTO `articles` VALUES ('33', '1', 'Linux 文件权限管理', '', '##查看文件和目录的权限\r\nls –al使用 ls 不带参数只显示文件名称，通过ls –al 可以显示文件或者目录的权限信息。\r\n\r\nls -l 文件名 显示信息包括：文件类型 (d 目录，- 普通文件，l 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称\r\n\r\n`-rw-r--r-- 1 sunyue sunyue 675 Oct 26 17:20 .profile`\r\n\r\n-：普通文件\r\nrw-：说明用户 sunyue 有读写权限，没有运行权限\r\nr--：表示用户组 sunyue 只有读权限，没有写和运行的权限\r\nr--：其他用户只有读权限，没有写权限和运行的权限\r\n\r\n`-rw-r--r--	1	sunyue	sunyue	675	Oct 26 17:20	.profile`\r\n文档类型及权限	连接数	文档所属用户	文档所属组	文档大小	文档最后被修改日期	文档名称\r\n\r\n`--- rw-	r--	r--`\r\n文档类型	文档所有者权限（user）	文档所属用户组权限（group）	其他用户权限（other）\r\n##文档类型\r\nd 表示目录\r\nl 表示软连接\r\n– 表示文件\r\nc 表示串行端口字符设备文件\r\nb 表示可供存储的块设备文件\r\n余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限\r\n##连接数\r\n指有多少个文件指向同一个索引节点。\r\n\r\n##文档所属用户和所属组\r\n就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的\r\n\r\n##文档大小\r\n默认是 bytes\r\n\r\n##更改操作权限\r\n##chown\r\n是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组\r\n\r\n`chown [-R] 用户名称 文件或者目录`\r\n\r\n`chown [-R] 用户名称 用户组名称 文件或目录`\r\n\r\n-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限\r\n\r\n##chmod\r\n改变访问权限\r\n\r\n`chmod [who] [+ | - | =] [mode] 文件名`\r\n\r\n##who\r\n表示操作对象可以是以下字母的一个或者组合\r\n\r\nu：用户 user\r\ng：用户组 group\r\no：表示其他用户\r\na：表示所有用户是系统默认的\r\n##操作符号\r\n+：表示添加某个权限\r\n-：表示取消某个权限\r\n=：赋予给定的权限，取消文档以前的所有权限\r\n##mode\r\n表示可执行的权限，可以是 r、w、x\r\n\r\n##文件名\r\n文件名可以使空格分开的文件列表\r\n\r\n##示例\r\n    sunyue@UbuntuBase:~$ ls -al test.txt \r\n    -rw-rw-r-- 1 sunyue sunyue 6 Nov  2 21:47 test.txt\r\n    sunyue@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt \r\n    sunyue@UbuntuBase:~$ ls -al test.txt \r\n    -rwxrw-r-- 1 sunyue sunyue 6 Nov  2 21:47 test.txt\r\n    sunyue@UbuntuBase:~$\r\n##数字设定法\r\n数字设定法中数字表示的含义\r\n\r\n0 表示没有任何权限\r\n1 表示有可执行权限 = x\r\n2 表示有可写权限 = w\r\n4 表示有可读权限 = r\r\n也可以用数字来表示权限如 chmod 755 file_name\r\n\r\nr w x	r – x	r - x\r\n4 2 1	4 - 1	4 - 1\r\nuser	group	others\r\n若要 rwx 属性则 4+2+1=7\r\n\r\n若要 rw- 属性则 4+2=6\r\n\r\n若要 r-x 属性则 4+1=5\r\n\r\n    sunyue@UbuntuBase:~$ chmod 777 test.txt \r\n    sunyue@UbuntuBase:~$ ls -al test.txt \r\n    -rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txt\r\n    \r\n    sunyue@UbuntuBase:~$ chmod 770 test.txt \r\n    sunyue@UbuntuBase:~$ ls -al test.txt \r\n    -rwxrwx--- 1 sunyue sunyue 6 Nov  2 21:47 test.txt', '<h2 id=\"h2-u67E5u770Bu6587u4EF6u548Cu76EEu5F55u7684u6743u9650\"><a name=\"查看文件和目录的权限\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看文件和目录的权限</h2><p>ls –al使用 ls 不带参数只显示文件名称，通过ls –al 可以显示文件或者目录的权限信息。</p>\r\n<p>ls -l 文件名 显示信息包括：文件类型 (d 目录，- 普通文件，l 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称</p>\r\n<p><code>-rw-r--r-- 1 sunyue sunyue 675 Oct 26 17:20 .profile</code></p>\r\n<p>-：普通文件<br>rw-：说明用户 sunyue 有读写权限，没有运行权限<br>r—：表示用户组 sunyue 只有读权限，没有写和运行的权限<br>r—：其他用户只有读权限，没有写权限和运行的权限\r\n<p><code>-rw-r--r--    1    sunyue    sunyue    675    Oct 26 17:20    .profile</code><br>文档类型及权限    连接数    文档所属用户    文档所属组    文档大小    文档最后被修改日期    文档名称\r\n<p><code>--- rw-    r--    r--</code><br>文档类型    文档所有者权限（user）    文档所属用户组权限（group）    其他用户权限（other）\r\n<h2 id=\"h2-u6587u6863u7C7Bu578B\"><a name=\"文档类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文档类型</h2><p>d 表示目录<br>l 表示软连接<br>– 表示文件<br>c 表示串行端口字符设备文件<br>b 表示可供存储的块设备文件<br>余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限\r\n<h2 id=\"h2-u8FDEu63A5u6570\"><a name=\"连接数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>连接数</h2><p>指有多少个文件指向同一个索引节点。</p>\r\n<h2 id=\"h2-u6587u6863u6240u5C5Eu7528u6237u548Cu6240u5C5Eu7EC4\"><a name=\"文档所属用户和所属组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文档所属用户和所属组</h2><p>就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的</p>\r\n<h2 id=\"h2-u6587u6863u5927u5C0F\"><a name=\"文档大小\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文档大小</h2><p>默认是 bytes</p>\r\n<h2 id=\"h2-u66F4u6539u64CDu4F5Cu6743u9650\"><a name=\"更改操作权限\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更改操作权限</h2><h2 id=\"h2-chown\"><a name=\"chown\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>chown</h2><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组</p>\r\n<p><code>chown [-R] 用户名称 文件或者目录</code></p>\r\n<p><code>chown [-R] 用户名称 用户组名称 文件或目录</code></p>\r\n<p>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p>\r\n<h2 id=\"h2-chmod\"><a name=\"chmod\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>chmod</h2><p>改变访问权限</p>\r\n<p><code>chmod [who] [+ | - | =] [mode] 文件名</code></p>\r\n<h2 id=\"h2-who\"><a name=\"who\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>who</h2><p>表示操作对象可以是以下字母的一个或者组合</p>\r\n<p>u：用户 user<br>g：用户组 group<br>o：表示其他用户<br>a：表示所有用户是系统默认的\r\n<h2 id=\"h2-u64CDu4F5Cu7B26u53F7\"><a name=\"操作符号\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>操作符号</h2><p>+：表示添加某个权限<br>-：表示取消某个权限<br>=：赋予给定的权限，取消文档以前的所有权限\r\n<h2 id=\"h2-mode\"><a name=\"mode\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>mode</h2><p>表示可执行的权限，可以是 r、w、x</p>\r\n<h2 id=\"h2-u6587u4EF6u540D\"><a name=\"文件名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文件名</h2><p>文件名可以使空格分开的文件列表</p>\r\n<h2 id=\"h2-u793Au4F8B\"><a name=\"示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>示例</h2><pre><code>sunyue@UbuntuBase:~$ ls -al test.txt \r\n-rw-rw-r-- 1 sunyue sunyue 6 Nov  2 21:47 test.txt\r\nsunyue@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt \r\nsunyue@UbuntuBase:~$ ls -al test.txt \r\n-rwxrw-r-- 1 sunyue sunyue 6 Nov  2 21:47 test.txt\r\nsunyue@UbuntuBase:~$\r\n</code></pre><h2 id=\"h2-u6570u5B57u8BBEu5B9Au6CD5\"><a name=\"数字设定法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数字设定法</h2><p>数字设定法中数字表示的含义</p>\r\n<p>0 表示没有任何权限<br>1 表示有可执行权限 = x<br>2 表示有可写权限 = w<br>4 表示有可读权限 = r<br>也可以用数字来表示权限如 chmod 755 file_name\r\n<p>r w x    r – x    r - x<br>4 2 1    4 - 1    4 - 1<br>user    group    others<br>若要 rwx 属性则 4+2+1=7\r\n<p>若要 rw- 属性则 4+2=6</p>\r\n<p>若要 r-x 属性则 4+1=5</p>\r\n<pre><code>sunyue@UbuntuBase:~$ chmod 777 test.txt \r\nsunyue@UbuntuBase:~$ ls -al test.txt \r\n-rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txt\r\n\r\nsunyue@UbuntuBase:~$ chmod 770 test.txt \r\nsunyue@UbuntuBase:~$ ls -al test.txt \r\n-rwxrwx--- 1 sunyue sunyue 6 Nov  2 21:47 test.txt\r\n</code></pre>', null, null, null, '2020-09-23 22:42:53', '2020-09-24 22:14:00', '1');
INSERT INTO `articles` VALUES ('34', '1', 'Linux 安装 Java', '', '> 概述：此处以 JDK 1.8.0_152 为例\r\n\r\n##下载地址\r\nhttp://www.oracle.com/technetwork/java/javase/downloads/index.html\r\n\r\n##解压缩并移动到指定目录\r\n##解压缩\r\n`tar -zxvf jdk-8u152-linux-x64.tar.gz`\r\n##创建目录\r\n`mkdir -p /usr/local/java`\r\n##移动安装包\r\n`mv jdk1.8.0_152/ /usr/local/java/`\r\n##设置所有者\r\n`chown -R root:root /usr/local/java/`\r\n##配置环境变量\r\n##配置系统环境变量\r\n`nano /etc/environment`\r\n##添加如下语句\r\n\r\n\r\n    PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\"\r\n    export JAVA_HOME=/usr/local/java/jdk1.8.0_152\r\n    export JRE_HOME=/usr/local/java/jdk1.8.0_152/jre\r\n    export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\r\n##配置用户环境变量\r\n`nano /etc/profile`\r\n##添加如下语句\r\n\r\n\r\n    if [ \"$PS1\" ]; then\r\n      if [ \"$BASH\" ] && [ \"$BASH\" != \"/bin/sh\" ]; then\r\n        # The file bash.bashrc already sets the default PS1.\r\n        # PS1=\'\\h:\\w\\$ \'\r\n        if [ -f /etc/bash.bashrc ]; then\r\n          . /etc/bash.bashrc\r\n        fi\r\n      else\r\n        if [ \"`id -u`\" -eq 0 ]; then\r\n          PS1=\'# \'\r\n        else\r\n          PS1=\'$ \'\r\n        fi\r\n      fi\r\n    fi\r\n    \r\n    export JAVA_HOME=/usr/local/java/jdk1.8.0_152\r\n    export JRE_HOME=/usr/local/java/jdk1.8.0_152/jre\r\n    export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\r\n    export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin\r\n    \r\n    if [ -d /etc/profile.d ]; then\r\n      for i in /etc/profile.d/*.sh; do\r\n        if [ -r $i ]; then\r\n          . $i\r\n        fi\r\n      done\r\n      unset i\r\n    fi\r\n##使用户环境变量生效\r\n`source /etc/profile`\r\n##测试是否安装成功\r\n\r\n\r\n    root@UbuntuBase:/usr/local/java# java -version\r\n    java version \"1.8.0_152\"\r\n    Java(TM) SE Runtime Environment (build 1.8.0_152-b16)\r\n    Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)\r\n##为其他用户更新用户环境变量\r\n`su sunyue`\r\n`source /etc/profile`', '<blockquote>\r\n<p>概述：此处以 JDK 1.8.0_152 为例</p>\r\n</blockquote>\r\n<h2 id=\"h2-u4E0Bu8F7Du5730u5740\"><a name=\"下载地址\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载地址</h2><p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>\r\n<h2 id=\"h2-u89E3u538Bu7F29u5E76u79FBu52A8u5230u6307u5B9Au76EEu5F55\"><a name=\"解压缩并移动到指定目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>解压缩并移动到指定目录</h2><h2 id=\"h2-u89E3u538Bu7F29\"><a name=\"解压缩\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>解压缩</h2><p><code>tar -zxvf jdk-8u152-linux-x64.tar.gz</code></p>\r\n<h2 id=\"h2-u521Bu5EFAu76EEu5F55\"><a name=\"创建目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建目录</h2><p><code>mkdir -p /usr/local/java</code></p>\r\n<h2 id=\"h2-u79FBu52A8u5B89u88C5u5305\"><a name=\"移动安装包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>移动安装包</h2><p><code>mv jdk1.8.0_152/ /usr/local/java/</code></p>\r\n<h2 id=\"h2-u8BBEu7F6Eu6240u6709u8005\"><a name=\"设置所有者\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置所有者</h2><p><code>chown -R root:root /usr/local/java/</code></p>\r\n<h2 id=\"h2-u914Du7F6Eu73AFu5883u53D8u91CF\"><a name=\"配置环境变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置环境变量</h2><h2 id=\"h2-u914Du7F6Eu7CFBu7EDFu73AFu5883u53D8u91CF\"><a name=\"配置系统环境变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置系统环境变量</h2><p><code>nano /etc/environment</code></p>\r\n<h2 id=\"h2-u6DFBu52A0u5982u4E0Bu8BEDu53E5\"><a name=\"添加如下语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>添加如下语句</h2><pre><code>PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\"\r\nexport JAVA_HOME=/usr/local/java/jdk1.8.0_152\r\nexport JRE_HOME=/usr/local/java/jdk1.8.0_152/jre\r\nexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\r\n</code></pre><h2 id=\"h2-u914Du7F6Eu7528u6237u73AFu5883u53D8u91CF\"><a name=\"配置用户环境变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置用户环境变量</h2><p><code>nano /etc/profile</code></p>\r\n<h2 id=\"h2-u6DFBu52A0u5982u4E0Bu8BEDu53E5\"><a name=\"添加如下语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>添加如下语句</h2><pre><code>if [ \"$PS1\" ]; then\r\n  if [ \"$BASH\" ] &amp;&amp; [ \"$BASH\" != \"/bin/sh\" ]; then\r\n    # The file bash.bashrc already sets the default PS1.\r\n    # PS1=\'\\h:\\w\\$ \'\r\n    if [ -f /etc/bash.bashrc ]; then\r\n      . /etc/bash.bashrc\r\n    fi\r\n  else\r\n    if [ \"`id -u`\" -eq 0 ]; then\r\n      PS1=\'# \'\r\n    else\r\n      PS1=\'$ \'\r\n    fi\r\n  fi\r\nfi\r\n\r\nexport JAVA_HOME=/usr/local/java/jdk1.8.0_152\r\nexport JRE_HOME=/usr/local/java/jdk1.8.0_152/jre\r\nexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\r\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin\r\n\r\nif [ -d /etc/profile.d ]; then\r\n  for i in /etc/profile.d/*.sh; do\r\n    if [ -r $i ]; then\r\n      . $i\r\n    fi\r\n  done\r\n  unset i\r\nfi\r\n</code></pre><h2 id=\"h2-u4F7Fu7528u6237u73AFu5883u53D8u91CFu751Fu6548\"><a name=\"使用户环境变量生效\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用户环境变量生效</h2><p><code>source /etc/profile</code></p>\r\n<h2 id=\"h2-u6D4Bu8BD5u662Fu5426u5B89u88C5u6210u529F\"><a name=\"测试是否安装成功\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试是否安装成功</h2><pre><code>root@UbuntuBase:/usr/local/java# java -version\r\njava version \"1.8.0_152\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_152-b16)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)\r\n</code></pre><h2 id=\"h2-u4E3Au5176u4ED6u7528u6237u66F4u65B0u7528u6237u73AFu5883u53D8u91CF\"><a name=\"为其他用户更新用户环境变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为其他用户更新用户环境变量</h2><p><code>su sunyue</code><br><code>source /etc/profile</code></p>\r\n', null, null, null, '2020-09-24 22:10:26', '2020-09-24 22:47:01', '1');
INSERT INTO `articles` VALUES ('35', '1', 'Linux 安装 Tomcat', '', '> 概述:此处以 Tomcat 8.5.23 为例\r\n\r\n##下载地址\r\nhttps://tomcat.apache.org/\r\n解压缩并移动到指定目录\r\n##解压缩\r\n`tar -zxvf apache-tomcat-8.5.23.tar.gz`\r\n##变更目录名\r\n`mv apache-tomcat-8.5.23 tomcat`\r\n##移动目录\r\n`mv tomcat/ /usr/local/`\r\n##常用命令\r\n##启动\r\n`/usr/local/tomcat/bin/startup.sh`\r\n##停止\r\n`/usr/local/tomcat/bin/shutdown.sh`\r\n##目录内执行脚本\r\n`./startup.sh`', '<blockquote>\r\n<p>概述:此处以 Tomcat 8.5.23 为例</p>\r\n</blockquote>\r\n<h2 id=\"h2-u4E0Bu8F7Du5730u5740\"><a name=\"下载地址\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载地址</h2><p><a href=\"https://tomcat.apache.org/\">https://tomcat.apache.org/</a><br>解压缩并移动到指定目录\r\n<h2 id=\"h2-u89E3u538Bu7F29\"><a name=\"解压缩\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>解压缩</h2><p><code>tar -zxvf apache-tomcat-8.5.23.tar.gz</code></p>\r\n<h2 id=\"h2-u53D8u66F4u76EEu5F55u540D\"><a name=\"变更目录名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>变更目录名</h2><p><code>mv apache-tomcat-8.5.23 tomcat</code></p>\r\n<h2 id=\"h2-u79FBu52A8u76EEu5F55\"><a name=\"移动目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>移动目录</h2><p><code>mv tomcat/ /usr/local/</code></p>\r\n<h2 id=\"h2-u5E38u7528u547Du4EE4\"><a name=\"常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用命令</h2><h2 id=\"h2-u542Fu52A8\"><a name=\"启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动</h2><p><code>/usr/local/tomcat/bin/startup.sh</code></p>\r\n<h2 id=\"h2-u505Cu6B62\"><a name=\"停止\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止</h2><p><code>/usr/local/tomcat/bin/shutdown.sh</code></p>\r\n<h2 id=\"h2-u76EEu5F55u5185u6267u884Cu811Au672C\"><a name=\"目录内执行脚本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录内执行脚本</h2><p><code>./startup.sh</code></p>\r\n', null, null, null, '2020-09-24 22:27:32', '2020-09-24 22:46:35', '1');
INSERT INTO `articles` VALUES ('36', '1', 'Linux 安装 MySQL', '', '##安装\r\n###更新数据源\r\n`apt-get update`\r\n###安装 MySQL\r\n`apt-get install mysql-server`\r\n系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。\r\n\r\n###配置\r\n因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。\r\n\r\n运行安全脚本：\r\n\r\n`mysql_secure_installation`\r\n这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。\r\n\r\n###测试\r\n按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。\r\n\r\n\r\n\r\n    sunyue@ubuntu:~$ systemctl status mysql.service\r\n    ● mysql.service - MySQL Community Server\r\n       Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)\r\n       Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago\r\n     Main PID: 2169 (mysqld)\r\n       CGroup: /system.slice/mysql.service\r\n               └─2169 /usr/sbin/mysqld\r\n    \r\n    Nov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...\r\n    Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server.\r\n查看 MySQL 版本：\r\n\r\n`mysqladmin -p -u root version`\r\n###配置远程访问\r\n修改配置文件\r\n`nano /etc/mysql/mysql.conf.d/mysqld.cnf`\r\n注释掉(语句前面加上 # 即可)：\r\n`bind-address = 127.0.0.1`\r\n重启 MySQL\r\n`service mysql restart`\r\n登录 MySQL\r\n`mysql -u root -p`\r\n授权 root 用户允许所有人连接\r\n`grant all privileges on *.* to \'root\'@\'%\' identified by \'你的 mysql root 账户密码\';`\r\n###因弱口令无法成功授权解决步骤\r\n查看和设置密码安全级别\r\n\r\n\r\n    select @@validate_password_policy;\r\n    set global validate_password_policy=0;\r\n查看和设置密码长度限制\r\n\r\n\r\n    select @@validate_password_length;\r\n    set global validate_password_length=1;\r\n###常用命令\r\n###启动\r\n`service mysql start`\r\n###停止\r\n`service mysql stop`\r\n###重启\r\n`service mysql restart`\r\n###其它配置\r\n修改配置 mysqld.cnf 配置文件\r\n\r\n`vi /etc/mysql/mysql.conf.d/mysqld.cnf`\r\n###配置默认字符集\r\n在 [mysqld] 节点上增加如下配置\r\n\r\n[client]\r\n`default-character-set=utf8`\r\n在 [mysqld] 节点底部增加如下配置\r\n\r\n\r\n\r\n    default-storage-engine=INNODB\r\n    character-set-server=utf8\r\n    collation-server=utf8_general_ci\r\n#配置忽略数据库大小写敏感\r\n在 [mysqld] 节点底部增加如下配置\r\n\r\n`lower-case-table-names = 1`', '<h2 id=\"h2-u5B89u88C5\"><a name=\"安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装</h2><h3 id=\"h3-u66F4u65B0u6570u636Eu6E90\"><a name=\"更新数据源\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新数据源</h3><p><code>apt-get update</code></p>\r\n<h3 id=\"h3--mysql\"><a name=\"安装 MySQL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装 MySQL</h3><p><code>apt-get install mysql-server</code><br>系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。\r\n<h3 id=\"h3-u914Du7F6E\"><a name=\"配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置</h3><p>因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。</p>\r\n<p>运行安全脚本：</p>\r\n<p><code>mysql_secure_installation</code><br>这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。\r\n<h3 id=\"h3-u6D4Bu8BD5\"><a name=\"测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试</h3><p>按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。</p>\r\n<pre><code>sunyue@ubuntu:~$ systemctl status mysql.service\r\n● mysql.service - MySQL Community Server\r\n   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)\r\n   Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago\r\n Main PID: 2169 (mysqld)\r\n   CGroup: /system.slice/mysql.service\r\n           └─2169 /usr/sbin/mysqld\r\n\r\nNov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...\r\nNov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server.\r\n</code></pre><p>查看 MySQL 版本：</p>\r\n<p><code>mysqladmin -p -u root version</code></p>\r\n<h3 id=\"h3-u914Du7F6Eu8FDCu7A0Bu8BBFu95EE\"><a name=\"配置远程访问\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置远程访问</h3><p>修改配置文件<br><code>nano /etc/mysql/mysql.conf.d/mysqld.cnf</code><br>注释掉(语句前面加上 # 即可)：<br><code>bind-address = 127.0.0.1</code><br>重启 MySQL<br><code>service mysql restart</code><br>登录 MySQL<br><code>mysql -u root -p</code><br>授权 root 用户允许所有人连接<br><code>grant all privileges on *.* to \'root\'@\'%\' identified by \'你的 mysql root 账户密码\';</code></p>\r\n<h3 id=\"h3-u56E0u5F31u53E3u4EE4u65E0u6CD5u6210u529Fu6388u6743u89E3u51B3u6B65u9AA4\"><a name=\"因弱口令无法成功授权解决步骤\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>因弱口令无法成功授权解决步骤</h3><p>查看和设置密码安全级别</p>\r\n<pre><code>select @@validate_password_policy;\r\nset global validate_password_policy=0;\r\n</code></pre><p>查看和设置密码长度限制</p>\r\n<pre><code>select @@validate_password_length;\r\nset global validate_password_length=1;\r\n</code></pre><h3 id=\"h3-u5E38u7528u547Du4EE4\"><a name=\"常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用命令</h3><h3 id=\"h3-u542Fu52A8\"><a name=\"启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动</h3><p><code>service mysql start</code></p>\r\n<h3 id=\"h3-u505Cu6B62\"><a name=\"停止\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止</h3><p><code>service mysql stop</code></p>\r\n<h3 id=\"h3-u91CDu542F\"><a name=\"重启\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>重启</h3><p><code>service mysql restart</code></p>\r\n<h3 id=\"h3-u5176u5B83u914Du7F6E\"><a name=\"其它配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其它配置</h3><p>修改配置 mysqld.cnf 配置文件</p>\r\n<p><code>vi /etc/mysql/mysql.conf.d/mysqld.cnf</code></p>\r\n<h3 id=\"h3-u914Du7F6Eu9ED8u8BA4u5B57u7B26u96C6\"><a name=\"配置默认字符集\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置默认字符集</h3><p>在 [mysqld] 节点上增加如下配置</p>\r\n<p>[client]<br><code>default-character-set=utf8</code><br>在 [mysqld] 节点底部增加如下配置\r\n<pre><code>default-storage-engine=INNODB\r\ncharacter-set-server=utf8\r\ncollation-server=utf8_general_ci\r\n</code></pre><h1 id=\"h1-u914Du7F6Eu5FFDu7565u6570u636Eu5E93u5927u5C0Fu5199u654Fu611F\"><a name=\"配置忽略数据库大小写敏感\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置忽略数据库大小写敏感</h1><p>在 [mysqld] 节点底部增加如下配置</p>\r\n<p><code>lower-case-table-names = 1</code></p>\r\n', null, null, null, '2020-09-24 22:33:01', '2020-09-24 22:45:23', '1');
INSERT INTO `articles` VALUES ('37', '1', '虚拟机安装Linux', '', '> 概述：原生云应用基本都是基于云服务器部署，本地化的 Linux 操作基本也都是在虚拟机中进行模拟操作。故我们只需要安装虚拟机并在虚拟机上安装对应的 Linux 操作系统即可。\r\n\r\n###1安装 VMware\r\n一直点下一步即可\r\n###2在VMware安装Linux 操作系统步骤 \r\n\r\n\r\n    1：新建虚拟机\r\n    2：自定义高级\r\n    3：稍后安装系统\r\n    4：Liunx Ubuntu 64位\r\n    5：Ubuntu Server X64虚拟机名字重定义，文件夹分层（F:\\VMware\\Ubuntu Server X64）\r\n    6：处理器1，内核2\r\n    7：默认\r\n    8：NAT网络\r\n    9：推荐使用\r\n    10：推荐使用\r\n    11：创建新虚拟磁盘\r\n    12：20G，拆分为多个文件\r\n    13：下一步\r\n    14：完成\r\n    15：编辑虚拟机设置\r\n    16：CD/DVD使用镜像\r\n    17：开启虚拟机\r\n    18：English\r\n    19：安装\r\n    20：English\r\n    21：USA（默认）\r\n    22：no\r\n    23：English\r\n    24：名字不要加空格\r\n    25：用户名和密码设置别太复杂（123456）\r\n    26：弱口令密码选yes\r\n    27：加密主目录no\r\n    28：配置时区yes\r\n    29：分区（第二个选择LVM）磁盘扩容技术\r\n    30：yes\r\n    31：continue\r\n    32：yes\r\n    33：代理服务器不需要（continue）\r\n    34：不要自动更新（No~）\r\n    35：Open SSH(记得是空格选中，不要忙按回车，不然重新来)\r\n    36：yes', '<blockquote>\r\n<p>概述：原生云应用基本都是基于云服务器部署，本地化的 Linux 操作基本也都是在虚拟机中进行模拟操作。故我们只需要安装虚拟机并在虚拟机上安装对应的 Linux 操作系统即可。</p>\r\n</blockquote>\r\n<h3 id=\"h3-1-vmware\"><a name=\"1安装 VMware\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1安装 VMware</h3><p>一直点下一步即可</p>\r\n<h3 id=\"h3-2-vmware-linux-\"><a name=\"2在VMware安装Linux 操作系统步骤\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2在VMware安装Linux 操作系统步骤</h3><pre><code>1：新建虚拟机\r\n2：自定义高级\r\n3：稍后安装系统\r\n4：Liunx Ubuntu 64位\r\n5：Ubuntu Server X64虚拟机名字重定义，文件夹分层（F:\\VMware\\Ubuntu Server X64）\r\n6：处理器1，内核2\r\n7：默认\r\n8：NAT网络\r\n9：推荐使用\r\n10：推荐使用\r\n11：创建新虚拟磁盘\r\n12：20G，拆分为多个文件\r\n13：下一步\r\n14：完成\r\n15：编辑虚拟机设置\r\n16：CD/DVD使用镜像\r\n17：开启虚拟机\r\n18：English\r\n19：安装\r\n20：English\r\n21：USA（默认）\r\n22：no\r\n23：English\r\n24：名字不要加空格\r\n25：用户名和密码设置别太复杂（123456）\r\n26：弱口令密码选yes\r\n27：加密主目录no\r\n28：配置时区yes\r\n29：分区（第二个选择LVM）磁盘扩容技术\r\n30：yes\r\n31：continue\r\n32：yes\r\n33：代理服务器不需要（continue）\r\n34：不要自动更新（No~）\r\n35：Open SSH(记得是空格选中，不要忙按回车，不然重新来)\r\n36：yes\r\n</code></pre>', null, null, null, '2020-09-24 22:38:24', '2020-09-24 22:38:24', '1');
INSERT INTO `articles` VALUES ('38', '1', 'SpringBoot 项目部署到服务器上（Jar包）', '', '### 1. 部署方式\r\n\r\n> Springboot 和普通web 应用程序不一样，其本质上是一个 Java 应用程序，那么又如何部署呢？\r\n通常来说，Springboot 部署会采用两种方式：全部打包成一个jar，或者打包成一个war，现在讲一下打包成 jar 部署。\r\n\r\n### 2. 打包成 jar\r\n\r\n在idea中maven管理点击package即可打包成jar包\r\n\r\n### 3. 部署\r\n1.先刷新用户Java权限\r\n\r\n`source /etc/profile`\r\n\r\n2.执行脚本自动程序\r\n\r\n`nohup java -jar my_blog.jar >log.txt &`\r\n\r\n### 4. 备注\r\n常用命令 :\r\n\r\n`kill -9 22899`  杀死端口号，关闭程序。\r\n\r\n`cat info.log` 查看文件\r\n\r\n`ps -ef | grep java` 查看java 运行的几个端口号', '<h3 id=\"h3-1-\"><a name=\"1. 部署方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 部署方式</h3><blockquote>\r\n<p>Springboot 和普通web 应用程序不一样，其本质上是一个 Java 应用程序，那么又如何部署呢？<br>通常来说，Springboot 部署会采用两种方式：全部打包成一个jar，或者打包成一个war，现在讲一下打包成 jar 部署。\r\n</blockquote>\r\n<h3 id=\"h3-2-jar\"><a name=\"2. 打包成 jar\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 打包成 jar</h3><p>在idea中maven管理点击package即可打包成jar包</p>\r\n<h3 id=\"h3-3-\"><a name=\"3. 部署\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 部署</h3><p>1.先刷新用户Java权限</p>\r\n<p><code>source /etc/profile</code></p>\r\n<p>2.执行脚本自动程序</p>\r\n<p><code>nohup java -jar my_blog.jar &gt;log.txt &amp;</code></p>\r\n<h3 id=\"h3-4-\"><a name=\"4. 备注\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 备注</h3><p>常用命令 :</p>\r\n<p><code>kill -9 22899</code>  杀死端口号，关闭程序。</p>\r\n<p><code>cat info.log</code> 查看文件</p>\r\n<p><code>ps -ef | grep java</code> 查看java 运行的几个端口号</p>\r\n', null, null, null, '2020-09-24 22:45:08', '2020-09-24 22:47:41', '1');
INSERT INTO `articles` VALUES ('40', '1', '有关Docker', 'https://www.funtl.com/zh/docker/', '### 什么是 Docker\r\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。\r\n\r\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\r\n\r\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。\r\n\r\nDocker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。\r\n\r\n下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\r\n![](../images/ea9c9615-f848-4737-8485-c88ae619d9c3.png)\r\n\r\n------------\r\n\r\n\r\n![](../images/298e807a-47a2-4408-921e-332c24acc0f8.png)\r\n### 为什么要使用 Docker\r\n> 概述：作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势\r\n\r\n#### 更高效的利用系统资源\r\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\r\n\r\n####更快速的启动时间\r\n传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\r\n\r\n#### 一致的运行环境\r\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。\r\n\r\n#### 持续交付和部署\r\n对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\r\n\r\n使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。\r\n\r\n而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\r\n\r\n#### 更轻松的迁移\r\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\r\n\r\n#### 更轻松的维护和扩展\r\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\r\n\r\n#### 对比传统虚拟机总结\r\n特性	容器	虚拟机\r\n启动	秒级	分钟级\r\n硬盘使用	一般为 MB	一般为 GB\r\n性能	接近原生	弱于\r\n系统支持量	单机支持上千个容器	一般几十个\r\n', '<h3 id=\"h3--docker\"><a name=\"什么是 Docker\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是 Docker</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</p>\r\n<p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p>\r\n<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p>\r\n<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>\r\n<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src=\"../images/ea9c9615-f848-4737-8485-c88ae619d9c3.png\" alt=\"\">\r\n<hr>\r\n<p><img src=\"../images/298e807a-47a2-4408-921e-332c24acc0f8.png\" alt=\"\">\r\n<h3 id=\"h3--docker\"><a name=\"为什么要使用 Docker\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为什么要使用 Docker</h3><blockquote>\r\n<p>概述：作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势</p>\r\n</blockquote>\r\n<h4 id=\"h4-u66F4u9AD8u6548u7684u5229u7528u7CFBu7EDFu8D44u6E90\"><a name=\"更高效的利用系统资源\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更高效的利用系统资源</h4><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\r\n<h4 id=\"h4-u66F4u5FEBu901Fu7684u542Fu52A8u65F6u95F4\"><a name=\"更快速的启动时间\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更快速的启动时间</h4><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\r\n<h4 id=\"h4-u4E00u81F4u7684u8FD0u884Cu73AFu5883\"><a name=\"一致的运行环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一致的运行环境</h4><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p>\r\n<h4 id=\"h4-u6301u7EEDu4EA4u4ED8u548Cu90E8u7F72\"><a name=\"持续交付和部署\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>持续交付和部署</h4><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\r\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p>\r\n<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\r\n<h4 id=\"h4-u66F4u8F7Bu677Eu7684u8FC1u79FB\"><a name=\"更轻松的迁移\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更轻松的迁移</h4><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\r\n<h4 id=\"h4-u66F4u8F7Bu677Eu7684u7EF4u62A4u548Cu6269u5C55\"><a name=\"更轻松的维护和扩展\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更轻松的维护和扩展</h4><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\r\n<h4 id=\"h4-u5BF9u6BD4u4F20u7EDFu865Au62DFu673Au603Bu7ED3\"><a name=\"对比传统虚拟机总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>对比传统虚拟机总结</h4><p>特性    容器    虚拟机<br>启动    秒级    分钟级<br>硬盘使用    一般为 MB    一般为 GB<br>性能    接近原生    弱于<br>系统支持量    单机支持上千个容器    一般几十个\r\n', null, null, null, '2020-10-09 22:04:25', '2020-10-09 22:12:33', '1');
INSERT INTO `articles` VALUES ('41', '1', 'Docker 系统架构', '', 'Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。\r\n\r\nDocker 容器通过 Docker 镜像来创建。\r\n\r\n容器与镜像的关系类似于面向对象编程中的对象与类。\r\n\r\nDocker	面向对象\r\n容器		对象\r\n镜像		类\r\n\r\n![](../images/6930ff35-e229-4360-939d-c4ce71a5ad83.png)\r\n\r\n镜像(Images)	Docker 镜像是用于创建 Docker 容器的模板。\r\n容器(Container)	容器是独立运行的一个或一组应用。\r\n客户端(Client)	Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。\r\n主机(Host)	一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。\r\n仓库(Registry)	Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。\r\nDocker Machine	Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。', '<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>\r\n<p>Docker 容器通过 Docker 镜像来创建。</p>\r\n<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>\r\n<p>Docker    面向对象<br>容器        对象<br>镜像        类\r\n<p><img src=\"../images/6930ff35-e229-4360-939d-c4ce71a5ad83.png\" alt=\"\">\r\n<p>镜像(Images)    Docker 镜像是用于创建 Docker 容器的模板。<br>容器(Container)    容器是独立运行的一个或一组应用。<br>客户端(Client)    Docker 客户端通过命令行或者其他工具使用 Docker API (<a href=\"https://docs.docker.com/reference/api/docker_remote_api\">https://docs.docker.com/reference/api/docker_remote_api</a>) 与 Docker 的守护进程通信。<br>主机(Host)    一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。<br>仓库(Registry)    Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href=\"https://hub.docker.com\">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br>Docker Machine    Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。\r\n', null, null, null, '2020-10-09 22:09:28', '2020-10-09 22:09:28', '1');
INSERT INTO `articles` VALUES ('42', '1', 'Docker 引擎', '', 'Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。\r\n\r\n一种服务器，它是一种称为守护进程并且长时间运行的程序。\r\nREST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。\r\n一个有命令行界面 (CLI) 工具的客户端。\r\nDocker 引擎组件的流程如下图所示：\r\n![](../images/979f45e5-c2fb-47f4-b50d-92011a4e7120.png)', '<p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p>\r\n<p>一种服务器，它是一种称为守护进程并且长时间运行的程序。<br>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。<br>一个有命令行界面 (CLI) 工具的客户端。<br>Docker 引擎组件的流程如下图所示：<br><img src=\"../images/979f45e5-c2fb-47f4-b50d-92011a4e7120.png\" alt=\"\">\r\n', null, null, null, '2020-10-09 22:10:35', '2020-10-09 22:10:35', '1');
INSERT INTO `articles` VALUES ('43', '1', 'Docker 镜像', '', '我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。\r\n\r\nDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\r\n\r\n###分层存储\r\n因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\r\n\r\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\r\n\r\n分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。\r\n\r\n关于镜像构建，将会在后续相关章节中做进一步的讲解。', '<p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。</p>\r\n<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\r\n<h3 id=\"h3-u5206u5C42u5B58u50A8\"><a name=\"分层存储\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分层存储</h3><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>\r\n<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>\r\n<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>\r\n<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>\r\n', null, null, null, '2020-10-09 22:14:03', '2020-10-09 22:14:03', '1');
INSERT INTO `articles` VALUES ('44', '1', 'Docker 容器', '', '镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\r\n\r\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。\r\n\r\n前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。\r\n\r\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\r\n\r\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\r\n\r\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。', '<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\r\n<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>\r\n<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p>\r\n<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\r\n<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>\r\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>\r\n', null, null, null, '2020-10-09 22:14:23', '2020-10-09 22:14:23', '1');
INSERT INTO `articles` VALUES ('45', '1', 'Docker 仓库', '', '镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。\r\n\r\n一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。\r\n\r\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\r\n\r\n以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\r\n\r\n仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。\r\n\r\n###公有 Docker Registry\r\nDocker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。\r\n\r\n最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。\r\n\r\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。\r\n\r\n国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。\r\n\r\n###私有 Docker Registry\r\n除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。\r\n\r\n开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。\r\n\r\n除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。', '<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>\r\n<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>\r\n<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>\r\n<p>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p>\r\n<p>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>\r\n<h3 id=\"h3--docker-registry\"><a name=\"公有 Docker Registry\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>公有 Docker Registry</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>\r\n<p>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。</p>\r\n<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p>\r\n<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。</p>\r\n<h3 id=\"h3--docker-registry\"><a name=\"私有 Docker Registry\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p>\r\n<p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。</p>\r\n<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。</p>\r\n', null, null, null, '2020-10-09 22:15:04', '2020-10-09 22:15:04', '1');
INSERT INTO `articles` VALUES ('46', '1', '安装 Docker', '', '> 概论\r\n\r\n你需要64位的ubuntu操作系统 Cosmic 18.10、Bionic 18.04 (LTS)、Xenial 16.04 (LTS)其中之一。\r\n\r\ndocker支持的架构为：x86_64 (or amd64), armhf, arm64, s390x (IBM Z), and ppc64le (IBM Power)。\r\n\r\n\r\n查看ubuntu系统是32位的还是64位的：getconf LONG_BIT\r\n![](../images/07eda1a9-925e-4843-b8c3-a40027cefcee.png)\r\n\r\n查看系统信息：lsb_release -a\r\n![](../images/2845eb76-e695-400f-ada1-3501da75c65d.png)\r\n\r\n查看操作系统架构：uname -a\r\n![](../images/fa1e8b56-52b9-44b4-9f5e-89c43e9873a8.png)\r\n\r\n\r\n### 卸载旧版本\r\n`sudo apt-get remove docker docker-engine docker.io containerd runc`\r\n\r\n/var/lib/docker的内容，包括镜像、容器、卷和网络，可以保留也可以删除。\r\n\r\n执行之后，输入docker --version仍能看到docker版本\r\n\r\n\r\n\r\n采用另一种方式：\r\n\r\n`sudo apt-get purge docker`\r\n\r\n`sudo apt-get purge docker-ce`\r\n\r\n`sudo apt-get remove -y docker-*`\r\n\r\n`sudo rm -rf /var/lib/docker`（慎重：这是镜像和容器的默认存储位置，不要误删）\r\n\r\n（apt-get remove 会删除软件包而保留软件的配置文件\r\napt-get purge 会同时清除软件包和软件的配置文件）\r\n\r\n###  Install using the repository\r\n1）`sudo apt-get update`\r\n\r\n2）允许apt通过https使用repository安装软件包\r\n\r\n\r\n\r\n    sudo apt-get install \\\r\n        apt-transport-https \\\r\n        ca-certificates \\\r\n        curl \\\r\n        gnupg-agent \\\r\n        software-properties-common\r\n 3）添加Docker官方GPG key\r\n\r\n`sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`\r\n\r\n（国内阿里云版 `sudo curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -`）\r\n\r\n4）验证key的指纹\r\n\r\n`sudo apt-key fingerprint 0EBFCD88`\r\n\r\n正常输出为：\r\n\r\n\r\n\r\n    root@sunyue:/# sudo apt-key fingerprint 0EBFCD88\r\n    pub   4096R/0EBFCD88 2017-02-22\r\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\r\n    uid                  Docker Release (CE deb) <docker@docker.com>\r\n    sub   4096R/F273FCD8 2017-02-22\r\n\r\n\r\n\r\n5）添加稳定版repository\r\n\r\n\r\n\r\n    sudo add-apt-repository \\\r\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\r\n       $(lsb_release -cs) \\\r\n       stable\"\r\n国内阿里云版：\r\n\r\n\r\n\r\n    sudo add-apt-repository \\\r\n       \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\\r\n       $(lsb_release -cs) \\\r\n       stable\"\r\n5）`sudo apt-get update`\r\n\r\n6）安装最新版本的docker ce和containerd\r\n\r\n`sudo apt-get install docker-ce docker-ce-cli containerd.io`\r\n（如果您启用了多个Docker存储库，则在apt-get install或apt-get update命令中未指定版本的情况下安装或更新将始终安装尽可能高的版本）\r\n\r\n7）安装指定版本的\r\n\r\n查看可获取的版本 `apt-cache madison docker-ce`\r\n\r\n\r\n`sudo apt-get install docker-ce=<VERSION_STRING> docker-ce-cli=<VERSION_STRING> containerd.io`\r\n8）验证：`docker --version`\r\n\r\n`sudo docker run hello-world`\r\n\r\n\r\n9）将非root用户加入docker组，以允许免sudo执行docker\r\n`sudo gpasswd -a 用户名 docker`\r\n重启服务并刷新docker组成员\r\n\r\n\r\n\r\n    sudo service docker restart\r\n    newgrp - docker\r\n10)设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）\r\n\r\n\r\n\r\n    sudo systemctl enable docker\r\n    sudo systemctl start docker\r\n11）升级版本\r\n\r\na) `sudo apt-get update`\r\n\r\nb) 按照以上步骤安装新版本\r\n\r\n12）安装docker-compose(二进制)\r\n\r\nhttps://www.runoob.com/docker/docker-compose.html\r\n\r\n    sudo curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\r\n\r\n`sudo chmod +x /usr/local/bin/docker-compose`\r\n\r\n`sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose`\r\n或者\r\n在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。\r\n\r\n例如，在 Linux 64 位系统上直接下载对应的二进制包。\r\n\r\n    $ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\r\n    $ sudo chmod +x /usr/local/bin/docker-compose\r\n注：可能出现超时现象，换源：\r\n```c\r\ncurl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\r\n```\r\n\r\n\r\n安装docker-compose(PIP 安装)\r\n注1： x86_64 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 ARM (例如，树莓派)，再使用 pip 安装。\r\n注2：pip未找到命令需要安装python3和python2\r\n`sudo apt-get install python3-pip`\r\n`sudo apt-get install python-pip`\r\n\r\n如果有pip版本过低则执行\r\n`pip3 install --upgrade pip`\r\n`pip3 install paramiko`\r\n\r\n\r\n这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。\r\n\r\n执行安装命令：\r\n\r\n`$ sudo pip install -U docker-compose` \r\n（使用pip安装模块时报错: ERROR: After October 2020 you may experience errors when installing or updating packages. This is because pip will change the way that it resolves dependency conflicts. We recommend you use --use-feature=2020-resolver to test your packages with the new resolver before it becomes the default.\r\n解决方法: 在pip命令中加入–use-feature=2020-resolver参数就可以了, 比如pip install xxx --use-feature=2020-resolver）\r\n可以看到类似如下输出，说明安装成功。\r\n> Collecting docker-compose\r\n  Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded\r\n...\r\nSuccessfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress\r\n\r\n安装docker-compose（bash 补全命令）\r\n`$ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose`\r\n\r\n查看版本`docker-compose --version`\r\n###容器中执行\r\nCompose 既然是一个 Python 应用，自然也可以直接用容器来执行它。\r\n\r\n`$ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh > /usr/local/bin/docker-compose`\r\n`$ chmod +x /usr/local/bin/docker-compose`\r\n实际上，查看下载的 run.sh 脚本内容，如下\r\n\r\n    set -e\r\n    \r\n    VERSION=\"1.8.0\"\r\n    IMAGE=\"docker/compose:$VERSION\"\r\n    \r\n    \r\n    # Setup options for connecting to docker host\r\n    if [ -z \"$DOCKER_HOST\" ]; then\r\n        DOCKER_HOST=\"/var/run/docker.sock\"\r\n    fi\r\n    if [ -S \"$DOCKER_HOST\" ]; then\r\n        DOCKER_ADDR=\"-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST\"\r\n    else\r\n        DOCKER_ADDR=\"-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH\"\r\n    fi\r\n    \r\n    \r\n    # Setup volume mounts for compose config and context\r\n    if [ \"$(pwd)\" != \'/\' ]; then\r\n        VOLUMES=\"-v $(pwd):$(pwd)\"\r\n    fi\r\n    if [ -n \"$COMPOSE_FILE\" ]; then\r\n        compose_dir=$(dirname $COMPOSE_FILE)\r\n    fi\r\n    # TODO: also check --file argument\r\n    if [ -n \"$compose_dir\" ]; then\r\n        VOLUMES=\"$VOLUMES -v $compose_dir:$compose_dir\"\r\n    fi\r\n    if [ -n \"$HOME\" ]; then\r\n        VOLUMES=\"$VOLUMES -v $HOME:$HOME -v $HOME:/root\" # mount $HOME in /root to share docker.config\r\n    fi\r\n    \r\n    # Only allocate tty if we detect one\r\n    if [ -t 1 ]; then\r\n        DOCKER_RUN_OPTIONS=\"-t\"\r\n    fi\r\n    if [ -t 0 ]; then\r\n        DOCKER_RUN_OPTIONS=\"$DOCKER_RUN_OPTIONS -i\"\r\n    fi\r\n    \r\n    exec docker run --rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w \"$(pwd)\" $IMAGE \"$@\"\r\n可以看到，它其实是下载了 docker/compose 镜像并运行。\r\n\r\n###卸载\r\n如果是二进制包方式安装的，删除二进制文件即可。\r\n\r\n`$ sudo rm /usr/local/bin/docker-compose`\r\n如果是通过 pip 安装的，则执行如下命令即可删除。\r\n\r\n$` sudo pip uninstall docker-compose`\r\n\r\n\r\n\r\n### 补充\r\n\r\n国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：\r\n\r\nDocker 官方提供的中国 registry mirror\r\n阿里云加速器\r\nDaoCloud 加速器\r\n我们以 Docker 官方加速器为例进行介绍。\r\n\r\n### Ubuntu 14.04、Debian 7 Wheezy\r\n对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：\r\n\r\n\r\n\r\n    DOCKER_OPTS=\"--registry-mirror=https://registry.docker-cn.com\"\r\n重新启动服务。\r\n\r\n`$ sudo service docker restart`\r\n\r\n### Ubuntu 16.04+、Debian 8+、CentOS 7\r\n对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\r\n\r\n\r\n\r\n      {\"registry-mirrors\": [\"https://hccwwfjl.mirror.aliyuncs.com\"]}\r\n注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。\r\n如果出现\r\n\r\n之后重新启动服务。\r\n\r\n    $ sudo systemctl daemon-reload\r\n    $ sudo systemctl restart docker\r\n注意：如果您之前查看旧教程，修改了 docker.service 文件内容，请去掉您添加的内容（--registry-mirror=https://registry.docker-cn.com），这里不再赘述。\r\n\r\n### Windows 10\r\n对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registry mirrors 一栏中填写加速器地址 https://registry.docker-cn.com，之后点击 Apply 保存后 Docker 就会重启并应用配置的镜像地址了。\r\n\r\n###macOS\r\n对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -> Perferences... -> Daemon -> Registry mirrors。在列表中填写加速器地址 https://registry.docker-cn.com。修改完成之后，点击 Apply & Restart 按钮，Docker 就会重启并应用配置的镜像地址了。\r\n\r\n###检查加速器是否生效\r\n配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。\r\n\r\n`{\"registry-mirrors\": [\"https://hccwwfjl.mirror.aliyuncs.com\"]}`\r\n\r\n\r\n如果出现错误`WARNING: No swap limit support`\r\n`vi /etc/default/grub` 找到下面信息 Set the GRUB_CMDLINE_LINUX value as follows: `GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"`\r\n修改并保持\r\nUpdate GRUB `sudo update-grub`\r\nreboot. 重启后就没有该信息了.\r\n', '<blockquote>\r\n<p>概论</p>\r\n</blockquote>\r\n<p>你需要64位的ubuntu操作系统 Cosmic 18.10、Bionic 18.04 (LTS)、Xenial 16.04 (LTS)其中之一。</p>\r\n<p>docker支持的架构为：x86_64 (or amd64), armhf, arm64, s390x (IBM Z), and ppc64le (IBM Power)。</p>\r\n<p>查看ubuntu系统是32位的还是64位的：getconf LONG_BIT<br><img src=\"../images/07eda1a9-925e-4843-b8c3-a40027cefcee.png\" alt=\"\">\r\n<p>查看系统信息：lsb_release -a<br><img src=\"../images/2845eb76-e695-400f-ada1-3501da75c65d.png\" alt=\"\">\r\n<p>查看操作系统架构：uname -a<br><img src=\"../images/fa1e8b56-52b9-44b4-9f5e-89c43e9873a8.png\" alt=\"\">\r\n<h3 id=\"h3-u5378u8F7Du65E7u7248u672C\"><a name=\"卸载旧版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>卸载旧版本</h3><p><code>sudo apt-get remove docker docker-engine docker.io containerd runc</code></p>\r\n<p>/var/lib/docker的内容，包括镜像、容器、卷和网络，可以保留也可以删除。</p>\r\n<p>执行之后，输入docker —version仍能看到docker版本</p>\r\n<p>采用另一种方式：</p>\r\n<p><code>sudo apt-get purge docker</code></p>\r\n<p><code>sudo apt-get purge docker-ce</code></p>\r\n<p><code>sudo apt-get remove -y docker-*</code></p>\r\n<p><code>sudo rm -rf /var/lib/docker</code>（慎重：这是镜像和容器的默认存储位置，不要误删）</p>\r\n<p>（apt-get remove 会删除软件包而保留软件的配置文件<br>apt-get purge 会同时清除软件包和软件的配置文件）\r\n<h3 id=\"h3-install-using-the-repository\"><a name=\"Install using the repository\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Install using the repository</h3><p>1）<code>sudo apt-get update</code></p>\r\n<p>2）允许apt通过https使用repository安装软件包</p>\r\n<pre><code>sudo apt-get install \\\r\n    apt-transport-https \\\r\n    ca-certificates \\\r\n    curl \\\r\n    gnupg-agent \\\r\n    software-properties-common\r\n</code></pre><p> 3）添加Docker官方GPG key</p>\r\n<p><code>sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p>\r\n<p>（国内阿里云版 <code>sudo curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -</code>）</p>\r\n<p>4）验证key的指纹</p>\r\n<p><code>sudo apt-key fingerprint 0EBFCD88</code></p>\r\n<p>正常输出为：</p>\r\n<pre><code>root@sunyue:/# sudo apt-key fingerprint 0EBFCD88\r\npub   4096R/0EBFCD88 2017-02-22\r\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\r\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\r\nsub   4096R/F273FCD8 2017-02-22\r\n</code></pre><p>5）添加稳定版repository</p>\r\n<pre><code>sudo add-apt-repository \\\r\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\r\n   $(lsb_release -cs) \\\r\n   stable\"\r\n</code></pre><p>国内阿里云版：</p>\r\n<pre><code>sudo add-apt-repository \\\r\n   \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\\r\n   $(lsb_release -cs) \\\r\n   stable\"\r\n</code></pre><p>5）<code>sudo apt-get update</code></p>\r\n<p>6）安装最新版本的docker ce和containerd</p>\r\n<p><code>sudo apt-get install docker-ce docker-ce-cli containerd.io</code><br>（如果您启用了多个Docker存储库，则在apt-get install或apt-get update命令中未指定版本的情况下安装或更新将始终安装尽可能高的版本）\r\n<p>7）安装指定版本的</p>\r\n<p>查看可获取的版本 <code>apt-cache madison docker-ce</code></p>\r\n<p><code>sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code><br>8）验证：<code>docker --version</code></p>\r\n<p><code>sudo docker run hello-world</code></p>\r\n<p>9）将非root用户加入docker组，以允许免sudo执行docker<br><code>sudo gpasswd -a 用户名 docker</code><br>重启服务并刷新docker组成员\r\n<pre><code>sudo service docker restart\r\nnewgrp - docker\r\n</code></pre><p>10)设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）</p>\r\n<pre><code>sudo systemctl enable docker\r\nsudo systemctl start docker\r\n</code></pre><p>11）升级版本</p>\r\n<p>a) <code>sudo apt-get update</code></p>\r\n<p>b) 按照以上步骤安装新版本</p>\r\n<p>12）安装docker-compose(二进制)</p>\r\n<p><a href=\"https://www.runoob.com/docker/docker-compose.html\">https://www.runoob.com/docker/docker-compose.html</a></p>\r\n<pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\r\n</code></pre><p><code>sudo chmod +x /usr/local/bin/docker-compose</code></p>\r\n<p><code>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code><br>或者<br>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。\r\n<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>\r\n<pre><code>$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\r\n$ sudo chmod +x /usr/local/bin/docker-compose\r\n</code></pre><p>注：可能出现超时现象，换源：</p>\r\n<pre><code class=\"lang-c\">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\r\n</code></pre>\r\n<p>安装docker-compose(PIP 安装)<br>注1： x86_64 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 ARM (例如，树莓派)，再使用 pip 安装。<br>注2：pip未找到命令需要安装python3和python2<br><code>sudo apt-get install python3-pip</code><br><code>sudo apt-get install python-pip</code></p>\r\n<p>如果有pip版本过低则执行<br><code>pip3 install --upgrade pip</code><br><code>pip3 install paramiko</code></p>\r\n<p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p>\r\n<p>执行安装命令：</p>\r\n<p><code>$ sudo pip install -U docker-compose</code><br>（使用pip安装模块时报错: ERROR: After October 2020 you may experience errors when installing or updating packages. This is because pip will change the way that it resolves dependency conflicts. We recommend you use —use-feature=2020-resolver to test your packages with the new resolver before it becomes the default.<br>解决方法: 在pip命令中加入–use-feature=2020-resolver参数就可以了, 比如pip install xxx —use-feature=2020-resolver）<br>可以看到类似如下输出，说明安装成功。\r\n<blockquote>\r\n<p>Collecting docker-compose<br>  Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded<br>…<br>Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress\r\n</blockquote>\r\n<p>安装docker-compose（bash 补全命令）<br><code>$ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></p>\r\n<p>查看版本<code>docker-compose --version</code></p>\r\n<h3 id=\"h3-u5BB9u5668u4E2Du6267u884C\"><a name=\"容器中执行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>容器中执行</h3><p>Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。</p>\r\n<p><code>$ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/local/bin/docker-compose</code><br><code>$ chmod +x /usr/local/bin/docker-compose</code><br>实际上，查看下载的 run.sh 脚本内容，如下\r\n<pre><code>set -e\r\n\r\nVERSION=\"1.8.0\"\r\nIMAGE=\"docker/compose:$VERSION\"\r\n\r\n\r\n# Setup options for connecting to docker host\r\nif [ -z \"$DOCKER_HOST\" ]; then\r\n    DOCKER_HOST=\"/var/run/docker.sock\"\r\nfi\r\nif [ -S \"$DOCKER_HOST\" ]; then\r\n    DOCKER_ADDR=\"-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST\"\r\nelse\r\n    DOCKER_ADDR=\"-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH\"\r\nfi\r\n\r\n\r\n# Setup volume mounts for compose config and context\r\nif [ \"$(pwd)\" != \'/\' ]; then\r\n    VOLUMES=\"-v $(pwd):$(pwd)\"\r\nfi\r\nif [ -n \"$COMPOSE_FILE\" ]; then\r\n    compose_dir=$(dirname $COMPOSE_FILE)\r\nfi\r\n# TODO: also check --file argument\r\nif [ -n \"$compose_dir\" ]; then\r\n    VOLUMES=\"$VOLUMES -v $compose_dir:$compose_dir\"\r\nfi\r\nif [ -n \"$HOME\" ]; then\r\n    VOLUMES=\"$VOLUMES -v $HOME:$HOME -v $HOME:/root\" # mount $HOME in /root to share docker.config\r\nfi\r\n\r\n# Only allocate tty if we detect one\r\nif [ -t 1 ]; then\r\n    DOCKER_RUN_OPTIONS=\"-t\"\r\nfi\r\nif [ -t 0 ]; then\r\n    DOCKER_RUN_OPTIONS=\"$DOCKER_RUN_OPTIONS -i\"\r\nfi\r\n\r\nexec docker run --rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w \"$(pwd)\" $IMAGE \"$@\"\r\n</code></pre><p>可以看到，它其实是下载了 docker/compose 镜像并运行。</p>\r\n<h3 id=\"h3-u5378u8F7D\"><a name=\"卸载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p>\r\n<p><code>$ sudo rm /usr/local/bin/docker-compose</code><br>如果是通过 pip 安装的，则执行如下命令即可删除。\r\n<p>$<code>sudo pip uninstall docker-compose</code></p>\r\n<h3 id=\"h3-u8865u5145\"><a name=\"补充\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>补充</h3><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>\r\n<p>Docker 官方提供的中国 registry mirror<br>阿里云加速器<br>DaoCloud 加速器<br>我们以 Docker 官方加速器为例进行介绍。\r\n<h3 id=\"h3-ubuntu-14-04-debian-7-wheezy\"><a name=\"Ubuntu 14.04、Debian 7 Wheezy\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Ubuntu 14.04、Debian 7 Wheezy</h3><p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：</p>\r\n<pre><code>DOCKER_OPTS=\"--registry-mirror=https://registry.docker-cn.com\"\r\n</code></pre><p>重新启动服务。</p>\r\n<p><code>$ sudo service docker restart</code></p>\r\n<h3 id=\"h3-ubuntu-16-04-debian-8-centos-7\"><a name=\"Ubuntu 16.04+、Debian 8+、CentOS 7\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>\r\n<pre><code>  {\"registry-mirrors\": [\"https://hccwwfjl.mirror.aliyuncs.com\"]}\r\n</code></pre><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。<br>如果出现\r\n<p>之后重新启动服务。</p>\r\n<pre><code>$ sudo systemctl daemon-reload\r\n$ sudo systemctl restart docker\r\n</code></pre><p>注意：如果您之前查看旧教程，修改了 docker.service 文件内容，请去掉您添加的内容（—registry-mirror=<a href=\"https://registry.docker-cn.com），这里不再赘述。\">https://registry.docker-cn.com），这里不再赘述。</a></p>\r\n<h3 id=\"h3-windows-10\"><a name=\"Windows 10\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Windows 10</h3><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registry mirrors 一栏中填写加速器地址 <a href=\"https://registry.docker-cn.com，之后点击\">https://registry.docker-cn.com，之后点击</a> Apply 保存后 Docker 就会重启并应用配置的镜像地址了。</p>\r\n<h3 id=\"h3-macos\"><a name=\"macOS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>macOS</h3><p>对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <a href=\"https://registry.docker-cn.com。修改完成之后，点击\">https://registry.docker-cn.com。修改完成之后，点击</a> Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p>\r\n<h3 id=\"h3-u68C0u67E5u52A0u901Fu5668u662Fu5426u751Fu6548\"><a name=\"检查加速器是否生效\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>检查加速器是否生效</h3><p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。</p>\r\n<p><code>{\"registry-mirrors\": [\"https://hccwwfjl.mirror.aliyuncs.com\"]}</code></p>\r\n<p>如果出现错误<code>WARNING: No swap limit support</code><br><code>vi /etc/default/grub</code> 找到下面信息 Set the GRUB_CMDLINE_LINUX value as follows: <code>GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"</code><br>修改并保持<br>Update GRUB <code>sudo update-grub</code><br>reboot. 重启后就没有该信息了.\r\n', null, null, null, '2020-10-12 22:47:17', '2020-10-13 22:46:33', '1');
INSERT INTO `articles` VALUES ('47', '1', 'COBOL文件操作', 'https://blog.csdn.net/lanyanjiayu/article/details/9027753', '要在COBOL中使用文件，要在3个不同的部中放上信息。\r\n   环境部，要有程序使用的每个文件的文件控制项目(FILE-CONTROL)。这个项目将程序中使用的文件名与程序外的实际文件联系起来。这些项目还定义文件的组织和访问方式。\r\n   数据部，要有每个文件的文件描述符(FD)项目，就是数据定义。\r\n   过程部，放上处理语句，OPEN,READ,WRITE,DELETE等。\r\n\r\n   环境部中主要是FILE-CONTROL和I-O-CONTROL.I-O-CONTROL很少使用。\r\n   SELECT [OPTIONAL] file-name ASSIGN TO DEV/FILE\r\n   [RESERVE N [AREA/AREAS]]\r\n   [FILE STATUS IS VAR]\r\n   SELECT必须是第一句，其他顺序无关。file-name是程序中传递使用的文件名，相当于实际文件的一个别名。OPTIONAL用于执行可能不存在的文件。\r\n   ASSIGN将file-name连接到实际的外部设备或文件。（TO好像可以省略。）\r\n   RESERVE指定文件缓冲区。\r\n   FILE STATUS指定一个变量存放文件状态，这个变量应该已在WORKING-STORAGE SECTION中定义。\r\n\r\n   对于顺序文件，还有声明如下：\r\n   [ORGANIZATION IS SEQUENTIAL]               可选，缺省为顺序组织文件\r\n   [ACCESS MODE IS SEQUENTIAL]                可选。顺序文件只允许顺序访问\r\n   [PADDING CHARACTER IS char]                指定文件在固定块长设备上时键块所用的字符，char为一个字符的数据项。\r\n   [RECORD DELIMITER IS STANDARD/usr-define]  指定如何确定变长纪录的长度。\r\n   顺序文件例子：\r\n   SELECT file-name ASSIGN TO \"/usr/file1\"\r\n   FILE STATUS IS file-status\r\n\r\n   对于相对文件，还有声明如下：\r\n   [ORGANIZATION IS RELATIVE]               是相对文件必须的\r\n   [ACCESS MODE IS SEQUENTIAL [RELATIVE KEY IS data]] 或者\r\n   [ACCESS MODE IS RANDOM/DYNAMIC RELATIVE KEY IS data]\r\n   访问方式有3种，缺省是SEQUENTIAL。\r\n   RELATIVE KEY 可选。如果存在，则文件读取操作顺利完成后，data用所读取纪录的关键字更新。data应为文件的纪录区中没有的整数数据项。\r\n   相对文件的例子：\r\n   SELECT file-name ASSIGN TO \"/usr/file2\"\r\n   ORGANIZATION IS RELATIVE\r\n   ACCESS MODE IS DYNAMIC RELATIVE KEY IS DAY-NUMBER\r\n   FILE STATUS IS file-status\r\n\r\n   对于索引文件，还有声明如下：\r\n   [ORGANIZATION IS INDEXED]               是索引文件必须的\r\n   [ACCESS MODE IS SEQUENTIAL/RANDOM/DYNAMIC] RECORD KEY IS data1\r\n   [ALTERNATE RECORD KEY IS data2 [WITH DUPLICATES]]\r\n   访问方式有3种，缺省是SEQUENTIAL。\r\n   RECORD KEY 指定文件的主纪录关键字，data1应为定义该文件的某个记录区的字母数字数据项目。这个关键字的描述及其在数据记录中的位置应该与生成文件时所用的关键字一致。\r\n   ALTERNATE RECORD KEY 如果文件有替换关键字，则其关键字用这个从句的短语指定，索引中允许重复关键字时采用DUPLICATES.COBOL要求文件记录中定义data2。重复关键字的长度及其在数据记录中的位置应该与生成文件时一致，所有替换关键字应放在文件控制项中。\r\n   索引文件的例子：\r\n   SELECT file-name ASSIGN TO \"/usr/file3\"\r\n   ORGANIZATION IS INDEXED\r\n   ACCESS MODE IS RANDOM\r\n   RECORD KEY IS NUMBER OF EMPLOYEE-RECORD\r\n   ALTERNATE RECORD KEY IS LAST-NAME OF EMPLOYEE-RECORD WITH DUPLICATES\r\n   ALTERNATE RECORD KEY IS SS-NUMBER OF EMPLOYEE-RECORD\r\n   FILE STATUS IS file-status\r\n   这里用户在程序中使用的文件名是file-name，实际文件名是file3。file-name的定义放在程序后边的数据部的文件节中。文件是索引文件，程序可以随机访问文件。文件的主关键字是NUMBER OF EMPLOYEE-RECORD，替换关键字是LAST-NAME和SS-NUMBER，都是文件记录区的字段。LAST-NAME允许重复。\r\n\r\n   文件状态：(对文件操作时返回文件状态到定义的文件状态变量)\r\n   ANY            00 成功\r\n   ANY            02 对索引文件，成功但发现重复关键字\r\n   READ           04 成功，但纪录长度不符合指定长度\r\n   OPEN           05 成功，但文件是可选的，前面不存在\r\n   OPEN,CLOSE     07 对顺序文件，成功，但媒介不是盘\r\n   READ           10 文件已到末尾\r\n   READ           14 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位\r\n   WRITE,REWRITE  21 对索引文件，顺序出错\r\n   WRITE          22 对索引和相对文件，带这个关键字的纪录已经存在\r\n   START,READ     23 对索引和相对文件，带这个关键字的纪录不存在\r\n   WRITE          24 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位\r\n   ANY            30 I/O错误\r\n   WRITE          34 对顺序文件，发生超边界错误\r\n   OPEN           35 对顺序和相对文件，未发现非可选文件\r\n   OPEN           37 对顺序和相对文件，该文件不支持指定的打开方式\r\n   OPEN           38 对顺序和相对文件，文件已经用锁关闭\r\n   OPEN           39 对顺序和相对文件，文件属性不支持程序中指定的属性\r\n   OPEN           41 文件已经打开\r\n   CLOSE          42 文件未打开\r\n   DELETE,REWRITE 43 最近的操作不是READ\r\n   WRITE,REWRITE  44 纪录长度非法\r\n   READ           46 没有有效的下一个记录\r\n   READ,START     47 文件未在INPUT或I-O方式中打开\r\n   WRITE          48 文件未在OUTPUT或EXTEND方式中打开\r\n   DELETE,REWRITE 49 文件未在I-O方式中打开\r\n   ANY            90~99 厂家定义\r\n\r\n   由上可知，文件操作时会发生错误，COBOL提供了检查错误和恢复I/O错误的公用地点。过程部开头应包括DECLARATIVES部分，放上出现错误时要执行的语句。\r\n   PROCEDURE DIVISION.\r\n   DECLARATIVES.\r\n   section-name SECTION.\r\n   USE statement(出现错误时调用的节).\r\n   paragraph-name.\r\n   sentence...\r\n   END DECLARATIVES.\r\n   section-name SECTION.\r\n   paragraph-name.\r\n   sentence...\r\n   USE AFTER STANDARD EXCEPTION/ERROR PROCEDURE ON file-name/INPUT/OUTPUT/I-O/EXTEND\r\n   只能在USE语句中指定一个文件，一种方式也只能有一个USE语句。如果既指定了文件，也指定了方式，则文件优先。\r\n\r\n   程序使用的所有文件要定义在数据部的第一节----文件节中。\r\n   FD file-name\r\n   [BLOCK CONTAINS int-1 [TO int-2] RECORDS/CHARACTERS]\r\n   [RECORD (CONTAINS int-3 [TO int-4] CHARACTERS)/(IS VARYING IN SIZE [FROM int-5] [TO int-6] CHARACTERS)/(DEPENDING ON data1)\r\n   [LABEL (RECORD IS)/(RECORDS ARE) STANDARD/OMITTED]\r\n   [VALUE OF (implementor-name IS id-lit-1)...]\r\n   [DATA (RECORD IS)/(RECORDS ARE) data2]\r\n   BLOCK CONTAINS 指定实际纪录的具体长度或最大与最小长度的逻辑记录数或块数。一般有操作系统和文件系统指定。\r\n   RECORD 指定包含变长纪录的文件中记录的最大与最小长度或定长纪录的具体长度。\r\n   RECORD CONTAINS 如果不带TO，则int-3是每个纪录的长度；如果带TO,介于int-3和int-4之间。\r\n   RECORD IS VARYING 指定纪录长度最小int-5和最大int-6。\r\n   DEPENDING ON 如要用，则需要在data1中保存纪录长度。\r\n   LABEL RECORD 指定文件是否带标号。（过时，下个版本不包含）\r\n   VALUE 和LABEL一起检查标号的不同部分。（过时，下个版本不包含）\r\n   DATA RECORD 指定属于文件的纪录描述项（FD后的01层项目）并作为程序文档。（过时，下个版本不包含）\r\n   一般定义文件只用第一句：FD file-name\r\n  顺序文件的LINAGE声明\r\n   对顺序文件，LINAGE声明可以在文件输出是打印机或打印机兼容文件时指定一些打印细节。\r\n   [LINAGE IS BODY LINES [WITH FOOTING AT FOOT][LINES AT TOP TOP][LINES AT BOTTOM BOTTOM]] [CODE-SET IS alphabet-name]\r\n   整个文件分成TOP,BODY,BOTTOM三部分。其中BODY包含有FOOT.\r\n   CODE-SET指定文件中所用的字符集。\r\n\r\n   过程部主要是对文件的OPEN,CLOSE,READ,WRITE,START,REWRITE,DELETE等操作。\r\nOPEN\r\n   OPEN文件有4种方式：（如果文件声明为OPTIONAL，则文件不存在会创建文件，否则会报错）\r\n   OPEN INPUT FILE-NAME.    只能读取的文件。\r\n   OPEN OUTPUT FILE-NAME.   生成写入纪录的文件，读取该文件会出错。若文件已存在，已有记录会被全部删除。\r\n   OPEN I-O FILE-NAME.      可读可写的文件。\r\n   OPEN EXTEND FILE-NAME.   生成写入的文件。与UOTPUT的区别在于，若文件已存在，EXTEND将纪录加在文件末尾。\r\n   如果OPEN不成功，执行USE语句。USE语句不存在，则程序结束。\r\n   顺序文件的OPEN可以有以下方式：\r\n   OPEN INPUT FILE-NAME [(WITH NO REWIND)/REVERSED].\r\n   OPEN OUTPUT FILE-NAME [WITH NO REWIND].   \r\n   REVERSED可以逆序处理，即由后向前处理。（过时，下个版本不包含）\r\n   WITH NO REWIND 用于单卷磁带文件，如果指定文件在不适用REWIND的媒介上，忽略。\r\n   在文件描述项中指定LINAGE得顺序文件不能用EXTEND方式打开。\r\n\r\nCLOSE\r\n   所有文件的CLOSE方法：\r\n   CLOSE FILE-NAME.    关闭文件。\r\n   CLOSE FILE-NAME WITH LOCK.    关闭文件，不退出程序不能再打开此文件。\r\n   顺序文件还有其他一些选项,如关闭卷或单元，和继续处理文件：\r\n   CLOSE file-name [REEL/UNIT] [FOR REMOVAL]/WITH NO REWIND\r\n\r\nREAD\r\n   顺序访问方式读文件。一定要有NEXT字样。\r\n   READ file-name [NEXT] RECORD [INTO data1]\r\n   [AT END statements][NOT AT END statements] [END-READ]\r\n   如果READ成功且有INTO，将读到的数据写入data1。\r\n   如果文件中没有记录，执行AT ENDstatements，如果没有就执行USE。\r\n   如果READ成功，就执行NOT AT END statements。\r\n\r\n   动态访问方式读文件。(相对或索引文件)\r\n   利用OPEN语句，将文件指针设在开头。\r\n   进行各种成功的READ操作。\r\n   有START语句标识文件中的纪录。\r\n   随机访问方式读文件。\r\n   READ file-name RECORD [INTO data1]\r\n   [INVALID KEY statements][NOT INVALID KEY statements] [END-READ]\r\n   如果READ成功且有INTO，将读到的数据写入data1。\r\n   如果文件中没有记录，执行INVALID KEY statements，如果没有就执行USE。\r\n   如果READ成功，就执行NOT INVALID KEY statements。\r\n   如果是相对文件，要设置文件控制项RELATIVE KEY中指定的整型关键字值后才能执行READ.\r\n   如果是索引文件，要设置当前索引的关键字值后才能执行READ.\r\n\r\nWRITE\r\n   顺序方式。\r\n   WRITE data [FROM data1] [BEFORE/AFTER ADVANCING mnemonic-name/PAGE/N LINE(LINES)]\r\n   [AT END-OF-PAGE(EOP) statements][NOT AT END-OF-PAGE(EOP) statements][END-WRITE]\r\n   如果指定了FROM，先将data1复制到data，再写入文件。\r\n   BEFORE/AFTER ADVANCING N LINE(LINES) 在纪录间插入N个空行。\r\n   AT END-OF-PAGE(EOP) 对于带LINAGE的文件有效，在WRITE使指针进入页脚(FOOT)时，先执行WRITE，再执行AT END-OF-PAGE(EOP) statements。\r\n\r\n   相对和索引文件方式。\r\n   WRITE data [FROM data1]\r\n   [INVALID KEY statements][NOT INVALID KEY statements] [END-WRITE]\r\n\r\nREWRITE\r\n   替换文件中的一个记录。\r\n   顺序方式：REWRITE data [FROM data1] [END-REWRITE]\r\n   相对和索引方式：\r\n   REWRITE data [FROM data1]\r\n   [INVALID KEY statements][NOT INVALID KEY statements] [END-REWRITE]\r\n\r\nDELETE\r\n   删除文件中的一个记录。只能用于相对或索引组织的文件。\r\n   DELETE file-name RECORD\r\n   [INVALID KEY statements][NOT INVALID KEY statements] [END-DELETE]\r\n   顺序访问方式的话，前一个READ的纪录被删除。\r\n   随机或动态访问的话，RELATIVE KEY的内容或主关键字所表示的纪录从文件中删除。\r\n\r\nSTART\r\n   将相对或索引文件定位到某个纪录，以便对其进行顺序访问。只对相对和索引文件有效。\r\n   START file-name [KEY IS (EQUAL TO)/=/GREATER THAN/>/NOT LESS THAN/NOT < data]\r\n   [INVALID KEY statements][NOT INVALID KEY statements] [END-START]\r\n   如果执行成功，则data所属的索引变成文件的当前索引。\r\n   对于相对文件，data定义为文件的RELATIVE KEY的数据项。\r\n   对于索引文件，data为下列之一：\r\n   文件的主关键字，是RECORD KEY从句中指定的数据项。\r\n   文件的替换关键字，是ALTERNATE RECORD KEY从句指定的数据项。\r\n   从一个关键字的第一个位置开头，长度小于或等于该关键字的数据项。\r\n', '<p>要在COBOL中使用文件，要在3个不同的部中放上信息。<br>   环境部，要有程序使用的每个文件的文件控制项目(FILE-CONTROL)。这个项目将程序中使用的文件名与程序外的实际文件联系起来。这些项目还定义文件的组织和访问方式。<br>   数据部，要有每个文件的文件描述符(FD)项目，就是数据定义。<br>   过程部，放上处理语句，OPEN,READ,WRITE,DELETE等。\r\n<p>   环境部中主要是FILE-CONTROL和I-O-CONTROL.I-O-CONTROL很少使用。<br>   SELECT [OPTIONAL] file-name ASSIGN TO DEV/FILE<br>   [RESERVE N [AREA/AREAS]]<br>   [FILE STATUS IS VAR]<br>   SELECT必须是第一句，其他顺序无关。file-name是程序中传递使用的文件名，相当于实际文件的一个别名。OPTIONAL用于执行可能不存在的文件。<br>   ASSIGN将file-name连接到实际的外部设备或文件。（TO好像可以省略。）<br>   RESERVE指定文件缓冲区。<br>   FILE STATUS指定一个变量存放文件状态，这个变量应该已在WORKING-STORAGE SECTION中定义。\r\n<p>   对于顺序文件，还有声明如下：<br>   [ORGANIZATION IS SEQUENTIAL]               可选，缺省为顺序组织文件<br>   [ACCESS MODE IS SEQUENTIAL]                可选。顺序文件只允许顺序访问<br>   [PADDING CHARACTER IS char]                指定文件在固定块长设备上时键块所用的字符，char为一个字符的数据项。<br>   [RECORD DELIMITER IS STANDARD/usr-define]  指定如何确定变长纪录的长度。<br>   顺序文件例子：<br>   SELECT file-name ASSIGN TO “/usr/file1”<br>   FILE STATUS IS file-status\r\n<p>   对于相对文件，还有声明如下：<br>   [ORGANIZATION IS RELATIVE]               是相对文件必须的<br>   [ACCESS MODE IS SEQUENTIAL [RELATIVE KEY IS data]] 或者<br>   [ACCESS MODE IS RANDOM/DYNAMIC RELATIVE KEY IS data]<br>   访问方式有3种，缺省是SEQUENTIAL。<br>   RELATIVE KEY 可选。如果存在，则文件读取操作顺利完成后，data用所读取纪录的关键字更新。data应为文件的纪录区中没有的整数数据项。<br>   相对文件的例子：<br>   SELECT file-name ASSIGN TO “/usr/file2”<br>   ORGANIZATION IS RELATIVE<br>   ACCESS MODE IS DYNAMIC RELATIVE KEY IS DAY-NUMBER<br>   FILE STATUS IS file-status\r\n<p>   对于索引文件，还有声明如下：<br>   [ORGANIZATION IS INDEXED]               是索引文件必须的<br>   [ACCESS MODE IS SEQUENTIAL/RANDOM/DYNAMIC] RECORD KEY IS data1<br>   [ALTERNATE RECORD KEY IS data2 [WITH DUPLICATES]]<br>   访问方式有3种，缺省是SEQUENTIAL。<br>   RECORD KEY 指定文件的主纪录关键字，data1应为定义该文件的某个记录区的字母数字数据项目。这个关键字的描述及其在数据记录中的位置应该与生成文件时所用的关键字一致。<br>   ALTERNATE RECORD KEY 如果文件有替换关键字，则其关键字用这个从句的短语指定，索引中允许重复关键字时采用DUPLICATES.COBOL要求文件记录中定义data2。重复关键字的长度及其在数据记录中的位置应该与生成文件时一致，所有替换关键字应放在文件控制项中。<br>   索引文件的例子：<br>   SELECT file-name ASSIGN TO “/usr/file3”<br>   ORGANIZATION IS INDEXED<br>   ACCESS MODE IS RANDOM<br>   RECORD KEY IS NUMBER OF EMPLOYEE-RECORD<br>   ALTERNATE RECORD KEY IS LAST-NAME OF EMPLOYEE-RECORD WITH DUPLICATES<br>   ALTERNATE RECORD KEY IS SS-NUMBER OF EMPLOYEE-RECORD<br>   FILE STATUS IS file-status<br>   这里用户在程序中使用的文件名是file-name，实际文件名是file3。file-name的定义放在程序后边的数据部的文件节中。文件是索引文件，程序可以随机访问文件。文件的主关键字是NUMBER OF EMPLOYEE-RECORD，替换关键字是LAST-NAME和SS-NUMBER，都是文件记录区的字段。LAST-NAME允许重复。\r\n<p>   文件状态：(对文件操作时返回文件状态到定义的文件状态变量)<br>   ANY            00 成功<br>   ANY            02 对索引文件，成功但发现重复关键字<br>   READ           04 成功，但纪录长度不符合指定长度<br>   OPEN           05 成功，但文件是可选的，前面不存在<br>   OPEN,CLOSE     07 对顺序文件，成功，但媒介不是盘<br>   READ           10 文件已到末尾<br>   READ           14 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位<br>   WRITE,REWRITE  21 对索引文件，顺序出错<br>   WRITE          22 对索引和相对文件，带这个关键字的纪录已经存在<br>   START,READ     23 对索引和相对文件，带这个关键字的纪录不存在<br>   WRITE          24 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位<br>   ANY            30 I/O错误<br>   WRITE          34 对顺序文件，发生超边界错误<br>   OPEN           35 对顺序和相对文件，未发现非可选文件<br>   OPEN           37 对顺序和相对文件，该文件不支持指定的打开方式<br>   OPEN           38 对顺序和相对文件，文件已经用锁关闭<br>   OPEN           39 对顺序和相对文件，文件属性不支持程序中指定的属性<br>   OPEN           41 文件已经打开<br>   CLOSE          42 文件未打开<br>   DELETE,REWRITE 43 最近的操作不是READ<br>   WRITE,REWRITE  44 纪录长度非法<br>   READ           46 没有有效的下一个记录<br>   READ,START     47 文件未在INPUT或I-O方式中打开<br>   WRITE          48 文件未在OUTPUT或EXTEND方式中打开<br>   DELETE,REWRITE 49 文件未在I-O方式中打开<br>   ANY            90~99 厂家定义\r\n<p>   由上可知，文件操作时会发生错误，COBOL提供了检查错误和恢复I/O错误的公用地点。过程部开头应包括DECLARATIVES部分，放上出现错误时要执行的语句。<br>   PROCEDURE DIVISION.<br>   DECLARATIVES.<br>   section-name SECTION.<br>   USE statement(出现错误时调用的节).<br>   paragraph-name.<br>   sentence…<br>   END DECLARATIVES.<br>   section-name SECTION.<br>   paragraph-name.<br>   sentence…<br>   USE AFTER STANDARD EXCEPTION/ERROR PROCEDURE ON file-name/INPUT/OUTPUT/I-O/EXTEND<br>   只能在USE语句中指定一个文件，一种方式也只能有一个USE语句。如果既指定了文件，也指定了方式，则文件优先。\r\n<p>   程序使用的所有文件要定义在数据部的第一节——文件节中。<br>   FD file-name<br>   [BLOCK CONTAINS int-1 [TO int-2] RECORDS/CHARACTERS]<br>   [RECORD (CONTAINS int-3 [TO int-4] CHARACTERS)/(IS VARYING IN SIZE [FROM int-5] [TO int-6] CHARACTERS)/(DEPENDING ON data1)<br>   [LABEL (RECORD IS)/(RECORDS ARE) STANDARD/OMITTED]<br>   [VALUE OF (implementor-name IS id-lit-1)…]<br>   [DATA (RECORD IS)/(RECORDS ARE) data2]<br>   BLOCK CONTAINS 指定实际纪录的具体长度或最大与最小长度的逻辑记录数或块数。一般有操作系统和文件系统指定。<br>   RECORD 指定包含变长纪录的文件中记录的最大与最小长度或定长纪录的具体长度。<br>   RECORD CONTAINS 如果不带TO，则int-3是每个纪录的长度；如果带TO,介于int-3和int-4之间。<br>   RECORD IS VARYING 指定纪录长度最小int-5和最大int-6。<br>   DEPENDING ON 如要用，则需要在data1中保存纪录长度。<br>   LABEL RECORD 指定文件是否带标号。（过时，下个版本不包含）<br>   VALUE 和LABEL一起检查标号的不同部分。（过时，下个版本不包含）<br>   DATA RECORD 指定属于文件的纪录描述项（FD后的01层项目）并作为程序文档。（过时，下个版本不包含）<br>   一般定义文件只用第一句：FD file-name<br>  顺序文件的LINAGE声明<br>   对顺序文件，LINAGE声明可以在文件输出是打印机或打印机兼容文件时指定一些打印细节。<br>   [LINAGE IS BODY LINES [WITH FOOTING AT FOOT][LINES AT TOP TOP][LINES AT BOTTOM BOTTOM]] [CODE-SET IS alphabet-name]<br>   整个文件分成TOP,BODY,BOTTOM三部分。其中BODY包含有FOOT.<br>   CODE-SET指定文件中所用的字符集。\r\n<p>   过程部主要是对文件的OPEN,CLOSE,READ,WRITE,START,REWRITE,DELETE等操作。<br>OPEN<br>   OPEN文件有4种方式：（如果文件声明为OPTIONAL，则文件不存在会创建文件，否则会报错）<br>   OPEN INPUT FILE-NAME.    只能读取的文件。<br>   OPEN OUTPUT FILE-NAME.   生成写入纪录的文件，读取该文件会出错。若文件已存在，已有记录会被全部删除。<br>   OPEN I-O FILE-NAME.      可读可写的文件。<br>   OPEN EXTEND FILE-NAME.   生成写入的文件。与UOTPUT的区别在于，若文件已存在，EXTEND将纪录加在文件末尾。<br>   如果OPEN不成功，执行USE语句。USE语句不存在，则程序结束。<br>   顺序文件的OPEN可以有以下方式：<br>   OPEN INPUT FILE-NAME [(WITH NO REWIND)/REVERSED].<br>   OPEN OUTPUT FILE-NAME [WITH NO REWIND].<br>   REVERSED可以逆序处理，即由后向前处理。（过时，下个版本不包含）<br>   WITH NO REWIND 用于单卷磁带文件，如果指定文件在不适用REWIND的媒介上，忽略。<br>   在文件描述项中指定LINAGE得顺序文件不能用EXTEND方式打开。\r\n<p>CLOSE<br>   所有文件的CLOSE方法：<br>   CLOSE FILE-NAME.    关闭文件。<br>   CLOSE FILE-NAME WITH LOCK.    关闭文件，不退出程序不能再打开此文件。<br>   顺序文件还有其他一些选项,如关闭卷或单元，和继续处理文件：<br>   CLOSE file-name [REEL/UNIT] [FOR REMOVAL]/WITH NO REWIND\r\n<p>READ<br>   顺序访问方式读文件。一定要有NEXT字样。<br>   READ file-name [NEXT] RECORD [INTO data1]<br>   [AT END statements][NOT AT END statements] [END-READ]<br>   如果READ成功且有INTO，将读到的数据写入data1。<br>   如果文件中没有记录，执行AT ENDstatements，如果没有就执行USE。<br>   如果READ成功，就执行NOT AT END statements。\r\n<p>   动态访问方式读文件。(相对或索引文件)<br>   利用OPEN语句，将文件指针设在开头。<br>   进行各种成功的READ操作。<br>   有START语句标识文件中的纪录。<br>   随机访问方式读文件。<br>   READ file-name RECORD [INTO data1]<br>   [INVALID KEY statements][NOT INVALID KEY statements] [END-READ]<br>   如果READ成功且有INTO，将读到的数据写入data1。<br>   如果文件中没有记录，执行INVALID KEY statements，如果没有就执行USE。<br>   如果READ成功，就执行NOT INVALID KEY statements。<br>   如果是相对文件，要设置文件控制项RELATIVE KEY中指定的整型关键字值后才能执行READ.<br>   如果是索引文件，要设置当前索引的关键字值后才能执行READ.\r\n<p>WRITE<br>   顺序方式。<br>   WRITE data [FROM data1] [BEFORE/AFTER ADVANCING mnemonic-name/PAGE/N LINE(LINES)]<br>   [AT END-OF-PAGE(EOP) statements][NOT AT END-OF-PAGE(EOP) statements][END-WRITE]<br>   如果指定了FROM，先将data1复制到data，再写入文件。<br>   BEFORE/AFTER ADVANCING N LINE(LINES) 在纪录间插入N个空行。<br>   AT END-OF-PAGE(EOP) 对于带LINAGE的文件有效，在WRITE使指针进入页脚(FOOT)时，先执行WRITE，再执行AT END-OF-PAGE(EOP) statements。\r\n<p>   相对和索引文件方式。<br>   WRITE data [FROM data1]<br>   [INVALID KEY statements][NOT INVALID KEY statements] [END-WRITE]\r\n<p>REWRITE<br>   替换文件中的一个记录。<br>   顺序方式：REWRITE data [FROM data1] [END-REWRITE]<br>   相对和索引方式：<br>   REWRITE data [FROM data1]<br>   [INVALID KEY statements][NOT INVALID KEY statements] [END-REWRITE]\r\n<p>DELETE<br>   删除文件中的一个记录。只能用于相对或索引组织的文件。<br>   DELETE file-name RECORD<br>   [INVALID KEY statements][NOT INVALID KEY statements] [END-DELETE]<br>   顺序访问方式的话，前一个READ的纪录被删除。<br>   随机或动态访问的话，RELATIVE KEY的内容或主关键字所表示的纪录从文件中删除。\r\n<p>START<br>   将相对或索引文件定位到某个纪录，以便对其进行顺序访问。只对相对和索引文件有效。<br>   START file-name [KEY IS (EQUAL TO)/=/GREATER THAN/&gt;/NOT LESS THAN/NOT &lt; data]<br>   [INVALID KEY statements][NOT INVALID KEY statements] [END-START]<br>   如果执行成功，则data所属的索引变成文件的当前索引。<br>   对于相对文件，data定义为文件的RELATIVE KEY的数据项。<br>   对于索引文件，data为下列之一：<br>   文件的主关键字，是RECORD KEY从句中指定的数据项。<br>   文件的替换关键字，是ALTERNATE RECORD KEY从句指定的数据项。<br>   从一个关键字的第一个位置开头，长度小于或等于该关键字的数据项。\r\n', null, null, null, '2020-10-18 20:55:38', '2020-10-18 21:09:49', '1');
INSERT INTO `articles` VALUES ('48', '1', 'COBOL语言概述', '', '一．COBOL程序的结构\r\n1．部\r\nIDENTIFICATION DIVISION 标识部\r\nENVIRONMENT DIVISION 环境部\r\nDATA DIVISION 数据部\r\nPROCEDURE DIVISION 过程部\r\n2．节（SECTION）和段（PARAGRAPH）\r\n（1）部-节-段\r\n（2）标识部下面不设节，直接设段\r\n（3）过程部可以设节，下面再设段，也可以直接设段\r\n3．句子、语句和子句\r\n每一段由若干句子（Sentence）组成，一个句子以句号加上一个以上的空格来结束。\r\n句子由语句（Statement）组成。\r\n语句中又可以包含若干子句（clause），每一个子句也有一个动词（但这个动词往往是可以省略的），它指定某一方面的特定功能。\r\n二．COBOL源程序的书写格式\r\n1．1-6列：标号区\r\n2．第7列：续行标志区（“-”为续行，“×”为注解）\r\n3．8-11列：A区（部头，节头，段头，层号01、77，文件描述符FD等）\r\n4．12-72列：B区（正文）\r\n5．73-80列：注释区\r\n三．COBOL字符\r\n数字0-9，大写字母A-Z，小写字母a-z，\r\n专用字符15个{ + - × / = , . ; ‘ ( ) < > $ 空格 }\r\n四．常量\r\n1．数值常量\r\n（1）小数点不能多于一个，而且不能出现在常数最右边。\r\n（2）数值常量的长度不能超过18位数字。\r\n（3）至少要有一个数字，不能有多于一个符号。\r\n（4）数字间不能有空格，空格是分界符。\r\n2．非数值常量\r\n（1）用’’把字符串包起来\r\n（2）假如要把’’放到非数值常量中，用QUOTE保留字，\r\n如 MOVE QUOTE ‘CHINA’QUOTE TO A\r\n（3）长度不应超过120个字符。\r\n五．COBOL的数据关系\r\n过程部初步\r\n一．输入输出语句\r\n1．ACCEPT（接收语句）：直接从中断键盘或系统指定的输入设备上输入少量的数据。\r\n语法：ACCEPT 标识符 [FROM 助忆名]\r\n2．READ（读语句）：从外部文件上读入数据输到程序中的数据项中。\r\n语法：READ 文件名 RECORD [INTO 标识符][；AT END 执行语句]\r\n3．WRITE（写语句）：将内存区中的数据输出到外部设备\r\n语法：\r\nWRITE 记录名 [FROM 标识符1][BEFORE ADVANCING 标识符2/整数 LINE/LINES]\r\nAFTER 助忆名/PAEG\r\n4．OPEN（打开语句）：程序若要读和写文件，先要把文件打开\r\n语法：OPEN INPUT/OUPUT 文件名1[，文件名2……]\r\n5．CLOSE（关闭语句）：关闭文件。\r\n语法：CLOSE 文件名1[，文件名2……]\r\n二．算术运算语句\r\n1．ADD（加法语句）\r\n举例：ADD A TO B A+BaB\r\nADD 15 TO C 15+CaC\r\nADD A，B TO C A+B+CaC\r\nADD 15，25 TO C 15+25+CaC\r\nADD A，B GIVING C A+B–C\r\nADD 15，25 GIVING T 15+25aT\r\nADD A，B TO C，D A+B+CaC,A+B+DaD\r\n2．SUBTRACT（减法语句）\r\n举例：SUBTRACT B FROM A A-BaA\r\nSUBTRACT B，C FROM A A-B-CaA\r\nSUBTRACT B，C FROM A，T A-B-CaA,T-B-CaT\r\nSUBTRACT B，C FROM A GIVING X A-B-CaX\r\n3．MULTIPLY（乘法语句）\r\n举例：MULTIPLY A BY B A×BaB\r\nMULTIPLY 0.5 BY B 0.5×BaB\r\nMULTIPLY A BY B GIVING C A×BaC\r\nMULTIPLY 1.5 BY 3 GIVING C,A 1.5×3aC,1.5×3aA\r\nMULTIPLY A BY B,C A×BaB,A×CaC\r\n4．DIVIDE（除法语句）\r\n举例：DIVIDE A INTO B B/AaB\r\nDIVIDE A INTO B GIVING C B/AaC\r\nDIVIDE A BY B GIVING C A/BaC\r\n5．COMPUTE（计算语句）\r\n语法：COMPUTE 标识符1[，标识符2]……=算术表达式\r\n举例：COMPUTE T = （A + B） × C / D\r\n注意：（1）所以运算符两侧应留一空格\r\n（2）括号外侧应留空格，内侧可不要留空格\r\n三．MOVE（传送语句）\r\n语法：MOVE 标识符1/常量1 TO 标识符2[，标识符3]……\r\n四．GOTO（转移语句）\r\n语法：（1）GO TO 过程名\r\n（2）GO TO 过程名1[，过程名2]……过程名n，DEPENDING ON 标识符\r\n五．IF（条件语句）\r\n1．关系运算符\r\n\r\nCOBOL关系运算符 意义\r\nIS GREATER THAN\r\nIS > THAN 大于\r\nIS LESS THAN\r\nIS < THAN 小于\r\nIS EQUAL TO\r\nIS = TO 等于\r\nNOT GREATER THAN\r\nNOT > 不大于\r\nNOT LESS THAN\r\nNOT < 不小于\r\nNOT EQUAL TO\r\nNOT = 不等于\r\n2．IF语句的两种形式\r\n（1）IF 条件 语句组\r\n（2）IF 条件 语句组1 ELSE 语句组2\r\n3．IF语句的一般格式\r\nIF 语句组1/NEXT SENTENCE [ELSE 语句组2/NEXT SENTENCE]\r\n六．STOP（停止语句）\r\n语法：STOP RUN/常量\r\n标识部和环境部\r\n一．标识部\r\n1．必写部分\r\nIDENTIFICATION DIVISION\r\nPROGRAM-ID. 程序名.\r\n2．任选部分\r\n[AUTHOR 作者姓名.]\r\n[INSTALLATION. 计算机设置的场所.]\r\n[DATE-WRITTEN. 源程序编写的日期.]\r\n[DATE-COMPILED. 源程序编译的日期.]\r\n[SECURITY. 保密程度.]\r\n二．环境部\r\n1．环境部的一般形式\r\nENVIRONMENT DIVISION. （环境部）\r\nCONFIGURATION SECTION. （配置节）\r\nSOURCE-COMPUTER. 源计算机名\r\nOBJECT-COMPUTER. 目标计算机名\r\n[SPECIAL-NAMES. 专用名描述项]\r\n[INPUT-OUTPUT SECTION. （输入输出节）\r\nFILE-CONTROL. {文件描述体}……\r\n[I-O-CONTROL. 输入输出控制描述体]]\r\n2．配置节（CONFIGURATION SECTION）\r\n（1）源计算机段和目标计算机段的一般格式\r\nSOURCE-COMPUTER.\r\nOBJECT-COMPUTER.\r\n[MEMORY SIZE IS 整数{WORDS/CHARACTERS/MODULES}]\r\n（2）专用名段\r\n格式：SPECIAL-NAMES.\r\n[DECIMAL-POINT IS COMMA.]\r\n[CURRENCY SIGN IS 非数值常量.]\r\n[专用名 IS 助记名.]\r\n3．输入输出节（分为输入输出控制段与文件控制段）\r\n文件控制段\r\n格式：INPUT-OUTPUT SECTION. （输入输出节）\r\nFILE-CONTROL. （文件控制段）\r\nSELECT 文件名 ASSIGN TO 外部文件名.\r\n说明：SELECT的三种用法\r\n（1）        在SELECT子句的“ASSIGN TO”的后面写上磁盘上实际的文件名。\r\n（2）        在SELECT子句中只指出外部设备名。\r\n（3）        在一些中、大型计算机系统，在SELECT子句中用该系统指定的逻辑名作为外部文件名，然后用作业控制语句将该逻辑名与实际的设备和文件相联系。\r\n数据部（一）\r\n一．概述\r\n1．数据有两种：孤立的数据项，组合的数据项\r\n2．数据的层次与层号\r\n（1）数据的层次结构：记录a组合项a初等项\r\n（2）层次的规定如下：\r\n用来描述数据层次结构的层号从01开始，到49。记录的最高层次定为01号。\r\n层号小的组合项包含层号大的数据项（组合项或初等项）。\r\n一个层号为K的组合项包括它下面所有层号比它大的组合项和初等项，直到遇到层号小于K或等于K的层次为止。\r\n3．数据部的结构\r\n（1）文件节（FILE SECTION）\r\n用来描述程序中用到的输入文件和输出文件及其记录中各数据项的属性。\r\n（2）工作单元节（WORKING-STORAGE SECTION）\r\n用来描述程序中用到的数据项。\r\n（3）联接节（LINKAGE SECTION）\r\n用来描述与调用程序间发生数据传递的数据项。\r\n（4）报表节（REPORT SECTION）\r\n为了完成报表编制功能，此节用来规定欲输出的报表的“体裁“，设计各报表栏的打印形式和方法等。\r\n二．文件节\r\n1．文件描述\r\n格式：FD 文件名 LABEL {RECORD IS/RECORDS ARE} {STANDARD/OMITTED} [DATA {RECORD IS/RECORDS ARE} 数据名]\r\n2．记录描述\r\n记录描述体由01层号开头，后跟记录名。\r\n如果记录下面不再分项，即记录本身就是一个初等项，则这种描述体最简单。\r\n三．字型子句（PIC子句）\r\n1．数值型数据的描述\r\n（1）“9”描述符：表示在该位置上可以放入一个0-9之间的数字\r\n举例：02 X PIC 9999.\r\n02 Y PIC 9(5).\r\n（2）“V”描述符：支持在数值型数据结构中隐含的小数点位置\r\n举例：03 M PIC 999V999.\r\n（3）“P”描述符：对低位上有若干个零的数，可以用该描述符。\r\n举例：01 A PIC 9P(9). 表示10的9次方\r\n01 B PIC PPPP99. 表示0.000023\r\n（4）“S”描述符：如果想在数据项中放入一个带符号的数，可以用该描述符。对于类似PIC S99的数据项，系统在内存中该数据项的最后一个字节中，放入一个标记，表示此数为负。\r\n二．字母型数据的描述\r\n“A”描述符：这种类型的数据项中只能放字母或空格\r\n三．字符型数据的描述\r\n（1）字符型数据的规定\r\n概念：由任意的COBOL字符组成的数据，称字符型数据。\r\n说明：I.字符型数据可以用X描述符来描述，也可以用9和A描述符来描述。\r\nII.字母型数据可以用A来描述，也可以用X。\r\nIII.字符型数据中可以放数字。\r\n四．编辑型描述符\r\n1．插入小数点“.”，用“.”描述符。\r\n2．插入逗号“，”作分位号，用“，”描述符。\r\n3．插入零，用“0”描述符。\r\n4．插入空格，用“B”描述符。\r\n5．插入正负号，用“+”或“-”描述符。\r\n6．插入“$”\r\n（1）加到数字前。\r\n（2）在数字前加正负号和$。\r\n7．浮动插入正负号和“$”\r\n8．取消高位零，用“Z”和“×”描述符。\r\n9．插入“DB“和“CR”字符：此两个描述符只能用作固定插入，而且只作最后一个描述符号。当数值为正时，此两次留两个空格；为负时，在编辑型数据项中最后两个字节中置DB或CR。五．PIC子句小结\r\n1．格式：PICTURE/PIC IS 描述字符串\r\n2．每一种类型数据可以使用的描述字符如下：\r\n\r\n数据类型 在PIC子句中允许使用的描述字符\r\n数值数据项 9 V S P\r\n字母数据项 A\r\n字符数据项 9 A X\r\n编辑数值数据项 9 P V . , B Z + - $ × 0 CR DB\r\n编辑字符数据项 A X 9 B 0\r\n3．描述字符的含义\r\n\r\n描述字符 含义\r\n9 表示一个数字的位置\r\nA 表示一个字母的位置\r\nX 表示一个字符的位置\r\nV 表示隐含小数点的位置\r\nS 表示数值数据带符号\r\nP 表示十进制比例换算，即指明落在数据域外的十进制小数点位置\r\n$ 插入货币号位置\r\n. 插入小数点位置\r\n, 插入逗号的位置\r\n+ 一律加符号\r\n- 对负数加负号，对正数前留一空格\r\nZ 取消高位零，以代空格\r\n× 取消高位零，代以×\r\nB 插入空格的位置\r\n0 插入零的位置\r\nDB（借方） 数据为负时，在数据后面出现DB，数据为正时，数据后空两格\r\nCR（贷方） 数据为负时，在数据后面出现CR，数据为正时，数据后空两格\r\n四．工作单元节（WORKING-STORAGE SECTION）\r\n1．工作单元节的作用\r\n程序中用的数据项分两部分：一部分是属于输入或输出文件的，另一部分是非输入或输出的数据。\r\n在工作单元节中描述的数据项也有两种形式：一种是孤立的数据项，它们是初等项。\r\n一种是组合项。COBOL规定，孤立的数据项的描述体以层号77开头，组合项描述体以01到49之间的一个数作层号。在次序上常先写77层，再写01-49层。\r\n2．赋初值子句（VALUE子句）\r\n举例：77 A PIC 99 VALUE IS 0.\r\n77 T PIC X(9) VALUE ‘fogshadow’.\r\n说明：只有对工作单元节中的数据项可以赋初值。\r\n过程部之二\r\n一．传送语句（MOVE语句）的较高技巧\r\n1．各种类型数据间的传送\r\n（1）同类型数据间的传送\r\n（2）编辑传送。\r\n注意：传送的方向必须是由数值型数据传送给编辑型数据，而不能由编辑型数据传送给数值型数据。\r\n（3）不同类型数据间的传送规则。\r\n说明：Y为允许传送，N为不允许，Z为在某些情况下是正确的\r\n\r\n横接收项\r\n竖发送项 数值型 数值编辑型 字母型 字符型 字符编辑型 组合项\r\n整数 非整数\r\n数值型 整数 Y Y Y Y Y Y Y\r\n非整数 Y Y Y N N N Y\r\n数值编辑型 N N N N Y Y Y\r\n字母型 N N N Y Y Y Y\r\n字符型 Z Z Z Z Y Y Y\r\n编辑字符型 N N N N Y Y Y\r\n数值常量 Y Y Y N N N Y\r\n非数值常量 N N N Y Y Y Y\r\nZERO Y Y Y N Y Y Y\r\nSPACE N N N Y Y Y Y\r\n组合项 Z Z Z Z Y Y Y\r\n2．组合项的传送\r\n（1）发送项和接收项都是组合项，而且其结构和描述均相同，则可看作将各初等项一一对应传送。\r\n（2）如发送项与接收项长度相同，但数据结构形式不同，则将发送项的内容原样不变地自左而右顺序地传送到接收项。\r\n3．对应传送（带CORRESPONDING子句的MOVE语句）\r\n（1）数据名的受限与受限名的传送\r\n数据名和限定符之间用OF或IN 来连接。\r\n举例：MOVe A1 OF A OF SUM TO T1.\r\n（2）用CORRESPONDING子句的传送——对应传送（同名传送）\r\n作用：把一个组合项中若干项传送给另一组合项中同名的项。\r\n格式：MOVE CORRESPONDING/CORR 标识符1 TO 标识符2\r\n二．算术运算语句的较高技巧\r\n1．四舍五入处理（ROUNDED子句）\r\n作用：按照数据项的描述要求对多余位截断，然后对被截断的后一位数进行四舍五入处理。\r\n举例：ADD A，B TO C ROUNDED\r\n\r\nA+B+C值 C描述 有无ROUNDED C内容\r\n186.7851 999 有 187\r\n186.7851 999V9 有 186.8\r\n186.7851 999V99 有 186.79\r\n186.7851 999V999 有 186.785\r\n如果计算结果有多个，则应该分别说明哪一个接收项要进行舍入处理，ROUNDED应写在有关的接收项（结果数据项）的数据名后面，如\r\nADD A,B,C TO D,E,F ROUNDED,G ROUNDED,H\r\n2．长度溢出处理\r\n当计算结果的整数部分的长度如果比结果数据项描述所规定的整数部分长，则发生长度溢出，结果的高位部分被截断。\r\nON SIZE ERROR子句提供“溢出”处理。即当发生溢出错误的时候，按程序设计者事先指定的操作处理。\r\n举例：MULTIPLY A BY B GIVING C\r\nON SIZE ERROR DISPLAY‘SIZE ERROR‘ STOP RUN.\r\n3．对应项间的运算（带CORRESPONDING子句的算术运算语句）\r\n格式：ADD CORRESPONDING/CORR 标识符1 TO 标识符2 [ROUNDED]\r\n[;ON SIZE ERROR 强制语句]\r\nSUBTRACT CORRESPONDING/CORR 标识符1 TO 标识符2 [ROUNDED]\r\n[;ON SIZE ERROR 强制语句]\r\n4．除法语句中的余数子句（REMAINDER子句）\r\n举例：DIVIDE 1.5 INTO 7 GIVING C REMAINDER D.\r\n三．IF语句的高级技巧\r\n1．IF语句的嵌套\r\n举例：（注意IF与ELSE的一一配对）\r\nIF A=B\r\nMOVE B TO T\r\nIF A=C\r\nMOVE C TO R\r\nIF X\r\n\r\nSUBTRACT X FROM Y\r\nIF N=M\r\nIF P=Q\r\nDISPLAY P,Q\r\nELSE NEXT SENTENCE\r\nELSE NEXT SENTENCE\r\nELSE NEXT SENTENCE\r\nELSE NEXT SENTENCE\r\nELSE NEXT SENTENCE\r\n2．关系表达式条件\r\n以下为关系条件的比较方式，其中，Y表示作为数值型比较，N表示作为非数值型（即字符型比较），Z表示不能比较。\r\n\r\n横-客体\r\n竖-主体 数值型 数值常量 非数值常量 字母型 字符型 组合项\r\n数值型 Y Y N N N N\r\n数值常量 Y Z Z N N N\r\n非数值常量 N Z Z N N\r\n字母型 N N N N N N\r\n字符型 N N N N N N\r\n组合项 N N N N N N\r\n3．符号条件\r\n格式：数据名/数值表达式 IS [NOT] POSITIVE/NEGATIVE/ZERO\r\n举例：（1）IF X IS POSITIVE 与 IF X>0 等价\r\n（2）IF X IS NEGATIVE 与 IF X<0 等价\r\n（3）IF X IS ZERO 与 IF X=0 等价\r\n4．类型条件\r\n格式：标识符 IS [NOT] NUMERIC/ALPHABETIC\r\n其中，NUMERIC表示数值类型，ALPHABETIC表示字母类型。\r\n5．条件名条件\r\n作用：用来代替一系列繁杂的IF-ELSE语句。\r\n格式：88 条件名 VALUE IS/ARE 常量1[THROUGH/THRU 常量2]\r\n[常量3[[THROUGH/THRU 常量4]]……\r\n举例：首先在数据部说明\r\n77 X (条件变量) PIC 9(6).\r\n88 X1 VALUE 0 THRU 99.\r\n88 X2 VALUE 100 THRU 999.\r\n88 X3 VALUE 1000 THRU 4999.\r\n88 X4 VALUE 5000 THRU 100000.\r\n经过上面的说明后，可以在过程部中直接使用条件名条件。\r\nIF X1 MOVE 0.03 TO R. (在0<=X<100时，R=0.03)\r\nIF X2 MOVE 0.04 TO R. (在100<=X<1000时，R=0.04)\r\nIF X3 MOVE 0.05 TO R. (在1000<=X<5000时，R=0.05)\r\nIF X4 MOVE 0.06 TO R. (在5000<=X<=100000时，R=0.06)\r\n6．复合条件\r\n逻辑运算符有：AND、OR、NOT\r\n运算次序是：NOTaANDaOR\r\n五．字符串连接语句（STRING语句）\r\n六．字符串分解语句（UNSTRING语句）\r\n七．检测语句（INSPECT语句）\r\n八．转换语句（TRANSFORM语句）\r\n过程部之三\r\n—执行语句（PERFORM语句）\r\n一．执行语句的作用 类似于子程序\r\n二．执行语句的最基本形式\r\n格式：PERFORM 过程名1[THROUGH/THRU 过程名2]\r\n三．执行语句的使用规则\r\n1．PERFORM语句的嵌套\r\n2．在PERFORM语句所执行的语句序列中，可以含有转移语句，可以使流程转到语句序列之外，但一般应该转回到此语句序列，以便能最后能执行此语句序列的最后一个句子。\r\n四．使用PERFORM语句实现循环\r\n格式：PERFORM 过程名1[THROUGH/THRU 过程名2] 整数/标识符 TIMES\r\n说明：1.标识符应为整数数据项\r\n2如果此标识符的值在执行语句序列中有变化，不会影响执行次数。即以它开始时候的值来决定执行的次数。\r\n五．执行语句的较复杂的形式\r\n1．格式：PERFORM 过程名1[THROUGH /THRU 过程名2 ] UNTIL 条件\r\n作用：反复执行指定的语句序列，直到给定的条件满足为止。\r\n2．格式：\r\nPERFORM 过程1[THROUGH/THRU 过程名2]\r\nVARYING 标识符1 FROM 常数1/标识符2 BY 常数2/标识符3 UNTIL 条件\r\n举例：PERFORM T1 THRU T2 VARYING X FROM A\r\nBY B UNTIL X>5\r\n其作用是执行T1到T2语句序列，X是“循环变量”，是整型数据项。A为初值，B为步长，它们都是整数或整数数据项。\r\n六．执行语句的多重循环形式\r\n格式：PERFORM 过程名1 [THROUGH/THRU] 过程名2\r\n[VARYING 参数1 FROM 初值1 BY 步长1 UNTIL 条件1]\r\n[AFTER 参数2 FROM 初值2 BY 步长2 UNTIL 条件2]\r\n[AFTER 参数3 FROM 初值3 BY 步长3 UNTIL 条件3]\r\n说明：1。最后面的循环体先执行。\r\n2．COBOL允许用到三重循环。\r\n七．出口语句（EXIT语句）\r\n作用：提供一个段名，被PERFORM调用的语句序列由此公共汇集点，返回到PERFORM的下一个语句去。\r\n举例：PERFORM A THRU B\r\n……\r\nA. IF X>Y GO TO B\r\nMOVE X TO T.\r\nB.            EXIT.\r\n八．修改语句（ALTER语句）\r\n格式：ALTER 过程名1 TO [PROCEED TO] 过程名2\r\n[，过程名3 TO [PROCEED TO] 过程名4]……\r\n作用：用来改变GO TO的转向点。该语句使以过程名1，过程名3，……命名的各段中的GO TO语句的转向点分别被修改为过程名2，过程名4……。注意，过程名1，过程名3……各段只能由一条GO TO语句单独组成。\r\n数据部之二\r\n-数据部的较高技巧\r\n一．数据在计算机内的表示形式\r\n1．字符数据在内存中的存储形式\r\n（1）ACSII\r\n（2）EBCDIC\r\n2．数值型数据在内存中的存储形式\r\n（1）外部十进制（或称扩张十进制）形式\r\n（2）外部浮点数形式\r\n（3）内部十进制（又称缩合十进制）形式\r\n（4）定点二进制形式\r\n（5）内部浮点形式\r\n二．用法子句（USAGE子句）\r\n作用：可以使程序设计者自由选择数据在内存中的存放形式。\r\n格式：[USAGE IS] DISPLAY/COMPUTATIONAL/COMP\r\n说明：1。DISPLAY表示是“显示型的用法”，表示此数据项适于显示，打印。\r\n2．COMPUTATIONAL=COMP，表示是“计算型的用法”，适于计算。\r\n3．如省略USAGE子句，则隐含表示为用DISPLAY形式。\r\n三．符号子句（SIGN子句）\r\n作用：用来指定数值型数据描述体中运算符号的状态和位置。\r\n格式：[SIGN IS] LEADING/TRAILING [SEPARATE CHARACTER]\r\n说明：1。没有SIGN子句时，数值的符号是存放在数据项最后一个字节中的。\r\n2．用SIGN子句可以指定符号在数值的前部还是后部（LEADING/TRAILING）。\r\n3．指定符号单独占一个字节，用“SEPARATE”可选项，内存中增加一个字节。\r\n4．SIGN子句只能用于PIC字符串中含有“S”的数值型数据描述体中。\r\n5．使用SIGN子句的数据项的用法应该是USAGE DISPLAY（显式的或隐含的）。\r\n举例：02 A PIC S9(3) USAGE DISPLAY SIGN IS LEADING.\r\n四．重定义子句（REDEFINES子句）\r\n作用：不同的数据项可以共用内存中的同一段空间。例如已给数据项A分配了一段内存空间，在经过某一段的过程后，A已经不再使用了，但它仍占着内存这部分空间，为了节约内存，可以将另一数据项B也分配在A所占的这段内存空间。\r\n格式：层号 数据名1 REDEFINES 数据名2\r\n举例：02 A PIC X(5).\r\n02 B REDEFINES A PIC 9(5).\r\n说明：\r\n1。数据名2 与数据名1的层号必须相同。\r\n2．用REDEFINES子句的描述体应该紧跟在被重新定义的数据项的描述之后，中间不能插入其它项的描述说明。\r\n3．可以多次重定义，但必须紧跟出现，而且要求使用最初定义的数据名。\r\n4．REDEFINES子句不能用于文件节的01层中。\r\n5．用REDEFINES子句可以改变数据结构，但数据名1、2的长度应该相等。\r\n6．REDEFINES子句应在其它子句之前。\r\n7．重定义子句所在的数据描述体中不能使用初值子句赋初值。.\r\n五．重命名子句（RENAMES子句）\r\n作用：在不改变数据项的长度的前提下，重新定义数据区的名称和数据结构的形式（包括初等项的类型和长度）。可以把原来已经定义的某些数据项重新组合成一个新项，并以一个新名字来代表它。但用重命名子句不能改变原来各初等项的类型、长度等属性。\r\n格式：66 数据名1 RENAMES 数据名2 [THRU 数据名3]\r\n说明：只能用于工作单元节中，不能用于文件节中\r\n六．遇零置空子句（BLANK子句）\r\n作用：当数据项的值为零时，使它的内容改变为空白（空格）。这个子句只能用于数值型或编辑型的初等项。\r\n举例：03 A PIC 9999 BLANK WHEN ZERO.\r\n七．对齐子句（JUSTIFIED子句）\r\n作用：字符或字母型数据传送的时候是按标准的对齐方式，即“左对齐”，若想改为“右对齐”，可以用JUSTIFIED子句。\r\n格式：JUSTIFIED/JUST RIGHT\r\n举例：77 B PIC X（5） JUSTIFIED RIGHT\r\n八．同步安置子句（SYNCHRONIZED子句）\r\n作用：一个机器字一般定为4个字节，从内存中取数据的时候是以机器字为单位的，而数据存放则是按字节连续存放的，这里面就存在一个边界对齐的矛盾，会影响目标程序运行时间。用同步安置子句可以指定数据项在内存中如何按自然边界来安置。\r\n格式：SYNCHRONIZED/SYNC LEFT/RIGHT\r\n说明：1。用SYNC LEFT时，左对齐，右边补零或空格。\r\n2．用SYNC RIGHT时，右对齐，左边补零或空格。\r\n举例：01 A.\r\n02        A1 PIC 9(3) SYNC LEFT VALUE 82.\r\n03        A2 PIC X(3) SYNC RIGHT VALUE ‘ABC’\r\n九．复写语句（COPY语句）\r\n作用：把“源程序库”中的某些记录描述和数据描述插入到自己的源程序中。\r\n格式：COPY 库名 [REPLACING 标识符1/常量1/字1 BY 标识符2/常量2/字2]\r\n子程序\r\n一．概述\r\n举例：编一个打印一行“×”符号的子程序\r\n1． 主程序（只写与调用子程序有关的部分）\r\nIDENTIFICATION DIVISION. （标识部）\r\nPROGRAM-ID. A. （程序名为A）\r\nENVIRONMENT DIVISION. （环境部）\r\n……\r\nDATA DIVISION. （数据部）\r\n……\r\nPROCEDURE DIVISION. （过程部）\r\n……\r\nCALL B. （调用子程序B）\r\n……\r\n2． 子程序\r\nIDENTIFICATION DIVISION.\r\nPROGRAM-ID. B.\r\nENVIRONMENT DIVISION.\r\nDATA DIVISION.\r\nWORKING-STORAGE SECTION.\r\n77        X PIC X(80).\r\nPROCEDURE DIVISION.\r\nMOVE ALL’×’ TO X.\r\nDISPLAY X.\r\nEXIT PROGRAM.\r\n可以看到程序A和程序B分别是两个程序，各有自己的程序名，都有四大部分。\r\n二．调用程序与被调用程序间的数据联系\r\n格式：调用语句\r\nCALL 子程序名 USING 数据名1 [，数据名2]……]\r\n被调用程序中过程部部头的一般格式为\r\nPROCEDURE DIVISION [USING 数据名1[，数据名2]……]\r\n说明：1。两部分相对应的参数个数、长度必须相等。\r\n2．参数是在内存中建立关联，类似于C++中的传递引用参数。\r\n三．子程序的结构\r\n1．标识部\r\n说明子程序的名字，以供调用。\r\n2．环境部\r\n3．数据部\r\n（1）文件节（FILE SECTION）\r\n（2）工作单元节（WORKING-STORAGE SECTION）\r\n（3）联接节（LINKAGE SECTION）：如果子程序过程部部头的USING子句中有数据名，则此数据名应在此节中加以说明。\r\n4．过程部\r\n过程部的部头：PROCEDURE DIVISION USING 数据名1，数据名2，……\r\n过程部中应该包括一个程序出口语句：EXIT PROGRAM.\r\n表的建立与查找\r\n一．表的概念\r\nCOBOL语言中的表（TABLE）类似于其他高级语言中的数组（ARRAY）。\r\n表中，序号称为下标，相对地址称为位标，下标和位标称为“出现号”。\r\n二．表的建立（OCCURS子句）\r\n格式：OCCURS 整数 TIMES\r\n举例：01 PRODUCT-RECORD.\r\n03        RODUCT OCCURS 20 TIMES.\r\n04 QUANTITY-OF-PRODUCTION PIC 9(6).\r\n04 QANTITY-OF-SALES PIC 9(6).\r\n04 QANTITY-OF-HAND PIC 9(6).\r\n说明：1。OCCURS子句不能出现在77层，因为77层是独立的数据项。\r\n2．OCCURS子句不能用于01层。\r\n3．只有当OCCURS所说明的数据是初等项时，才能在该数据项的描述中使用PIC子句。\r\n4．不能用VALUE子句对表赋初值，不能同时用OCCURS子句和VALUE子句来描述同一数据项。\r\n三．可变长表\r\n格式：OCCURS 整数1 TO 整数2 TIMES DEPENDING ON 数据名1\r\n说明：根据数据名1的值来确定数据项重复的次数。\r\n四．表元素的引用\r\n格式：表名（下标）\r\n说明：1。如果B是一个表，不直接引用表名B而不加下标。\r\n2．如果表元素是组合项，则引用它下属的项（可以是初等项或组合项），也必须用下标指明它是属于哪一个表元素的。\r\n3．如果表元素是组合项，可以用它对下属的数据项进行限定。\r\n4．下标只能是整常数或具有整型值的数据名。\r\n5．下标不能是带下标的数据名，即不能是表元素。\r\n五．给表元素赋初值\r\n1．对包括所有表元素的整个表赋给一个初值，这时可以对表的描述体上面一层的数据项赋一个初值即可。\r\n例1：01 TABLE VALUE IS ZERO.\r\n03        OCCURS 20 PIC 9(3).\r\n例2：01 T VALUE ‘ABCDEFHIJ’.\r\n02        Q OCCURS 3 PIC X(3).\r\n这样，Q（1），Q（2），Q（3）的内容分别是ABC，DEF，HIJ。\r\n2．联合使用OCCURS子句和REDEFINES子句来给各个表元素赋值。\r\n（1）先在工作单元节中定义一个组合项，它占的内存的大小和需赋值的表一样，在该组合项中定义若干个数据项，数据项的描述和表的元素相同。\r\n（2）然后对这些数据项分别用VALUE子句赋以初值，由于在这些数据项的描述中没有出现OCCURS子句，因此用VALUE赋初值是合法的（VALUE子句和OCCURS子句不能同时用来描述一个数据项）。这些值就是要赋给表元素的初值。\r\n（3）把这个组合项重定义为一个表。\r\n六．用位标法(cursor)引用表元素\r\n1．位标的概念：位标的值表示表元素在该表中的相对位置（以字节数表示）。\r\n2． 位标名的指定方法：在数据部中定义一个表时所用的OCCURS子句中要加上“INDEXED BY 位标名”短语来指定。\r\n说明：（1）由于位标是专门用于引用表元素的特殊数据项，它不能用来进行算术运算。\r\n（2）一维表或多维表的每一维按需要可以指定若干个位标名，引用时这些位标名只能在该维内使用。\r\n（3）有时需要把位标的值转存到另一个数据项中，但由于位标是特殊类型的数据项，因此，需要另外定义一种特殊的数据项叫位标数据项，用来专门存储位标的值。位标数据项在数据部中定义。描述位标数据项用USAGE子句。例如：77 K USAGE IS INDEX.\r\n七．SET（设置）语句\r\n1．作用：将一表元素的相对地址放到指定的位标去。\r\n如： SET I TO 10.\r\n表示将位标I置位到第10个元素的第一个字节的相对地址上去。\r\n2．格式一\r\nSET 标识符1[，标识符2]…… TO 标识符3/位标3/整数\r\n位标1[，位标2]……\r\n规则列表（设SET A TO B）\r\n\r\n横-发送项B\r\n竖-接收项A 整数 数值初等项 位标名 位标数据项\r\n数值初等项 不合法 不合法 将位标代表的序号传送 不合法\r\n位标名 将整数（序号）化成相对地址传送 同左（1）如果两个位标名指向同一个表，则转换成另一表的相对地址再传送，即将发送项代表的表元素顺序号减1，乘以接收项相关表元素的长度，再传送简单传送\r\n位标数据项 不合法 不合法 简单传送 简单传送\r\n3． 格式二\r\nSET 位标1 [，位标2]…… UP/DOWN BY 标识符/整数\r\n作用：给位标增减一个量。\r\n八．表的检索\r\n1．用于顺序检索的SEARCH语句\r\n格式：SEARCH 表名[VARYING 位标名1/标识符2][AT END 强制语句1]\r\nWHEN 条件1 强制语句2/NEXT SENTENCE\r\n[WHEN 条件2 强制语句3/NEXT SENTENCE]……\r\n举例：SET N TO 1.\r\nSEARCH WORKER-TABLE\r\nAT END DISPLAY‘CANNOT FIND NAME’\r\nWHEN NAME（N）=‘ZHANG SHENG’\r\nDISPLAY NAME（N），PAY（N）.\r\n……\r\nSEARCH语句是这样执行的：从指定的表元素开始，检查是否满足WHEN后面指定的条件。如不满足，就使N增值，自动执行一个SET N UP BY 1。使N指向下一个元素的地址，如果查到某一个元素满足指定的条件时，查表工作立即停止，执行WHEN字句中条件后面的语句。\r\n2．用于有序表的SEARCH语句（折半法检索）\r\n（1）说明升（降）序的一般格式为：\r\nASCENDING/DESCENDING KEY IS 数据名1[，数据名2]……\r\nASCENDING/DESCENDING KEY IS 数据名3[，数据名4……]……\r\n举例：02 BOOK-TABLE OCCURS 100\r\nASCENDING KEY IS NAME\r\nDESCENDING KEY IS COD\r\nINDEX BY N.\r\n（2）SEARCH语句的一般格式（之二）\r\nSEARCH ALL 表名[；AT END 强制语句1]\r\nWHEN 条件 强制语句2/NEXT SENTENCE\r\n举例：SEARCH ALL BOOK-TABLE\r\nAT END DISPLAY’CANNOT FIND NAME’\r\nWHEN NAME(N) = ‘COMPUTER DESIGN’\r\nDISPLAY NAME (N),NUM (N).\r\n九．用PERFORM语句对表进行检索\r\n最多可以处理三重循环\r\nPERFORM 过程名1[THRU 过程名2]\r\nVARYING 位标名1/下标名1 FROM 位标名2/常量1/标识符1 BY 常量2/标识符2 UNTIL 条件1\r\nAFTER 位标名3/下标名2 FROM 位标名4/常量3/标识符3 BY 常量4/标识符4 UNTIL 条件2\r\nAFTER 位标名5/下标名4 FROM 位标名6/常量5/标识符5 BY 常量6/标识符6 UNTIL 条件3', '<p>一．COBOL程序的结构<br>1．部<br>IDENTIFICATION DIVISION 标识部<br>ENVIRONMENT DIVISION 环境部<br>DATA DIVISION 数据部<br>PROCEDURE DIVISION 过程部<br>2．节（SECTION）和段（PARAGRAPH）<br>（1）部-节-段<br>（2）标识部下面不设节，直接设段<br>（3）过程部可以设节，下面再设段，也可以直接设段<br>3．句子、语句和子句<br>每一段由若干句子（Sentence）组成，一个句子以句号加上一个以上的空格来结束。<br>句子由语句（Statement）组成。<br>语句中又可以包含若干子句（clause），每一个子句也有一个动词（但这个动词往往是可以省略的），它指定某一方面的特定功能。<br>二．COBOL源程序的书写格式<br>1．1-6列：标号区<br>2．第7列：续行标志区（“-”为续行，“×”为注解）<br>3．8-11列：A区（部头，节头，段头，层号01、77，文件描述符FD等）<br>4．12-72列：B区（正文）<br>5．73-80列：注释区<br>三．COBOL字符<br>数字0-9，大写字母A-Z，小写字母a-z，<br>专用字符15个{ + - × / = , . ; ‘ ( ) &lt; &gt; $ 空格 }<br>四．常量<br>1．数值常量<br>（1）小数点不能多于一个，而且不能出现在常数最右边。<br>（2）数值常量的长度不能超过18位数字。<br>（3）至少要有一个数字，不能有多于一个符号。<br>（4）数字间不能有空格，空格是分界符。<br>2．非数值常量<br>（1）用’’把字符串包起来<br>（2）假如要把’’放到非数值常量中，用QUOTE保留字，<br>如 MOVE QUOTE ‘CHINA’QUOTE TO A<br>（3）长度不应超过120个字符。<br>五．COBOL的数据关系<br>过程部初步<br>一．输入输出语句<br>1．ACCEPT（接收语句）：直接从中断键盘或系统指定的输入设备上输入少量的数据。<br>语法：ACCEPT 标识符 [FROM 助忆名]<br>2．READ（读语句）：从外部文件上读入数据输到程序中的数据项中。<br>语法：READ 文件名 RECORD [INTO 标识符][；AT END 执行语句]<br>3．WRITE（写语句）：将内存区中的数据输出到外部设备<br>语法：<br>WRITE 记录名 [FROM 标识符1][BEFORE ADVANCING 标识符2/整数 LINE/LINES]<br>AFTER 助忆名/PAEG<br>4．OPEN（打开语句）：程序若要读和写文件，先要把文件打开<br>语法：OPEN INPUT/OUPUT 文件名1[，文件名2……]<br>5．CLOSE（关闭语句）：关闭文件。<br>语法：CLOSE 文件名1[，文件名2……]<br>二．算术运算语句<br>1．ADD（加法语句）<br>举例：ADD A TO B A+BaB<br>ADD 15 TO C 15+CaC<br>ADD A，B TO C A+B+CaC<br>ADD 15，25 TO C 15+25+CaC<br>ADD A，B GIVING C A+B–C<br>ADD 15，25 GIVING T 15+25aT<br>ADD A，B TO C，D A+B+CaC,A+B+DaD<br>2．SUBTRACT（减法语句）<br>举例：SUBTRACT B FROM A A-BaA<br>SUBTRACT B，C FROM A A-B-CaA<br>SUBTRACT B，C FROM A，T A-B-CaA,T-B-CaT<br>SUBTRACT B，C FROM A GIVING X A-B-CaX<br>3．MULTIPLY（乘法语句）<br>举例：MULTIPLY A BY B A×BaB<br>MULTIPLY 0.5 BY B 0.5×BaB<br>MULTIPLY A BY B GIVING C A×BaC<br>MULTIPLY 1.5 BY 3 GIVING C,A 1.5×3aC,1.5×3aA<br>MULTIPLY A BY B,C A×BaB,A×CaC<br>4．DIVIDE（除法语句）<br>举例：DIVIDE A INTO B B/AaB<br>DIVIDE A INTO B GIVING C B/AaC<br>DIVIDE A BY B GIVING C A/BaC<br>5．COMPUTE（计算语句）<br>语法：COMPUTE 标识符1[，标识符2]……=算术表达式<br>举例：COMPUTE T = （A + B） × C / D<br>注意：（1）所以运算符两侧应留一空格<br>（2）括号外侧应留空格，内侧可不要留空格<br>三．MOVE（传送语句）<br>语法：MOVE 标识符1/常量1 TO 标识符2[，标识符3]……<br>四．GOTO（转移语句）<br>语法：（1）GO TO 过程名<br>（2）GO TO 过程名1[，过程名2]……过程名n，DEPENDING ON 标识符<br>五．IF（条件语句）<br>1．关系运算符\r\n<p>COBOL关系运算符 意义<br>IS GREATER THAN<br>IS &gt; THAN 大于<br>IS LESS THAN<br>IS &lt; THAN 小于<br>IS EQUAL TO<br>IS = TO 等于<br>NOT GREATER THAN<br>NOT &gt; 不大于<br>NOT LESS THAN<br>NOT &lt; 不小于<br>NOT EQUAL TO<br>NOT = 不等于<br>2．IF语句的两种形式<br>（1）IF 条件 语句组<br>（2）IF 条件 语句组1 ELSE 语句组2<br>3．IF语句的一般格式<br>IF 语句组1/NEXT SENTENCE [ELSE 语句组2/NEXT SENTENCE]<br>六．STOP（停止语句）<br>语法：STOP RUN/常量<br>标识部和环境部<br>一．标识部<br>1．必写部分<br>IDENTIFICATION DIVISION<br>PROGRAM-ID. 程序名.<br>2．任选部分<br>[AUTHOR 作者姓名.]<br>[INSTALLATION. 计算机设置的场所.]<br>[DATE-WRITTEN. 源程序编写的日期.]<br>[DATE-COMPILED. 源程序编译的日期.]<br>[SECURITY. 保密程度.]<br>二．环境部<br>1．环境部的一般形式<br>ENVIRONMENT DIVISION. （环境部）<br>CONFIGURATION SECTION. （配置节）<br>SOURCE-COMPUTER. 源计算机名<br>OBJECT-COMPUTER. 目标计算机名<br>[SPECIAL-NAMES. 专用名描述项]<br>[INPUT-OUTPUT SECTION. （输入输出节）<br>FILE-CONTROL. {文件描述体}……<br>[I-O-CONTROL. 输入输出控制描述体]]<br>2．配置节（CONFIGURATION SECTION）<br>（1）源计算机段和目标计算机段的一般格式<br>SOURCE-COMPUTER.<br>OBJECT-COMPUTER.<br>[MEMORY SIZE IS 整数{WORDS/CHARACTERS/MODULES}]<br>（2）专用名段<br>格式：SPECIAL-NAMES.<br>[DECIMAL-POINT IS COMMA.]<br>[CURRENCY SIGN IS 非数值常量.]<br>[专用名 IS 助记名.]<br>3．输入输出节（分为输入输出控制段与文件控制段）<br>文件控制段<br>格式：INPUT-OUTPUT SECTION. （输入输出节）<br>FILE-CONTROL. （文件控制段）<br>SELECT 文件名 ASSIGN TO 外部文件名.<br>说明：SELECT的三种用法<br>（1）        在SELECT子句的“ASSIGN TO”的后面写上磁盘上实际的文件名。<br>（2）        在SELECT子句中只指出外部设备名。<br>（3）        在一些中、大型计算机系统，在SELECT子句中用该系统指定的逻辑名作为外部文件名，然后用作业控制语句将该逻辑名与实际的设备和文件相联系。<br>数据部（一）<br>一．概述<br>1．数据有两种：孤立的数据项，组合的数据项<br>2．数据的层次与层号<br>（1）数据的层次结构：记录a组合项a初等项<br>（2）层次的规定如下：<br>用来描述数据层次结构的层号从01开始，到49。记录的最高层次定为01号。<br>层号小的组合项包含层号大的数据项（组合项或初等项）。<br>一个层号为K的组合项包括它下面所有层号比它大的组合项和初等项，直到遇到层号小于K或等于K的层次为止。<br>3．数据部的结构<br>（1）文件节（FILE SECTION）<br>用来描述程序中用到的输入文件和输出文件及其记录中各数据项的属性。<br>（2）工作单元节（WORKING-STORAGE SECTION）<br>用来描述程序中用到的数据项。<br>（3）联接节（LINKAGE SECTION）<br>用来描述与调用程序间发生数据传递的数据项。<br>（4）报表节（REPORT SECTION）<br>为了完成报表编制功能，此节用来规定欲输出的报表的“体裁“，设计各报表栏的打印形式和方法等。<br>二．文件节<br>1．文件描述<br>格式：FD 文件名 LABEL {RECORD IS/RECORDS ARE} {STANDARD/OMITTED} [DATA {RECORD IS/RECORDS ARE} 数据名]<br>2．记录描述<br>记录描述体由01层号开头，后跟记录名。<br>如果记录下面不再分项，即记录本身就是一个初等项，则这种描述体最简单。<br>三．字型子句（PIC子句）<br>1．数值型数据的描述<br>（1）“9”描述符：表示在该位置上可以放入一个0-9之间的数字<br>举例：02 X PIC 9999.<br>02 Y PIC 9(5).<br>（2）“V”描述符：支持在数值型数据结构中隐含的小数点位置<br>举例：03 M PIC 999V999.<br>（3）“P”描述符：对低位上有若干个零的数，可以用该描述符。<br>举例：01 A PIC 9P(9). 表示10的9次方<br>01 B PIC PPPP99. 表示0.000023<br>（4）“S”描述符：如果想在数据项中放入一个带符号的数，可以用该描述符。对于类似PIC S99的数据项，系统在内存中该数据项的最后一个字节中，放入一个标记，表示此数为负。<br>二．字母型数据的描述<br>“A”描述符：这种类型的数据项中只能放字母或空格<br>三．字符型数据的描述<br>（1）字符型数据的规定<br>概念：由任意的COBOL字符组成的数据，称字符型数据。<br>说明：I.字符型数据可以用X描述符来描述，也可以用9和A描述符来描述。<br>II.字母型数据可以用A来描述，也可以用X。<br>III.字符型数据中可以放数字。<br>四．编辑型描述符<br>1．插入小数点“.”，用“.”描述符。<br>2．插入逗号“，”作分位号，用“，”描述符。<br>3．插入零，用“0”描述符。<br>4．插入空格，用“B”描述符。<br>5．插入正负号，用“+”或“-”描述符。<br>6．插入“$”<br>（1）加到数字前。<br>（2）在数字前加正负号和$。<br>7．浮动插入正负号和“$”<br>8．取消高位零，用“Z”和“×”描述符。<br>9．插入“DB“和“CR”字符：此两个描述符只能用作固定插入，而且只作最后一个描述符号。当数值为正时，此两次留两个空格；为负时，在编辑型数据项中最后两个字节中置DB或CR。五．PIC子句小结<br>1．格式：PICTURE/PIC IS 描述字符串<br>2．每一种类型数据可以使用的描述字符如下：\r\n<p>数据类型 在PIC子句中允许使用的描述字符<br>数值数据项 9 V S P<br>字母数据项 A<br>字符数据项 9 A X<br>编辑数值数据项 9 P V . , B Z + - $ × 0 CR DB<br>编辑字符数据项 A X 9 B 0<br>3．描述字符的含义\r\n<p>描述字符 含义<br>9 表示一个数字的位置<br>A 表示一个字母的位置<br>X 表示一个字符的位置<br>V 表示隐含小数点的位置<br>S 表示数值数据带符号<br>P 表示十进制比例换算，即指明落在数据域外的十进制小数点位置<br>$ 插入货币号位置<br>. 插入小数点位置<br>, 插入逗号的位置\r\n<ul>\r\n<li>一律加符号</li></ul>\r\n<ul>\r\n<li>对负数加负号，对正数前留一空格<br>Z 取消高位零，以代空格<br>× 取消高位零，代以×<br>B 插入空格的位置<br>0 插入零的位置<br>DB（借方） 数据为负时，在数据后面出现DB，数据为正时，数据后空两格<br>CR（贷方） 数据为负时，在数据后面出现CR，数据为正时，数据后空两格<br>四．工作单元节（WORKING-STORAGE SECTION）<br>1．工作单元节的作用<br>程序中用的数据项分两部分：一部分是属于输入或输出文件的，另一部分是非输入或输出的数据。<br>在工作单元节中描述的数据项也有两种形式：一种是孤立的数据项，它们是初等项。<br>一种是组合项。COBOL规定，孤立的数据项的描述体以层号77开头，组合项描述体以01到49之间的一个数作层号。在次序上常先写77层，再写01-49层。<br>2．赋初值子句（VALUE子句）<br>举例：77 A PIC 99 VALUE IS 0.<br>77 T PIC X(9) VALUE ‘fogshadow’.<br>说明：只有对工作单元节中的数据项可以赋初值。<br>过程部之二<br>一．传送语句（MOVE语句）的较高技巧<br>1．各种类型数据间的传送<br>（1）同类型数据间的传送<br>（2）编辑传送。<br>注意：传送的方向必须是由数值型数据传送给编辑型数据，而不能由编辑型数据传送给数值型数据。<br>（3）不同类型数据间的传送规则。<br>说明：Y为允许传送，N为不允许，Z为在某些情况下是正确的</ul>\r\n<p>横接收项<br>竖发送项 数值型 数值编辑型 字母型 字符型 字符编辑型 组合项<br>整数 非整数<br>数值型 整数 Y Y Y Y Y Y Y<br>非整数 Y Y Y N N N Y<br>数值编辑型 N N N N Y Y Y<br>字母型 N N N Y Y Y Y<br>字符型 Z Z Z Z Y Y Y<br>编辑字符型 N N N N Y Y Y<br>数值常量 Y Y Y N N N Y<br>非数值常量 N N N Y Y Y Y<br>ZERO Y Y Y N Y Y Y<br>SPACE N N N Y Y Y Y<br>组合项 Z Z Z Z Y Y Y<br>2．组合项的传送<br>（1）发送项和接收项都是组合项，而且其结构和描述均相同，则可看作将各初等项一一对应传送。<br>（2）如发送项与接收项长度相同，但数据结构形式不同，则将发送项的内容原样不变地自左而右顺序地传送到接收项。<br>3．对应传送（带CORRESPONDING子句的MOVE语句）<br>（1）数据名的受限与受限名的传送<br>数据名和限定符之间用OF或IN 来连接。<br>举例：MOVe A1 OF A OF SUM TO T1.<br>（2）用CORRESPONDING子句的传送——对应传送（同名传送）<br>作用：把一个组合项中若干项传送给另一组合项中同名的项。<br>格式：MOVE CORRESPONDING/CORR 标识符1 TO 标识符2<br>二．算术运算语句的较高技巧<br>1．四舍五入处理（ROUNDED子句）<br>作用：按照数据项的描述要求对多余位截断，然后对被截断的后一位数进行四舍五入处理。<br>举例：ADD A，B TO C ROUNDED\r\n<p>A+B+C值 C描述 有无ROUNDED C内容<br>186.7851 999 有 187<br>186.7851 999V9 有 186.8<br>186.7851 999V99 有 186.79<br>186.7851 999V999 有 186.785<br>如果计算结果有多个，则应该分别说明哪一个接收项要进行舍入处理，ROUNDED应写在有关的接收项（结果数据项）的数据名后面，如<br>ADD A,B,C TO D,E,F ROUNDED,G ROUNDED,H<br>2．长度溢出处理<br>当计算结果的整数部分的长度如果比结果数据项描述所规定的整数部分长，则发生长度溢出，结果的高位部分被截断。<br>ON SIZE ERROR子句提供“溢出”处理。即当发生溢出错误的时候，按程序设计者事先指定的操作处理。<br>举例：MULTIPLY A BY B GIVING C<br>ON SIZE ERROR DISPLAY‘SIZE ERROR‘ STOP RUN.<br>3．对应项间的运算（带CORRESPONDING子句的算术运算语句）<br>格式：ADD CORRESPONDING/CORR 标识符1 TO 标识符2 [ROUNDED]<br>[;ON SIZE ERROR 强制语句]<br>SUBTRACT CORRESPONDING/CORR 标识符1 TO 标识符2 [ROUNDED]<br>[;ON SIZE ERROR 强制语句]<br>4．除法语句中的余数子句（REMAINDER子句）<br>举例：DIVIDE 1.5 INTO 7 GIVING C REMAINDER D.<br>三．IF语句的高级技巧<br>1．IF语句的嵌套<br>举例：（注意IF与ELSE的一一配对）<br>IF A=B<br>MOVE B TO T<br>IF A=C<br>MOVE C TO R<br>IF X\r\n<p>SUBTRACT X FROM Y<br>IF N=M<br>IF P=Q<br>DISPLAY P,Q<br>ELSE NEXT SENTENCE<br>ELSE NEXT SENTENCE<br>ELSE NEXT SENTENCE<br>ELSE NEXT SENTENCE<br>ELSE NEXT SENTENCE<br>2．关系表达式条件<br>以下为关系条件的比较方式，其中，Y表示作为数值型比较，N表示作为非数值型（即字符型比较），Z表示不能比较。\r\n<p>横-客体<br>竖-主体 数值型 数值常量 非数值常量 字母型 字符型 组合项<br>数值型 Y Y N N N N<br>数值常量 Y Z Z N N N<br>非数值常量 N Z Z N N<br>字母型 N N N N N N<br>字符型 N N N N N N<br>组合项 N N N N N N<br>3．符号条件<br>格式：数据名/数值表达式 IS [NOT] POSITIVE/NEGATIVE/ZERO<br>举例：（1）IF X IS POSITIVE 与 IF X&gt;0 等价<br>（2）IF X IS NEGATIVE 与 IF X<0 等价\r\n（3）IF X IS ZERO 与 IF X=0 等价\r\n4．类型条件\r\n格式：标识符 IS [NOT] NUMERIC/ALPHABETIC\r\n其中，NUMERIC表示数值类型，ALPHABETIC表示字母类型。\r\n5．条件名条件\r\n作用：用来代替一系列繁杂的IF-ELSE语句。\r\n格式：88 条件名 VALUE IS/ARE 常量1[THROUGH/THRU 常量2]\r\n[常量3[[THROUGH/THRU 常量4]]……\r\n举例：首先在数据部说明\r\n77 X (条件变量) PIC 9(6).\r\n88 X1 VALUE 0 THRU 99.\r\n88 X2 VALUE 100 THRU 999.\r\n88 X3 VALUE 1000 THRU 4999.\r\n88 X4 VALUE 5000 THRU 100000.\r\n经过上面的说明后，可以在过程部中直接使用条件名条件。\r\nIF X1 MOVE 0.03 TO R. (在0<=X<100时，R=0.03)\r\nIF X2 MOVE 0.04 TO R. (在100<=X<1000时，R=0.04)\r\nIF X3 MOVE 0.05 TO R. (在1000<=X<5000时，R=0.05)\r\nIF X4 MOVE 0.06 TO R. (在5000<=X<=100000时，R=0.06)\r\n6．复合条件\r\n逻辑运算符有：AND、OR、NOT\r\n运算次序是：NOTaANDaOR\r\n五．字符串连接语句（STRING语句）\r\n六．字符串分解语句（UNSTRING语句）\r\n七．检测语句（INSPECT语句）\r\n八．转换语句（TRANSFORM语句）\r\n过程部之三\r\n—执行语句（PERFORM语句）\r\n一．执行语句的作用 类似于子程序\r\n二．执行语句的最基本形式\r\n格式：PERFORM 过程名1[THROUGH/THRU 过程名2]\r\n三．执行语句的使用规则\r\n1．PERFORM语句的嵌套\r\n2．在PERFORM语句所执行的语句序列中，可以含有转移语句，可以使流程转到语句序列之外，但一般应该转回到此语句序列，以便能最后能执行此语句序列的最后一个句子。\r\n四．使用PERFORM语句实现循环\r\n格式：PERFORM 过程名1[THROUGH/THRU 过程名2] 整数/标识符 TIMES\r\n说明：1.标识符应为整数数据项\r\n2如果此标识符的值在执行语句序列中有变化，不会影响执行次数。即以它开始时候的值来决定执行的次数。\r\n五．执行语句的较复杂的形式\r\n1．格式：PERFORM 过程名1[THROUGH /THRU 过程名2 ] UNTIL 条件\r\n作用：反复执行指定的语句序列，直到给定的条件满足为止。\r\n2．格式：\r\nPERFORM 过程1[THROUGH/THRU 过程名2]\r\nVARYING 标识符1 FROM 常数1/标识符2 BY 常数2/标识符3 UNTIL 条件\r\n举例：PERFORM T1 THRU T2 VARYING X FROM A\r\nBY B UNTIL X>5<br>其作用是执行T1到T2语句序列，X是“循环变量”，是整型数据项。A为初值，B为步长，它们都是整数或整数数据项。<br>六．执行语句的多重循环形式<br>格式：PERFORM 过程名1 [THROUGH/THRU] 过程名2<br>[VARYING 参数1 FROM 初值1 BY 步长1 UNTIL 条件1]<br>[AFTER 参数2 FROM 初值2 BY 步长2 UNTIL 条件2]<br>[AFTER 参数3 FROM 初值3 BY 步长3 UNTIL 条件3]<br>说明：1。最后面的循环体先执行。<br>2．COBOL允许用到三重循环。<br>七．出口语句（EXIT语句）<br>作用：提供一个段名，被PERFORM调用的语句序列由此公共汇集点，返回到PERFORM的下一个语句去。<br>举例：PERFORM A THRU B<br>……<br>A. IF X&gt;Y GO TO B<br>MOVE X TO T.<br>B.            EXIT.<br>八．修改语句（ALTER语句）<br>格式：ALTER 过程名1 TO [PROCEED TO] 过程名2<br>[，过程名3 TO [PROCEED TO] 过程名4]……<br>作用：用来改变GO TO的转向点。该语句使以过程名1，过程名3，……命名的各段中的GO TO语句的转向点分别被修改为过程名2，过程名4……。注意，过程名1，过程名3……各段只能由一条GO TO语句单独组成。<br>数据部之二<br>-数据部的较高技巧<br>一．数据在计算机内的表示形式<br>1．字符数据在内存中的存储形式<br>（1）ACSII<br>（2）EBCDIC<br>2．数值型数据在内存中的存储形式<br>（1）外部十进制（或称扩张十进制）形式<br>（2）外部浮点数形式<br>（3）内部十进制（又称缩合十进制）形式<br>（4）定点二进制形式<br>（5）内部浮点形式<br>二．用法子句（USAGE子句）<br>作用：可以使程序设计者自由选择数据在内存中的存放形式。<br>格式：[USAGE IS] DISPLAY/COMPUTATIONAL/COMP<br>说明：1。DISPLAY表示是“显示型的用法”，表示此数据项适于显示，打印。<br>2．COMPUTATIONAL=COMP，表示是“计算型的用法”，适于计算。<br>3．如省略USAGE子句，则隐含表示为用DISPLAY形式。<br>三．符号子句（SIGN子句）<br>作用：用来指定数值型数据描述体中运算符号的状态和位置。<br>格式：[SIGN IS] LEADING/TRAILING [SEPARATE CHARACTER]<br>说明：1。没有SIGN子句时，数值的符号是存放在数据项最后一个字节中的。<br>2．用SIGN子句可以指定符号在数值的前部还是后部（LEADING/TRAILING）。<br>3．指定符号单独占一个字节，用“SEPARATE”可选项，内存中增加一个字节。<br>4．SIGN子句只能用于PIC字符串中含有“S”的数值型数据描述体中。<br>5．使用SIGN子句的数据项的用法应该是USAGE DISPLAY（显式的或隐含的）。<br>举例：02 A PIC S9(3) USAGE DISPLAY SIGN IS LEADING.<br>四．重定义子句（REDEFINES子句）<br>作用：不同的数据项可以共用内存中的同一段空间。例如已给数据项A分配了一段内存空间，在经过某一段的过程后，A已经不再使用了，但它仍占着内存这部分空间，为了节约内存，可以将另一数据项B也分配在A所占的这段内存空间。<br>格式：层号 数据名1 REDEFINES 数据名2<br>举例：02 A PIC X(5).<br>02 B REDEFINES A PIC 9(5).<br>说明：<br>1。数据名2 与数据名1的层号必须相同。<br>2．用REDEFINES子句的描述体应该紧跟在被重新定义的数据项的描述之后，中间不能插入其它项的描述说明。<br>3．可以多次重定义，但必须紧跟出现，而且要求使用最初定义的数据名。<br>4．REDEFINES子句不能用于文件节的01层中。<br>5．用REDEFINES子句可以改变数据结构，但数据名1、2的长度应该相等。<br>6．REDEFINES子句应在其它子句之前。<br>7．重定义子句所在的数据描述体中不能使用初值子句赋初值。.<br>五．重命名子句（RENAMES子句）<br>作用：在不改变数据项的长度的前提下，重新定义数据区的名称和数据结构的形式（包括初等项的类型和长度）。可以把原来已经定义的某些数据项重新组合成一个新项，并以一个新名字来代表它。但用重命名子句不能改变原来各初等项的类型、长度等属性。<br>格式：66 数据名1 RENAMES 数据名2 [THRU 数据名3]<br>说明：只能用于工作单元节中，不能用于文件节中<br>六．遇零置空子句（BLANK子句）<br>作用：当数据项的值为零时，使它的内容改变为空白（空格）。这个子句只能用于数值型或编辑型的初等项。<br>举例：03 A PIC 9999 BLANK WHEN ZERO.<br>七．对齐子句（JUSTIFIED子句）<br>作用：字符或字母型数据传送的时候是按标准的对齐方式，即“左对齐”，若想改为“右对齐”，可以用JUSTIFIED子句。<br>格式：JUSTIFIED/JUST RIGHT<br>举例：77 B PIC X（5） JUSTIFIED RIGHT<br>八．同步安置子句（SYNCHRONIZED子句）<br>作用：一个机器字一般定为4个字节，从内存中取数据的时候是以机器字为单位的，而数据存放则是按字节连续存放的，这里面就存在一个边界对齐的矛盾，会影响目标程序运行时间。用同步安置子句可以指定数据项在内存中如何按自然边界来安置。<br>格式：SYNCHRONIZED/SYNC LEFT/RIGHT<br>说明：1。用SYNC LEFT时，左对齐，右边补零或空格。<br>2．用SYNC RIGHT时，右对齐，左边补零或空格。<br>举例：01 A.<br>02        A1 PIC 9(3) SYNC LEFT VALUE 82.<br>03        A2 PIC X(3) SYNC RIGHT VALUE ‘ABC’<br>九．复写语句（COPY语句）<br>作用：把“源程序库”中的某些记录描述和数据描述插入到自己的源程序中。<br>格式：COPY 库名 [REPLACING 标识符1/常量1/字1 BY 标识符2/常量2/字2]<br>子程序<br>一．概述<br>举例：编一个打印一行“×”符号的子程序<br>1． 主程序（只写与调用子程序有关的部分）<br>IDENTIFICATION DIVISION. （标识部）<br>PROGRAM-ID. A. （程序名为A）<br>ENVIRONMENT DIVISION. （环境部）<br>……<br>DATA DIVISION. （数据部）<br>……<br>PROCEDURE DIVISION. （过程部）<br>……<br>CALL B. （调用子程序B）<br>……<br>2． 子程序<br>IDENTIFICATION DIVISION.<br>PROGRAM-ID. B.<br>ENVIRONMENT DIVISION.<br>DATA DIVISION.<br>WORKING-STORAGE SECTION.<br>77        X PIC X(80).<br>PROCEDURE DIVISION.<br>MOVE ALL’×’ TO X.<br>DISPLAY X.<br>EXIT PROGRAM.<br>可以看到程序A和程序B分别是两个程序，各有自己的程序名，都有四大部分。<br>二．调用程序与被调用程序间的数据联系<br>格式：调用语句<br>CALL 子程序名 USING 数据名1 [，数据名2]……]<br>被调用程序中过程部部头的一般格式为<br>PROCEDURE DIVISION [USING 数据名1[，数据名2]……]<br>说明：1。两部分相对应的参数个数、长度必须相等。<br>2．参数是在内存中建立关联，类似于C++中的传递引用参数。<br>三．子程序的结构<br>1．标识部<br>说明子程序的名字，以供调用。<br>2．环境部<br>3．数据部<br>（1）文件节（FILE SECTION）<br>（2）工作单元节（WORKING-STORAGE SECTION）<br>（3）联接节（LINKAGE SECTION）：如果子程序过程部部头的USING子句中有数据名，则此数据名应在此节中加以说明。<br>4．过程部<br>过程部的部头：PROCEDURE DIVISION USING 数据名1，数据名2，……<br>过程部中应该包括一个程序出口语句：EXIT PROGRAM.<br>表的建立与查找<br>一．表的概念<br>COBOL语言中的表（TABLE）类似于其他高级语言中的数组（ARRAY）。<br>表中，序号称为下标，相对地址称为位标，下标和位标称为“出现号”。<br>二．表的建立（OCCURS子句）<br>格式：OCCURS 整数 TIMES<br>举例：01 PRODUCT-RECORD.<br>03        RODUCT OCCURS 20 TIMES.<br>04 QUANTITY-OF-PRODUCTION PIC 9(6).<br>04 QANTITY-OF-SALES PIC 9(6).<br>04 QANTITY-OF-HAND PIC 9(6).<br>说明：1。OCCURS子句不能出现在77层，因为77层是独立的数据项。<br>2．OCCURS子句不能用于01层。<br>3．只有当OCCURS所说明的数据是初等项时，才能在该数据项的描述中使用PIC子句。<br>4．不能用VALUE子句对表赋初值，不能同时用OCCURS子句和VALUE子句来描述同一数据项。<br>三．可变长表<br>格式：OCCURS 整数1 TO 整数2 TIMES DEPENDING ON 数据名1<br>说明：根据数据名1的值来确定数据项重复的次数。<br>四．表元素的引用<br>格式：表名（下标）<br>说明：1。如果B是一个表，不直接引用表名B而不加下标。<br>2．如果表元素是组合项，则引用它下属的项（可以是初等项或组合项），也必须用下标指明它是属于哪一个表元素的。<br>3．如果表元素是组合项，可以用它对下属的数据项进行限定。<br>4．下标只能是整常数或具有整型值的数据名。<br>5．下标不能是带下标的数据名，即不能是表元素。<br>五．给表元素赋初值<br>1．对包括所有表元素的整个表赋给一个初值，这时可以对表的描述体上面一层的数据项赋一个初值即可。<br>例1：01 TABLE VALUE IS ZERO.<br>03        OCCURS 20 PIC 9(3).<br>例2：01 T VALUE ‘ABCDEFHIJ’.<br>02        Q OCCURS 3 PIC X(3).<br>这样，Q（1），Q（2），Q（3）的内容分别是ABC，DEF，HIJ。<br>2．联合使用OCCURS子句和REDEFINES子句来给各个表元素赋值。<br>（1）先在工作单元节中定义一个组合项，它占的内存的大小和需赋值的表一样，在该组合项中定义若干个数据项，数据项的描述和表的元素相同。<br>（2）然后对这些数据项分别用VALUE子句赋以初值，由于在这些数据项的描述中没有出现OCCURS子句，因此用VALUE赋初值是合法的（VALUE子句和OCCURS子句不能同时用来描述一个数据项）。这些值就是要赋给表元素的初值。<br>（3）把这个组合项重定义为一个表。<br>六．用位标法(cursor)引用表元素<br>1．位标的概念：位标的值表示表元素在该表中的相对位置（以字节数表示）。<br>2． 位标名的指定方法：在数据部中定义一个表时所用的OCCURS子句中要加上“INDEXED BY 位标名”短语来指定。<br>说明：（1）由于位标是专门用于引用表元素的特殊数据项，它不能用来进行算术运算。<br>（2）一维表或多维表的每一维按需要可以指定若干个位标名，引用时这些位标名只能在该维内使用。<br>（3）有时需要把位标的值转存到另一个数据项中，但由于位标是特殊类型的数据项，因此，需要另外定义一种特殊的数据项叫位标数据项，用来专门存储位标的值。位标数据项在数据部中定义。描述位标数据项用USAGE子句。例如：77 K USAGE IS INDEX.<br>七．SET（设置）语句<br>1．作用：将一表元素的相对地址放到指定的位标去。<br>如： SET I TO 10.<br>表示将位标I置位到第10个元素的第一个字节的相对地址上去。<br>2．格式一<br>SET 标识符1[，标识符2]…… TO 标识符3/位标3/整数<br>位标1[，位标2]……<br>规则列表（设SET A TO B）\r\n<p>横-发送项B<br>竖-接收项A 整数 数值初等项 位标名 位标数据项<br>数值初等项 不合法 不合法 将位标代表的序号传送 不合法<br>位标名 将整数（序号）化成相对地址传送 同左（1）如果两个位标名指向同一个表，则转换成另一表的相对地址再传送，即将发送项代表的表元素顺序号减1，乘以接收项相关表元素的长度，再传送简单传送<br>位标数据项 不合法 不合法 简单传送 简单传送<br>3． 格式二<br>SET 位标1 [，位标2]…… UP/DOWN BY 标识符/整数<br>作用：给位标增减一个量。<br>八．表的检索<br>1．用于顺序检索的SEARCH语句<br>格式：SEARCH 表名[VARYING 位标名1/标识符2][AT END 强制语句1]<br>WHEN 条件1 强制语句2/NEXT SENTENCE<br>[WHEN 条件2 强制语句3/NEXT SENTENCE]……<br>举例：SET N TO 1.<br>SEARCH WORKER-TABLE<br>AT END DISPLAY‘CANNOT FIND NAME’<br>WHEN NAME（N）=‘ZHANG SHENG’<br>DISPLAY NAME（N），PAY（N）.<br>……<br>SEARCH语句是这样执行的：从指定的表元素开始，检查是否满足WHEN后面指定的条件。如不满足，就使N增值，自动执行一个SET N UP BY 1。使N指向下一个元素的地址，如果查到某一个元素满足指定的条件时，查表工作立即停止，执行WHEN字句中条件后面的语句。<br>2．用于有序表的SEARCH语句（折半法检索）<br>（1）说明升（降）序的一般格式为：<br>ASCENDING/DESCENDING KEY IS 数据名1[，数据名2]……<br>ASCENDING/DESCENDING KEY IS 数据名3[，数据名4……]……<br>举例：02 BOOK-TABLE OCCURS 100<br>ASCENDING KEY IS NAME<br>DESCENDING KEY IS COD<br>INDEX BY N.<br>（2）SEARCH语句的一般格式（之二）<br>SEARCH ALL 表名[；AT END 强制语句1]<br>WHEN 条件 强制语句2/NEXT SENTENCE<br>举例：SEARCH ALL BOOK-TABLE<br>AT END DISPLAY’CANNOT FIND NAME’<br>WHEN NAME(N) = ‘COMPUTER DESIGN’<br>DISPLAY NAME (N),NUM (N).<br>九．用PERFORM语句对表进行检索<br>最多可以处理三重循环<br>PERFORM 过程名1[THRU 过程名2]<br>VARYING 位标名1/下标名1 FROM 位标名2/常量1/标识符1 BY 常量2/标识符2 UNTIL 条件1<br>AFTER 位标名3/下标名2 FROM 位标名4/常量3/标识符3 BY 常量4/标识符4 UNTIL 条件2<br>AFTER 位标名5/下标名4 FROM 位标名6/常量5/标识符5 BY 常量6/标识符6 UNTIL 条件3\r\n', null, null, null, '2020-10-18 21:05:32', '2020-10-18 21:05:32', '1');
INSERT INTO `articles` VALUES ('49', '1', 'COBOL基本语法', '', 'REDEFINES\r\n     可以用不同的变量描述同一内存。\r\n     01 PART_RECODE USAGE DISPLAY\r\n        03 PART-TYPE PICTURE...\r\n        03 PART_TYPE_A.\r\n           05 PART_NUMBER PICTURE...\r\n           05 PART_COST PICTURE...\r\n        03 PART_TYPE_B REDEFINES PART_TYPE_A.\r\n           05 UPC_CODE PICTURE...\r\n        03 PART_TYPE_C REDEFINES PART_TYPE_A.\r\n           05 ISBN PICTURE...\r\n     根据PART_TYPE决定用PART_TYPE_A还是PART_TYPE_B还是PART_TYPE_C。\r\n     规则：\r\n         PART_TYPE_B和PART_TYPE_C长度不能大于PART_TYPE_A。\r\n         数据项不能有VALUE。\r\n         01层不能用REDEFINES.\r\n         PART_TYPE_B和PART_TYPE_C中不能有OCCURS.\r\n\r\nPICTURE\r\n     定义基本项目的具体长度，格式，数据类型。可以简写成PIC.\r\n     格式字符串最多30个字符，可以包含下列字符：\r\n     A   字母A-Z,a-z,空格\r\n     B   插入空格\r\n     P   标量字符，代表字段中不显示的小数点位置\r\n     S   代数符号，实际显示取决于项目的USAGE\r\n     V   小数点位置\r\n     X   任何字符\r\n     Z   抑制前头的0并转换成空字符\r\n     0   插入0\r\n     9   数字0~9\r\n     /   插入/\r\n     ,   插入,(逗号不能作为字符串的最后一位，最后时逗号是分隔符)\r\n     .   插入.\r\n     ×   抑制前头的0并转换成×\r\n   +   正值插入+，负值插入-\r\n     -   正值插入空格，负值插入-\r\n     $   插入美元号\r\n     CR 正值插入两个空格，负值插入CR\r\n     DB 正值插入两个空格，负值插入DB\r\n例子：\r\n     03 VAR PIC AAAAA.     VAR变量长度为5个字符，不能有数字，等价于03 STATE PIC A(5)。\r\n     输入ASDFG ,显示ASDFG\r\n     03 VAR PIC XXXXX.    VAR变量长度为5个任意字符。等价于03 FILLER PIC X(5)。\r\n     输入123AS ， 显示123AS\r\n     03 VAR PIC 99/XXX/9999 长度11，输入05may2004,显示05/may/2004\r\n     03 VAR PIC 0ABXXX/9999 长度11，输入05may2004,显示05 may/2004\r\n     03 VAR PIC 9(3) 长度3，0~999之间。\r\n     03 VAR PIC 9(4)V99 长度6，0.00~9999.99之间。\r\n     03 VAR PIC S9(5)V99 长度7，-99999.99~99999.99之间。\r\n     03 VAR PIC 9(6)PPP 长度6，可以是1000，2000，...,999999000。输入1234，显示1000。\r\n     03 VAR PIC PPP999 长度3，0.000001~0.000999之间。输入123，显示0.000123。\r\n     03 VAR PIC ZZZ.99，输入100.50,显示100.50;输入-51.50,显示51.50;\r\n     输入0,显示.00.\r\n     03 VAR PIC $ZZZ.ZZ-，输入100.50,显示$100.50;输入-51.50,显示$51.50-;\r\n     输入0,显示\r\n     03 VAR PIC $×××,×××.99CR，输入1000,显示$××1000.00;输入-1000,显示$××1000.00CR;\r\n     输入0,显示$×××,×××.00;输入51.5,显示$×××,×51.50\r\n     03 VAR PIC\r\n$,\r\n$.99，输入100.50,显示$100.50;输入-100.50,显示$100.50;\r\n     输入0.777,显示$.77;输入0,显示$.00\r\n     03 VAR PIC $.$$$，输入1.00,显示$.00;输入0.65,显示$.65;\r\n     输入0,显示$.00;\r\n     03 VAR PIC $--，输入17.7,显示$17;输入-17.7,显示$-17;\r\n             输入-5,显示$-5\r\n     03 VAR PIC $999.99+，输入100.50,显示$100.50+;输入-100.50,显示$100.50-;\r\n     03 VAR PIC 9(3)B9(3)，输入55,显示000 055;输入1000.78,显示001 000;\r\n     03 FILLER PIC X(44)，补上44个空位。\r\n\r\n\r\nUSAGE 表示基本或组数据的类型。有BINARY,COMPUTATIONAL(COMP),DISPLAY,INDEX,PACKED-DECIMAL.\r\n\r\nJUSTIFIED\r\n     03 VAR1 PIC X(5) JUSTIFIED RIGHT.\r\n     03 VAR2 PIC X(5).\r\n     输入XYZ，VAR1显示的是\"   XYZ\"，VAR2显示的是\"XYZ   \"。\r\n\r\nBLANK WHEN ZERO\r\n     03 VAR PIC $999,999.99 BLANK WHEN ZERO.\r\n     当字段值为0，这个项目设置为全部空格。\r\n\r\nVALUE\r\n     定义的时候就赋值。\r\n     03 VAR PIC X(5) VALUE \"ABCDE\".\r\n     01 VAR VALUE ALL SPACES.\r\n     03 VAR1 PIC XXX.\r\n     03 VAR2 PIC XX.\r\n\r\n算术语句\r\n    COBOL中操作符执行顺序为：取正(+)、取负(-)最高级，指数操作(××)其次，乘(×)、除(/)再其次，加(+)、减(-)最后。\r\n    ROUNDED   舍入操作。\r\n     77 A PIC 9V9 VALUE 9.1.\r\n     77 B PIC 9.\r\n       ADD 0.5 TO A GIVING B ON SIZE ERROR GO TO PROC1.\r\n       ADD 0.5 TO A GIVING B ROUNDED ON SIZE ERROR GO TO PROC2.\r\n       END-ADD.\r\nON SIZE ERROR 是当语句出现错误时执行的。本例中第一句话执行没有错误，所以ON SIZE ERROR\r\n不执行PROC1.第二句话，当0.5加上9.1得到9.6，因为有ROUNDED,所以执行舍入操作，得到10。而B只有1位数字，所以发生错误，执行ON SIZE ERROR操作，跳转执行PROC2。 \r\nCORRESPONDING(CORR)     数据项同名时编写多条语句。ADD和SUBSTRACT有此选项。\r\n     01 A.\r\n        03 B.\r\n           05 B1 PIC 999V99.\r\n           05 B1 PIC 999V99.\r\n           05 B1 PIC 999V99.\r\n        03 C.\r\n           05 B1 PIC 999V99.\r\n           05 B1 PIC 999V99.\r\n           05 B1 PIC 999V99.\r\n则语句ADD CORR B TO C.相当于执行了下面3条语句。\r\n     ADD B1 OF B TO B1 OF C.\r\n     ADD B2 OF B TO B2 OF C.\r\n     ADD B3 OF B TO B3 OF C.\r\n组项目不一定要格式相同。一个组项目中的内容在另一个组项目中可以没有，数据项顺序也无关紧要。只是严格按照数据项名称对应。\r\n     ADD A,B GIVING C. END-ADD.               将A,B相加放入C。\r\n     SUBTRACT A,B FROM C. END-SUBTRACT.       从C中减去A,B.\r\n     MULTIPLY A BY B GIVING C. END-MULTIPLY. 将A,B相乘放入C。\r\n     DIVIDE A INTO B GIVING C. END-DIVIDE.    将B除于A的结果放入C.\r\n     DIVIDE A BY B GIVING C. END-DIVIDE.      将A除于B的结果放入C.\r\n     DIVIDE A BY B GIVING C REMAINDER D.      将A除于B的商放入C，余数放入D.\r\n     D=A-B×C.\r\n     77 C PIC S99V9.\r\n     77 D PIC S99V9.\r\n     DIVIDE 3 INTO 7 GIVING C REMAINDER D.\r\n     C的值为2.3，D为0.1。(D=7-3×2.3)\r\n\r\nCOMPUTE\r\n     除了取余操作要用DIVIDE外，其他操作都可以用此语句。本语句求值一个算术表达式，并将结果存放在一个或几个变量中。\r\n     COMPUTE   A ROUNDED,B = X×Y/(N+M)+Z.   将X×Y/(N+M)+Z的结果存放在B中，然后舍入后放入A中。\r\n\r\nMOVE\r\n     MOVE A TO B.\r\n     也可以用CORR选项。\r\n     MOVE CORR A TO B.\r\n\r\nACCEPT\r\n     从键盘或其他输入设备读取数据。\r\n     ACCEPT A FROM DEV.     从DEV读取数据到A，也可以省略FROM DEV，表示从键盘读取。\r\n     ACCEPT A FROM DATE/DAY/DAY-OF-WEEK/TIME.读取日期，表示为6个字符，如990909（1999年9月9日）。\r\n     读取当前日期在年度（前2位）中为第几天（后3位），表示为6个字符，如1994年4月1日表示为94091。\r\n     读取当前星期几，表示为1位字符。1表示星期一，7表示星期日。\r\n     读取当前时间，表示为8位字符。精确到毫秒。如下午2：41表示为14410000。\r\n\r\nDISPLAY\r\n     将数据写入输出设备。如监视器（monite），系统输出流和操作员控制台（console）。\r\n     DISPLAY AAAAA BBBBB [UPON DEV] [WITH NO ADVANCING]\r\n     如果使用UPON选项，dev要与special-names段中的硬件名相关联。\r\n     如果使用no advancing选项，则输出最后一个字符后输出设备仍然保持原位，使下一条display语句还在该位置显示。否则可能到下一行显示。\r\n\r\nINITIALIZE\r\n     初始化数据，数字和数字编辑数据项初始化为0，其他初始化为空格。\r\n\r\nINSPECT TALLYING\r\n     计算项目中该字符串出现的次数。\r\n     INSPECT AA TALLYING BB FOR ALL “EE”.   从AA中查找有多少个EE，将个数写入BB。\r\n     INSPECT AA TALLYING BB FOR CHARACTERS BEFORE “E”.   从AA中查找E前面有多少个字符，将个数写入BB。\r\n     INSPECT AA TALLYING BB FOR CHARACTERS AFTER “C” BEFORE “E”.   从AA中查找C后面E前面有多少个字符，将个数写入BB。\r\n     INSPECT AA TALLYING BB FOR LEADING “E”.   从AA中第一个字符开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。\r\n     INSPECT AA TALLYING BB FOR LEADING “E” AFTER “C”.   从AA中C后面开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。\r\n组合例子：\r\n     77 CS PIC X(9) VALUE \"REELWHEEL\".\r\n     77 COUNT-0.\r\n     77 COUNT-1.\r\n     77 COUNT-2.\r\n     MOVE 0 TO COUNT-0,COUNT-1,COUNT-2.\r\n     INSPECT CS TALLYING\r\n         COUNT-0 FOR ALL \"E\",\r\n         COUNT-1 FOR LEADING \"W\" AFTER \"L\",\r\n         COUNT-2 FOR CHARACTERS.\r\n     程序首先判断的是字符\"R\",执行COUNT-0 FOR ALL \"E\"，因为第一个字符不是\"E\"，所以程序转而执行COUNT-1 FOR LEADING \"W\" AFTER \"L\"，也不符合要求，\r\n     于是程序执行COUNT-2 FOR CHARACTERS，COUNT-2 =1。然后字符串往下一位，判断\"E\",执行COUNT-0 FOR ALL \"E\"，符合要求，则COUNT-0=1。\r\n     有了满足条件的判断，则余下的判断不再执行，字符串再往下一位，判断\"E\"，则COUNT-0=2。接着判断\"L\",则COUNT-2 =2。以此类推，最后结果为COUNT-0=4，\r\n     COUNT-1=1，COUNT-2=4。\r\n\r\n\r\nINSPECT REPLACING\r\n     用另一个字符串替换这个字符串。\r\n     还用上面的例子。\r\n     INSPECT CS REPLACING ALL \"E\" BY \"Y\".   结果\"RYYLWHYYL\"\r\n     INSPECT CS REPLACING CHARACTERS BY \"Z\" AFTER   \"L\".   结果\"REELZZZZZ\"\r\n     INSPECT CS REPLACING LEADING \"E\" BY \"Y\".   结果不变\r\n     INSPECT CS REPLACING LEADING \"E\" BY \"Z\" AFTER   \"H\".   结果\"REELWHZZL\"\r\n     INSPECT CS REPLACING FIRST \"E\" BY \"I\".   结果\"RIELWHEEL\"\r\n     INSPECT CS REPLACING FIRST \"EE\" BY \"00\",ALL \"WH\" BY \"TH\",CHARACTERS BY SPACE.   结果\" 00 TH    \"\r\n\r\n\r\nINSPECT CONVERTING\r\n     就是INSPECT REPLACING的缩写。\r\n     INSPECT CS CONVERTING \"EE\" TO \"00\". 也可以加上BEFORE，AFTER。\r\n\r\nSTRING\r\n     将几个字符串合并成一个字符串。\r\n     STRING A DELIMITED BY SPACE，\" ！\" DELIMITED BY SIZE INTO C.假设A中的内容是\"HELLO\",则结果是\"HELLO !\".\r\n     DELIMITED BY SPACE意思是碰到空格，或到A的结尾或C的结尾，则合并A字符串结束。\r\n     DELIMITED BY SIZE意思是到\" ！\"的结尾或C的结尾，则合并\" ！\"字符串结束。\r\n     STRING A INTO B POINTER C ON OVERFLOW PROC1 NOT ON OVERFLOW   PROC2.\r\n     将A字符串复制到B中由C开始的地址处。如果C小于1或大于B的长度，或A的长度大于B中C到结尾处的长度，则发生\r\n     OVERFLOW溢出，执行PROC1。\r\n\r\nUNSTRING\r\n     将一个字符串中的字符按照要求放入多个变量中。\r\n     UNSTRING AAA [DELIMITED BY [ALL] B [OR [ALL] C] ...] INTO { C [DELIMITER IN D] [COUNT IN E] } ...[WITH POINTER F] [TALLYING IN G] [ON OVERFLOW PROC1] [NOT ON OVERFLOW PROC2] [END-UNSTRING] \r\n     将AAA中的字符放入C，如果还有其他变量，如C2，则等C放满后放入C2。\r\n     DELIMITED BY和STRING中的作用一样。表示将AAA中到B为止的字符取出。如果有OR，则表示到B或C字符为止的字符取出。如果有ALL，则如果几个相同的B在一起，则认为是一个B。\r\n     DELIMITER IN 将B放入D，知道是哪个字符为分隔符。\r\n     COUNT IN 实际复制到C中的字符数放入E中。\r\n     WITH POINTER 和STRIGN中一样。\r\n     TALLYING IN 计算有几个接受项。访问一个新的接受项，G值加1。\r\n例子：\r\n     03 CITY PIC X(10).\r\n     O3 ZIP   PIC X(10).\r\n     77 TEST PIC X(20).\r\n     MOVE \"NEW YORK,NY 10017\" TO TEST.\r\n     UNSTRING TEST DELIMITED BY \",\" INTO CITY,ZIP.\r\n     执行结果CITY值是NEW YORK.ZIP的值是NY 10017。\r\n\r\n逻辑和控制语句\r\n     IF (A [NOT] > B) 等价于 IF (A [NOT] GREATER THAN B)\r\n     IF (A [NOT] < B) 等价于 IF (A [NOT] LESS THAN B)\r\n     IF (A [NOT] = B) 等价于 IF (A [NOT] EQUAL TO B)\r\n     IF (A >= B) 等价于 IF (A GREATER THAN OR EQUAL TO B)\r\n     IF (A <= B) 等价于 IF (A LESS THAN OR EQUAL TO B)\r\n\r\n   IF (A [NOT] > B AND   C) 表示A [NOT] 大于B 而且 A [NOT] 大于C\r\n\r\n   IF A IS [NOT] NUMERIC     数字和可选符号\r\n   IF A IS [NOT] ALPHABETIC A~Z,a~z字符和空格\r\n   IF A IS [NOT] ALPHABETIC-LOWER a~z字符和空格\r\n   IF A IS [NOT] ALPHABETIC-UPPER A~Z字符和空格\r\n   IF A IS [NOT] CLASS-NAME        SPECIAL-NAMES定义的字符集\r\n   例如：SPECIAL-NAMES.\r\n             CLASS MYDEFINE IS \"12345+ABCDE-\".\r\n\r\n  判断变量是否定义了数值。这个变量是88层的，且要与一个数据项关联。\r\n     03 STATE PIC XX.\r\n     88 CON VALUES ARE \"A\",\"B\",\"C\".\r\n     IF CON ...\r\n\r\n   判断厂家定义运行开关的开/关状态。\r\n     SPECIAL-NAMES.\r\n         SWITCH-A ON STATUS IS A-ON ,OFF STATUS IS A-OFF.\r\n     IF A-ON...\r\n     若开关在开位置，则IF A-ON返回TRUE。\r\n\r\n   IF A IS [NOT] POSITIVE   判断是否大于0\r\n   IF A IS [NOT] NEGATIVE   判断是否小于0\r\n   IF A IS [NOT] ZERO       判断是否等于0\r\n\r\n   COBOL支持NOT ,AND ,OR 操作。\r\n\r\nPERFORM\r\n     过程调用，但是不传递参数。\r\n   PERFORM PROC1 [THROUGH PROC2] \r\n     执行完PROC1再执行PROC2.没有THROUGH(THRU)就只执行PROC1.\r\n   PERFORM PROC1 [THRU PROC2] N TIMES\r\n     执行PROC1[或者还有PROC2]N次。\r\n   PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] UNTIL A NOT EUQAL 0.\r\n     执行PROC1[或者还有PROC2]直到A不等于0。WITH TEST BEFORE/AFTER指定在第一次执行之前还是之后判断条件。默认是BEFORE，执行之前判断。\r\n   PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 [AFTER D FROM E BY F UNTIL CONDITION2].\r\n     相当于FOR循环，将A的值从B开始，以C为单位递增，直到满足CONDITION1。AFTER语句是一个嵌套的FOR 循环。VARYING是外循环，AFTER是内循环。A，B可以是索引。\r\n\r\n   过程也可以直接写入PERFORM中。但是THROUGH就不好用了。语法如下 ：\r\n   PERFORM 过程语句 END-PERFORM.\r\n   PERFORM N TIMES 过程语句 END-PERFORM.\r\n   PERFORM [WITH TEST BEFORE/AFTER] UNTIL CONDITION 过程语句 END-PERFORM.\r\n   PERFORM [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 过程语句 END-PERFORM.\r\n\r\nIF语句\r\n   IF CONDITION THEN STATEMENTS1/NEXT SENTENCE ELSE STATEMENTS2 END-IF/NEXT SENTENCE/ENDIF\r\n     NEXT SENTENCE将跳出IF操作语句执行下一条语句。\r\n     IF语句中不要使用.句号。.句号将结束所有IF语句。要结束一个嵌套的IF语句，可以使用END-IF或者NEXT SENTENCE.如\r\n     IF A IF B END-IF ELSE C END-IF.或者\r\n     IF A IF B ELSE NEXT SENTENCE ELSE C END-IF.\r\n\r\nUATE\r\n     相当于SWITCH CASE语句。\r\n     UATE A\r\n         WHEN B ...\r\n         WHEN 0 THRU 100 ...(FROM 0 TO 100)\r\n         WHEN OTHER ...\r\n     [END-UATE]\r\n     首先得到A的结果，和WHEN语句的参数比较，如果和B相等，就执行B后的操作，执行完了不再执行后面的WHEN语句。如果不等就执行下一条WHEN语句。如果没有相等的就执行WHEN OTHER语句。\r\n     UATE A ALSO B\r\n         WHEN C ALSO D ...\r\n         WHEN E ALSO F ...\r\n         WHEN OTHER ...\r\n     对于有多个判断条件的，要多个条件同时满足。如上要C=A同时D=B，才执行WHEN语句。\r\n\r\nCONTINUE\r\n     继续执行下面的程序。\r\n\r\nGO TO\r\n     GO TO PROC1 [DEPENDING ON N] DEPENDING ON N将跳转到清单中的第N个PROC.\r\n\r\nEXIT\r\n     一般为最后一句话。\r\n\r\nSTOP\r\n     STOP RUN   结束程序。\r\n\r\nALTER\r\n     ALTER PROC1 TO PROC2. 不懂什么意思，反正已经从标准中废除了这个语句。\r\n\r\nENTER\r\n     使其他编程语言中的语句可以放进当前源程序中。\r\n     ENTER LANGUAGE-NAME [ROUTINE-NAME]\r\n     LANGUAGE 是厂家指定可以输入COBOL的任何语言，这个语句后面是其他编程语言的语句，然后要用ENTERCOBOL表示返回COBOL语言。\r\n     如果无法将其他语言的程序直接放入，可以用ROUTINE-NAME引用其他语言编写的程序。', '<p>REDEFINES<br>     可以用不同的变量描述同一内存。<br>     01 PART_RECODE USAGE DISPLAY<br>        03 PART-TYPE PICTURE…<br>        03 PART_TYPE_A.<br>           05 PART_NUMBER PICTURE…<br>           05 PART_COST PICTURE…<br>        03 PART_TYPE_B REDEFINES PART_TYPE_A.<br>           05 UPC_CODE PICTURE…<br>        03 PART_TYPE_C REDEFINES PART_TYPE_A.<br>           05 ISBN PICTURE…<br>     根据PART_TYPE决定用PART_TYPE_A还是PART_TYPE_B还是PART_TYPE_C。<br>     规则：<br>         PART_TYPE_B和PART_TYPE_C长度不能大于PART_TYPE_A。<br>         数据项不能有VALUE。<br>         01层不能用REDEFINES.<br>         PART_TYPE_B和PART_TYPE_C中不能有OCCURS.\r\n<p>PICTURE<br>     定义基本项目的具体长度，格式，数据类型。可以简写成PIC.<br>     格式字符串最多30个字符，可以包含下列字符：<br>     A   字母A-Z,a-z,空格<br>     B   插入空格<br>     P   标量字符，代表字段中不显示的小数点位置<br>     S   代数符号，实际显示取决于项目的USAGE<br>     V   小数点位置<br>     X   任何字符<br>     Z   抑制前头的0并转换成空字符<br>     0   插入0<br>     9   数字0~9<br>     /   插入/<br>     ,   插入,(逗号不能作为字符串的最后一位，最后时逗号是分隔符)<br>     .   插入.<br>     ×   抑制前头的0并转换成×\r\n<ul>\r\n<li>正值插入+，负值插入-<ul>\r\n<li>正值插入空格，负值插入-<br>$   插入美元号<br>CR 正值插入两个空格，负值插入CR<br>DB 正值插入两个空格，负值插入DB<br>例子：<br>03 VAR PIC AAAAA.     VAR变量长度为5个字符，不能有数字，等价于03 STATE PIC A(5)。<br>输入ASDFG ,显示ASDFG<br>03 VAR PIC XXXXX.    VAR变量长度为5个任意字符。等价于03 FILLER PIC X(5)。<br>输入123AS ， 显示123AS<br>03 VAR PIC 99/XXX/9999 长度11，输入05may2004,显示05/may/2004<br>03 VAR PIC 0ABXXX/9999 长度11，输入05may2004,显示05 may/2004<br>03 VAR PIC 9(3) 长度3，0~999之间。<br>03 VAR PIC 9(4)V99 长度6，0.00~9999.99之间。<br>03 VAR PIC S9(5)V99 长度7，-99999.99~99999.99之间。<br>03 VAR PIC 9(6)PPP 长度6，可以是1000，2000，…,999999000。输入1234，显示1000。<br>03 VAR PIC PPP999 长度3，0.000001~0.000999之间。输入123，显示0.000123。<br>03 VAR PIC ZZZ.99，输入100.50,显示100.50;输入-51.50,显示51.50;<br>输入0,显示.00.<br>03 VAR PIC $ZZZ.ZZ-，输入100.50,显示$100.50;输入-51.50,显示$51.50-;<br>输入0,显示<br>03 VAR PIC $×××,×××.99CR，输入1000,显示$××1000.00;输入-1000,显示$××1000.00CR;<br>输入0,显示$×××,×××.00;输入51.5,显示$×××,×51.50<br>03 VAR PIC<br>$,<br>$.99，输入100.50,显示$100.50;输入-100.50,显示$100.50;<br>输入0.777,显示$.77;输入0,显示$.00<br>03 VAR PIC $.$$$，输入1.00,显示$.00;输入0.65,显示$.65;<br>输入0,显示$.00;<br>03 VAR PIC $—，输入17.7,显示$17;输入-17.7,显示$-17;<br>  输入-5,显示$-5<br>03 VAR PIC $999.99+，输入100.50,显示$100.50+;输入-100.50,显示$100.50-;<br>03 VAR PIC 9(3)B9(3)，输入55,显示000 055;输入1000.78,显示001 000;<br>03 FILLER PIC X(44)，补上44个空位。</ul>\r\n</li></ul>\r\n<p>USAGE 表示基本或组数据的类型。有BINARY,COMPUTATIONAL(COMP),DISPLAY,INDEX,PACKED-DECIMAL.</p>\r\n<p>JUSTIFIED<br>     03 VAR1 PIC X(5) JUSTIFIED RIGHT.<br>     03 VAR2 PIC X(5).<br>     输入XYZ，VAR1显示的是”   XYZ”，VAR2显示的是”XYZ   “。\r\n<p>BLANK WHEN ZERO<br>     03 VAR PIC $999,999.99 BLANK WHEN ZERO.<br>     当字段值为0，这个项目设置为全部空格。\r\n<p>VALUE<br>     定义的时候就赋值。<br>     03 VAR PIC X(5) VALUE “ABCDE”.<br>     01 VAR VALUE ALL SPACES.<br>     03 VAR1 PIC XXX.<br>     03 VAR2 PIC XX.\r\n<p>算术语句<br>    COBOL中操作符执行顺序为：取正(+)、取负(-)最高级，指数操作(××)其次，乘(×)、除(/)再其次，加(+)、减(-)最后。<br>    ROUNDED   舍入操作。<br>     77 A PIC 9V9 VALUE 9.1.<br>     77 B PIC 9.<br>       ADD 0.5 TO A GIVING B ON SIZE ERROR GO TO PROC1.<br>       ADD 0.5 TO A GIVING B ROUNDED ON SIZE ERROR GO TO PROC2.<br>       END-ADD.<br>ON SIZE ERROR 是当语句出现错误时执行的。本例中第一句话执行没有错误，所以ON SIZE ERROR<br>不执行PROC1.第二句话，当0.5加上9.1得到9.6，因为有ROUNDED,所以执行舍入操作，得到10。而B只有1位数字，所以发生错误，执行ON SIZE ERROR操作，跳转执行PROC2。<br>CORRESPONDING(CORR)     数据项同名时编写多条语句。ADD和SUBSTRACT有此选项。<br>     01 A.<br>        03 B.<br>           05 B1 PIC 999V99.<br>           05 B1 PIC 999V99.<br>           05 B1 PIC 999V99.<br>        03 C.<br>           05 B1 PIC 999V99.<br>           05 B1 PIC 999V99.<br>           05 B1 PIC 999V99.<br>则语句ADD CORR B TO C.相当于执行了下面3条语句。<br>     ADD B1 OF B TO B1 OF C.<br>     ADD B2 OF B TO B2 OF C.<br>     ADD B3 OF B TO B3 OF C.<br>组项目不一定要格式相同。一个组项目中的内容在另一个组项目中可以没有，数据项顺序也无关紧要。只是严格按照数据项名称对应。<br>     ADD A,B GIVING C. END-ADD.               将A,B相加放入C。<br>     SUBTRACT A,B FROM C. END-SUBTRACT.       从C中减去A,B.<br>     MULTIPLY A BY B GIVING C. END-MULTIPLY. 将A,B相乘放入C。<br>     DIVIDE A INTO B GIVING C. END-DIVIDE.    将B除于A的结果放入C.<br>     DIVIDE A BY B GIVING C. END-DIVIDE.      将A除于B的结果放入C.<br>     DIVIDE A BY B GIVING C REMAINDER D.      将A除于B的商放入C，余数放入D.<br>     D=A-B×C.<br>     77 C PIC S99V9.<br>     77 D PIC S99V9.<br>     DIVIDE 3 INTO 7 GIVING C REMAINDER D.<br>     C的值为2.3，D为0.1。(D=7-3×2.3)\r\n<p>COMPUTE<br>     除了取余操作要用DIVIDE外，其他操作都可以用此语句。本语句求值一个算术表达式，并将结果存放在一个或几个变量中。<br>     COMPUTE   A ROUNDED,B = X×Y/(N+M)+Z.   将X×Y/(N+M)+Z的结果存放在B中，然后舍入后放入A中。\r\n<p>MOVE<br>     MOVE A TO B.<br>     也可以用CORR选项。<br>     MOVE CORR A TO B.\r\n<p>ACCEPT<br>     从键盘或其他输入设备读取数据。<br>     ACCEPT A FROM DEV.     从DEV读取数据到A，也可以省略FROM DEV，表示从键盘读取。<br>     ACCEPT A FROM DATE/DAY/DAY-OF-WEEK/TIME.读取日期，表示为6个字符，如990909（1999年9月9日）。<br>     读取当前日期在年度（前2位）中为第几天（后3位），表示为6个字符，如1994年4月1日表示为94091。<br>     读取当前星期几，表示为1位字符。1表示星期一，7表示星期日。<br>     读取当前时间，表示为8位字符。精确到毫秒。如下午2：41表示为14410000。\r\n<p>DISPLAY<br>     将数据写入输出设备。如监视器（monite），系统输出流和操作员控制台（console）。<br>     DISPLAY AAAAA BBBBB [UPON DEV] [WITH NO ADVANCING]<br>     如果使用UPON选项，dev要与special-names段中的硬件名相关联。<br>     如果使用no advancing选项，则输出最后一个字符后输出设备仍然保持原位，使下一条display语句还在该位置显示。否则可能到下一行显示。\r\n<p>INITIALIZE<br>     初始化数据，数字和数字编辑数据项初始化为0，其他初始化为空格。\r\n<p>INSPECT TALLYING<br>     计算项目中该字符串出现的次数。<br>     INSPECT AA TALLYING BB FOR ALL “EE”.   从AA中查找有多少个EE，将个数写入BB。<br>     INSPECT AA TALLYING BB FOR CHARACTERS BEFORE “E”.   从AA中查找E前面有多少个字符，将个数写入BB。<br>     INSPECT AA TALLYING BB FOR CHARACTERS AFTER “C” BEFORE “E”.   从AA中查找C后面E前面有多少个字符，将个数写入BB。<br>     INSPECT AA TALLYING BB FOR LEADING “E”.   从AA中第一个字符开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。<br>     INSPECT AA TALLYING BB FOR LEADING “E” AFTER “C”.   从AA中C后面开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。<br>组合例子：<br>     77 CS PIC X(9) VALUE “REELWHEEL”.<br>     77 COUNT-0.<br>     77 COUNT-1.<br>     77 COUNT-2.<br>     MOVE 0 TO COUNT-0,COUNT-1,COUNT-2.<br>     INSPECT CS TALLYING<br>         COUNT-0 FOR ALL “E”,<br>         COUNT-1 FOR LEADING “W” AFTER “L”,<br>         COUNT-2 FOR CHARACTERS.<br>     程序首先判断的是字符”R”,执行COUNT-0 FOR ALL “E”，因为第一个字符不是”E”，所以程序转而执行COUNT-1 FOR LEADING “W” AFTER “L”，也不符合要求，<br>     于是程序执行COUNT-2 FOR CHARACTERS，COUNT-2 =1。然后字符串往下一位，判断”E”,执行COUNT-0 FOR ALL “E”，符合要求，则COUNT-0=1。<br>     有了满足条件的判断，则余下的判断不再执行，字符串再往下一位，判断”E”，则COUNT-0=2。接着判断”L”,则COUNT-2 =2。以此类推，最后结果为COUNT-0=4，<br>     COUNT-1=1，COUNT-2=4。\r\n<p>INSPECT REPLACING<br>     用另一个字符串替换这个字符串。<br>     还用上面的例子。<br>     INSPECT CS REPLACING ALL “E” BY “Y”.   结果”RYYLWHYYL”<br>     INSPECT CS REPLACING CHARACTERS BY “Z” AFTER   “L”.   结果”REELZZZZZ”<br>     INSPECT CS REPLACING LEADING “E” BY “Y”.   结果不变<br>     INSPECT CS REPLACING LEADING “E” BY “Z” AFTER   “H”.   结果”REELWHZZL”<br>     INSPECT CS REPLACING FIRST “E” BY “I”.   结果”RIELWHEEL”<br>     INSPECT CS REPLACING FIRST “EE” BY “00”,ALL “WH” BY “TH”,CHARACTERS BY SPACE.   结果” 00 TH    “\r\n<p>INSPECT CONVERTING<br>     就是INSPECT REPLACING的缩写。<br>     INSPECT CS CONVERTING “EE” TO “00”. 也可以加上BEFORE，AFTER。\r\n<p>STRING<br>     将几个字符串合并成一个字符串。<br>     STRING A DELIMITED BY SPACE，” ！” DELIMITED BY SIZE INTO C.假设A中的内容是”HELLO”,则结果是”HELLO !”.<br>     DELIMITED BY SPACE意思是碰到空格，或到A的结尾或C的结尾，则合并A字符串结束。<br>     DELIMITED BY SIZE意思是到” ！”的结尾或C的结尾，则合并” ！”字符串结束。<br>     STRING A INTO B POINTER C ON OVERFLOW PROC1 NOT ON OVERFLOW   PROC2.<br>     将A字符串复制到B中由C开始的地址处。如果C小于1或大于B的长度，或A的长度大于B中C到结尾处的长度，则发生<br>     OVERFLOW溢出，执行PROC1。\r\n<p>UNSTRING<br>     将一个字符串中的字符按照要求放入多个变量中。<br>     UNSTRING AAA [DELIMITED BY [ALL] B [OR [ALL] C] …] INTO { C [DELIMITER IN D] [COUNT IN E] } …[WITH POINTER F] [TALLYING IN G] [ON OVERFLOW PROC1] [NOT ON OVERFLOW PROC2] [END-UNSTRING]<br>     将AAA中的字符放入C，如果还有其他变量，如C2，则等C放满后放入C2。<br>     DELIMITED BY和STRING中的作用一样。表示将AAA中到B为止的字符取出。如果有OR，则表示到B或C字符为止的字符取出。如果有ALL，则如果几个相同的B在一起，则认为是一个B。<br>     DELIMITER IN 将B放入D，知道是哪个字符为分隔符。<br>     COUNT IN 实际复制到C中的字符数放入E中。<br>     WITH POINTER 和STRIGN中一样。<br>     TALLYING IN 计算有几个接受项。访问一个新的接受项，G值加1。<br>例子：<br>     03 CITY PIC X(10).<br>     O3 ZIP   PIC X(10).<br>     77 TEST PIC X(20).<br>     MOVE “NEW YORK,NY 10017” TO TEST.<br>     UNSTRING TEST DELIMITED BY “,” INTO CITY,ZIP.<br>     执行结果CITY值是NEW YORK.ZIP的值是NY 10017。\r\n<p>逻辑和控制语句<br>     IF (A [NOT] &gt; B) 等价于 IF (A [NOT] GREATER THAN B)<br>     IF (A [NOT] &lt; B) 等价于 IF (A [NOT] LESS THAN B)<br>     IF (A [NOT] = B) 等价于 IF (A [NOT] EQUAL TO B)<br>     IF (A &gt;= B) 等价于 IF (A GREATER THAN OR EQUAL TO B)<br>     IF (A <= B) 等价于 IF (A LESS THAN OR EQUAL TO B)\r\n<p>   IF (A [NOT] &gt; B AND   C) 表示A [NOT] 大于B 而且 A [NOT] 大于C</p>\r\n<p>   IF A IS [NOT] NUMERIC     数字和可选符号<br>   IF A IS [NOT] ALPHABETIC A~Z,a~z字符和空格<br>   IF A IS [NOT] ALPHABETIC-LOWER a~z字符和空格<br>   IF A IS [NOT] ALPHABETIC-UPPER A~Z字符和空格<br>   IF A IS [NOT] CLASS-NAME        SPECIAL-NAMES定义的字符集<br>   例如：SPECIAL-NAMES.<br>             CLASS MYDEFINE IS “12345+ABCDE-“.\r\n<p>  判断变量是否定义了数值。这个变量是88层的，且要与一个数据项关联。<br>     03 STATE PIC XX.<br>     88 CON VALUES ARE “A”,”B”,”C”.<br>     IF CON …\r\n<p>   判断厂家定义运行开关的开/关状态。<br>     SPECIAL-NAMES.<br>         SWITCH-A ON STATUS IS A-ON ,OFF STATUS IS A-OFF.<br>     IF A-ON…<br>     若开关在开位置，则IF A-ON返回TRUE。\r\n<p>   IF A IS [NOT] POSITIVE   判断是否大于0<br>   IF A IS [NOT] NEGATIVE   判断是否小于0<br>   IF A IS [NOT] ZERO       判断是否等于0\r\n<p>   COBOL支持NOT ,AND ,OR 操作。</p>\r\n<p>PERFORM<br>     过程调用，但是不传递参数。<br>   PERFORM PROC1 [THROUGH PROC2]<br>     执行完PROC1再执行PROC2.没有THROUGH(THRU)就只执行PROC1.<br>   PERFORM PROC1 [THRU PROC2] N TIMES<br>     执行PROC1[或者还有PROC2]N次。<br>   PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] UNTIL A NOT EUQAL 0.<br>     执行PROC1[或者还有PROC2]直到A不等于0。WITH TEST BEFORE/AFTER指定在第一次执行之前还是之后判断条件。默认是BEFORE，执行之前判断。<br>   PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 [AFTER D FROM E BY F UNTIL CONDITION2].<br>     相当于FOR循环，将A的值从B开始，以C为单位递增，直到满足CONDITION1。AFTER语句是一个嵌套的FOR 循环。VARYING是外循环，AFTER是内循环。A，B可以是索引。\r\n<p>   过程也可以直接写入PERFORM中。但是THROUGH就不好用了。语法如下 ：<br>   PERFORM 过程语句 END-PERFORM.<br>   PERFORM N TIMES 过程语句 END-PERFORM.<br>   PERFORM [WITH TEST BEFORE/AFTER] UNTIL CONDITION 过程语句 END-PERFORM.<br>   PERFORM [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 过程语句 END-PERFORM.\r\n<p>IF语句<br>   IF CONDITION THEN STATEMENTS1/NEXT SENTENCE ELSE STATEMENTS2 END-IF/NEXT SENTENCE/ENDIF<br>     NEXT SENTENCE将跳出IF操作语句执行下一条语句。<br>     IF语句中不要使用.句号。.句号将结束所有IF语句。要结束一个嵌套的IF语句，可以使用END-IF或者NEXT SENTENCE.如<br>     IF A IF B END-IF ELSE C END-IF.或者<br>     IF A IF B ELSE NEXT SENTENCE ELSE C END-IF.\r\n<p>UATE<br>     相当于SWITCH CASE语句。<br>     UATE A<br>         WHEN B …<br>         WHEN 0 THRU 100 …(FROM 0 TO 100)<br>         WHEN OTHER …<br>     [END-UATE]<br>     首先得到A的结果，和WHEN语句的参数比较，如果和B相等，就执行B后的操作，执行完了不再执行后面的WHEN语句。如果不等就执行下一条WHEN语句。如果没有相等的就执行WHEN OTHER语句。<br>     UATE A ALSO B<br>         WHEN C ALSO D …<br>         WHEN E ALSO F …<br>         WHEN OTHER …<br>     对于有多个判断条件的，要多个条件同时满足。如上要C=A同时D=B，才执行WHEN语句。\r\n<p>CONTINUE<br>     继续执行下面的程序。\r\n<p>GO TO<br>     GO TO PROC1 [DEPENDING ON N] DEPENDING ON N将跳转到清单中的第N个PROC.\r\n<p>EXIT<br>     一般为最后一句话。\r\n<p>STOP<br>     STOP RUN   结束程序。\r\n<p>ALTER<br>     ALTER PROC1 TO PROC2. 不懂什么意思，反正已经从标准中废除了这个语句。\r\n<p>ENTER<br>     使其他编程语言中的语句可以放进当前源程序中。<br>     ENTER LANGUAGE-NAME [ROUTINE-NAME]<br>     LANGUAGE 是厂家指定可以输入COBOL的任何语言，这个语句后面是其他编程语言的语句，然后要用ENTERCOBOL表示返回COBOL语言。<br>     如果无法将其他语言的程序直接放入，可以用ROUTINE-NAME引用其他语言编写的程序。\r\n', null, null, null, '2020-10-18 21:13:19', '2020-10-18 21:16:45', '1');
INSERT INTO `articles` VALUES ('50', '1', 'COBOL 知识点集锦（下）', '', 'COBOL <wbr> <wbr>知识点集锦（下） cobol子程序调用\r\n内部子程序\r\n    IDENTIFICATION DIVISION.\r\n    PROGRAM-ID. PROC-A.\r\n    ENVIRONMENT DIVISION.\r\n    ...\r\n    DATA DIVISION.\r\n    ...\r\n    PROCEDURE DIVISION.\r\n    ...\r\n       IDENTIFICATION DIVISION.\r\n       PROGRAM-ID. PROC-B.\r\n       ENVIRONMENT DIVISION.\r\n       ...\r\n       DATA DIVISION.\r\n       ...\r\n       PROCEDURE DIVISION.\r\n       ...\r\n       END PROGRAM PROC-B.\r\n       IDENTIFICATION DIVISION.\r\n       PROGRAM-ID. PROC-C.\r\n       ENVIRONMENT DIVISION.\r\n       ...\r\n       DATA DIVISION.\r\n       ...\r\n       PROCEDURE DIVISION.\r\n       ...\r\n           IDENTIFICATION DIVISION.\r\n           PROGRAM-ID. PROC-D.\r\n           ENVIRONMENT DIVISION.\r\n           ...\r\n           DATA DIVISION.\r\n           ...\r\n           PROCEDURE DIVISION.\r\n           ...\r\n           END PROGRAM PROC-D.\r\n       END PROGRAM PROC-C.\r\n    END PROGRAM PROC-A.\r\n    程序A包含B,C两个子程序，其中C又包含子程序D。\r\n    A能调用B，C。C能调用D。B不能调用C，A不能调用D。\r\n    如果C声明为公用的，则B可以调用C，语法为：\r\n    PROGRAM-ID. PROC-C IS COMMON PROGRAM.\r\n\r\n   当前函数中定义的变量都只是对当前函数有效。可以用GLOBAL声明为对所有函数有效。\r\n    01 DATA-NAME IS GOLBAL ...\r\n    文件也有此声明：FD FILE-NAME IS GOLBAL ...\r\n\r\n   如果调用的不是本程序中的文件或变量，则可以用EXTERNAL声明。\r\n    FD FILE-NAME IS EXTERNAL.../01 DATA-NAME IS EXTERNAL...\r\n\r\n   CALL PROC VAR1 [ON EXCEPTION CODE1] [NOT ON EXCEPTION CODE2] END-CALL.\r\n    如果找不到PROC程序名，执行CODE1(如果有此声明)，找到将参数VAR1传递给PROC，并执行。PROC返回时执行CODE2(如果有此声明)。\r\n    参数应该在文件，工作存储或连接节中定义，应为01层数据项，77层数据项或基本数据项。\r\n    子程序要返回调用程序，执行EXIT PROGRAM\r\n\r\n   传递参数有3步:\r\n    首先在调用程序的CALL语句列出要传递的参数。\r\n    CALL PROC VAR1 .\r\n    然后在被调用程序的过程部标题，使用USING短语列出相应的参数。\r\n    PROCEDURE DIVISION USING VAR1.\r\n    最后在被调用程序的连接节(LINKAGE SECTION)提供参数的存储空间。 \r\n    LINKAGE SECTION.\r\n    01 VAR1 PIC XX.\r\n\r\n   参数传递有2中方式:\r\n    BY CONTENT    传递的参数值只在被调用函数中被改变，调用函数中的值不变。\r\n    BY REFERENCE. 传递的参数值在被调用函数中被改变，调用函数中的值也改变。\r\n    CALL PROC VAR1 BY CONTENT/REFERENCE.\r\n\r\n   再次调用子程序，子程序处于上次退出的状态（除了连接节中的数据），打开的文件依然打开。\r\n    可以用INITIAL声明函数被调用时处于初始状态。\r\n    PROGRAM-ID. PROC-C IS INITIAL PROGRAM.\r\n\r\n   如果不想每次执行都初始化，只在需要的时候初始化，可以用CANCEL PROC.初始化PROC程序，但不执行PROC。\r\n\r\ncobol 知识点集锦\r\nCOBOL <wbr> <wbr>知识点集锦（下） COBOL数据类型\r\n        计息是银行的一项重要业务，包括日常代理客户收、付计算客户利息和年度计息等。目前，这些工作大多数是在IBM ES9000主机的SAFE应用系统平台上进行，该系统联机程序和联机计息程序是用IBM 370汇编语言实现的。为方便汇编语言读写，在VSAM文件存储的数据中，数据存放格式进行了特殊的定义。如日期存放采用X(3)型，01年03月15日，存入EBCD码为X‘010315’。在进行年度计息时，为了实现各种复杂的运算工作，一般采用COBOL语言来实现各种运算。而采用COBOL语言读取X(3)型数据时，读出的是字符型数据，不能直接进行运算，必须转换为COBOL数据类型的数据后才能进行相应处理。如刚才的X‘010315’，需要转换为内部十进制数据X‘0010315C’。本文介绍一种用COBOL语言实现字符型X(3)与内部十进制数据相互转换的方法。\r\n由X(3)型转换为内部十进制\r\n由于日期数据总是大于零，在COBOL语言的工作单元节定义变量DATE－FIRST后，再追加定义COBOL语言的最小数据单元X‘000C’，即十进制12。由于重定义DATE－CASE为DATE－CHANGE后，DATE－CHANGE是原日期数据的1000倍，于是要在过程部将DATE－CHANGE除以1000。\r\n首先，在COBOL程序WORKING－STORAGE SECTION. 中定义如下内容：\r\nWORKING－STORAGE SECTION.\r\n01 DATE－CASE.\r\n02 DATE－FIRST PIC X(3).\r\n02 DATE－SIGN PIC 9(4) COMP VALUE 12.；定点二进制数\r\n01 DATE－CHANGE REDEFINES DATE－CASE PIC 9(9) COMP－3. ；内部十进制数据\r\n01 DATE－HEX PIC X（3）. ； 转换前数据\r\n01 DATE－DEC PIC S9（7）COMP－3 . ； 转换后数据\r\n然后，在过程部PROCEDURE DEVISION.中加入如下语句：\r\nPROCEDURE DEVISION.\r\nMOVE DATE－HEX TO DATE－FIRST .\r\nCOMPUTE DATE－CHANGE = DATE－\r\nCHANGE / 1000.\r\nMOVE DATE－CHANGE TO DATE－DEC.\r\n由内部十进制转换为X(3)型\r\n在进行相反的转换时，要消除因COBOL语言数据类型标志“C”引起的原日期数据前多加的一个0，所以需要将转换数据乘以10，再取出前6位数据即可。\r\n首先，在COBOL程序WORKING－STORAGE SECTION. 中定义如下内容：\r\nWORKING－STORAGE SECTION.\r\n01 WORK－DATE PIC S9(7) COMP－3.\r\n01 AA REDEFINES WORK－DATE.\r\n02 A1 PIC X(3).\r\n02 A2 PIC X(1).\r\n01 DATE－HEX PIC X(3). ；转换后数据\r\n01 DATE－DEC PIC S9(7) COMP－3.\r\n；转换前数据\r\n然后，在过程部PROCEDURE DEVISION.中加入如下语句即可：\r\nPROCEDURE DIVISION.\r\nMOVE DATE－DEC TO WORK－DATE。\r\nCOMPUTE WORK－DATE=WORK－DATE＊10.\r\nMOVE A1 TO DATE－HEX .\r\n\r\nCOBOL <wbr> <wbr>知识点集锦（下） cobol语法\r\nREDEFINES\r\n    可以用不同的变量描述同一内存。\r\n    01 PART_RECODE USAGE DISPLAY\r\n       03 PART-TYPE PICTURE...\r\n       03 PART_TYPE_A.\r\n          05 PART_NUMBER PICTURE...\r\n          05 PART_COST PICTURE...\r\n       03 PART_TYPE_B REDEFINES PART_TYPE_A.\r\n          05 UPC_CODE PICTURE...\r\n       03 PART_TYPE_C REDEFINES PART_TYPE_A.\r\n          05 ISBN PICTURE...\r\n    根据PART_TYPE决定用PART_TYPE_A还是PART_TYPE_B还是PART_TYPE_C。\r\n    规则：\r\n        PART_TYPE_B和PART_TYPE_C长度不能大于PART_TYPE_A。\r\n        数据项不能有VALUE。\r\n        01层不能用REDEFINES.\r\n        PART_TYPE_B和PART_TYPE_C中不能有OCCURS.\r\n\r\nPICTURE\r\n    定义基本项目的具体长度，格式，数据类型。可以简写成PIC.\r\n    格式字符串最多30个字符，可以包含下列字符：\r\n    A  字母A-Z,a-z,空格\r\n    B  插入空格\r\n    P  标量字符，代表字段中不显示的小数点位置\r\n    S  代数符号，实际显示取决于项目的USAGE\r\n    V  小数点位置\r\n    X  任何字符\r\n    Z  抑制前头的0并转换成空字符\r\n    0  插入0\r\n    9  数字0~9\r\n    /  插入/\r\n    ,  插入,(逗号不能作为字符串的最后一位，最后时逗号是分隔符)\r\n    .  插入.\r\n   *  抑制前头的0并转换成*\r\n    +  正值插入+，负值插入-\r\n    -  正值插入空格，负值插入-\r\n    $  插入美元号\r\n    CR 正值插入两个空格，负值插入CR\r\n    DB 正值插入两个空格，负值插入DB\r\n例子：\r\n    03 VAR PIC AAAAA.    VAR变量长度为5个字符，不能有数字，等价于03 STATE PIC A(5)。\r\n    输入ASDFG ,显示ASDFG\r\n    03 VAR PIC XXXXX.   VAR变量长度为5个任意字符。等价于03 FILLER PIC X(5)。\r\n    输入123AS ，显示123AS\r\n    03 VAR PIC 99/XXX/9999 长度11，输入05may2004,显示05/may/2004\r\n    03 VAR PIC 0ABXXX/9999 长度11，输入05may2004,显示05 may/2004\r\n    03 VAR PIC 9(3) 长度3，0~999之间。\r\n    03 VAR PIC 9(4)V99 长度6，0.00~9999.99之间。\r\n    03 VAR PIC S9(5)V99 长度7，-99999.99~99999.99之间。\r\n    03 VAR PIC 9(6)PPP 长度6，可以是1000，2000，...,999999000。输入1234，显示1000。\r\n    03 VAR PIC PPP999 长度3，0.000001~0.000999之间。输入123，显示0.000123。\r\n    03 VAR PIC ZZZ.99，输入100.50,显示100.50;输入-51.50,显示51.50;\r\n    输入0,显示.00.\r\n    03 VAR PIC $ZZZ.ZZ-，输入100.50,显示$100.50;输入-51.50,显示$51.50-;\r\n    输入0,显示\r\n    03 VAR PIC $***,***.99CR，输入1000,显示$**1000.00;输入-1000,显示$**1000.00CR;\r\n    输入0,显示$***,***.00;输入51.5,显示$***,*51.50\r\n    03 VAR PIC\r\n$,\r\n$.99，输入100.50,显示$100.50;输入-100.50,显示$100.50;\r\n    输入0.777,显示$.77;输入0,显示$.00\r\n    03 VAR PIC $.$$$，输入1.00,显示$.00;输入0.65,显示$.65;\r\n    输入0,显示$.00;\r\n    03 VAR PIC $--，输入17.7,显示$17;输入-17.7,显示$-17;\r\n            输入-5,显示$-5\r\n    03 VAR PIC $999.99+，输入100.50,显示$100.50+;输入-100.50,显示$100.50-;\r\n    03 VAR PIC 9(3)B9(3)，输入55,显示000 055;输入1000.78,显示001 000;\r\n    03 FILLER PIC X(44)，补上44个空位。\r\n\r\n\r\nUSAGE 表示基本或组数据的类型。有BINARY,COMPUTATIONAL(COMP),DISPLAY,INDEX,PACKED-DECIMAL.\r\n\r\nJUSTIFIED\r\n    03 VAR1 PIC X(5) JUSTIFIED RIGHT.\r\n    03 VAR2 PIC X(5).\r\n    输入XYZ，VAR1显示的是\"  XYZ\"，VAR2显示的是\"XYZ  \"。\r\n\r\nBLANK WHEN ZERO\r\n    03 VAR PIC $999,999.99 BLANK WHEN ZERO.\r\n    当字段值为0，这个项目设置为全部空格。\r\n\r\nVALUE\r\n    定义的时候就赋值。\r\n    03 VAR PIC X(5) VALUE \"ABCDE\".\r\n    01 VAR VALUE ALL SPACES.\r\n    03 VAR1 PIC XXX.\r\n    03 VAR2 PIC XX.\r\n\r\n算术语句\r\n    COBOL中操作符执行顺序为：取正(+)、取负(-)最高级，指数操作(**)其次，乘(*)、除(/)再其次，加(+)、减(-)最后。\r\n    ROUNDED  舍入操作。\r\n    77 A PIC 9V9 VALUE 9.1.\r\n    77 B PIC 9.\r\n      ADD 0.5 TO A GIVING B ON SIZE ERROR GO TO PROC1.\r\n      ADD 0.5 TO A GIVING B ROUNDED ON SIZE ERROR GO TO PROC2.\r\n      END-ADD.\r\nON SIZE ERROR 是当语句出现错误时执行的。本例中第一句话执行没有错误，所以ON SIZE ERROR\r\n不执行PROC1.第二句话，当0.5加上9.1得到9.6，因为有ROUNDED,所以执行舍入操作，得到10。而B只有1位数字，所以发生错误，执行ON SIZE ERROR操作，跳转执行PROC2。  \r\nCORRESPONDING(CORR)    数据项同名时编写多条语句。ADD和SUBSTRACT有此选项。\r\n    01 A.\r\n       03 B.\r\n          05 B1 PIC 999V99.\r\n          05 B1 PIC 999V99.\r\n          05 B1 PIC 999V99.\r\n       03 C.\r\n          05 B1 PIC 999V99.\r\n          05 B1 PIC 999V99.\r\n          05 B1 PIC 999V99.\r\n则语句ADD CORR B TO C.相当于执行了下面3条语句。\r\n    ADD B1 OF B TO B1 OF C.\r\n    ADD B2 OF B TO B2 OF C.\r\n    ADD B3 OF B TO B3 OF C.\r\n组项目不一定要格式相同。一个组项目中的内容在另一个组项目中可以没有，数据项顺序也无关紧要。只是严格按照数据项名称对应。\r\n    ADD A,B GIVING C. END-ADD.              将A,B相加放入C。\r\n    SUBTRACT A,B FROM C. END-SUBTRACT.      从C中减去A,B.\r\n    MULTIPLY A BY B GIVING C. END-MULTIPLY. 将A,B相乘放入C。\r\n    DIVIDE A INTO B GIVING C. END-DIVIDE.   将B除于A的结果放入C.\r\n    DIVIDE A BY B GIVING C. END-DIVIDE.     将A除于B的结果放入C.\r\n    DIVIDE A BY B GIVING C REMAINDER D.     将A除于B的商放入C，余数放入D.\r\n    D=A-B*C.\r\n    77 C PIC S99V9.\r\n    77 D PIC S99V9.\r\n    DIVIDE 3 INTO 7 GIVING C REMAINDER D.\r\n    C的值为2.3，D为0.1。(D=7-3*2.3)\r\n\r\nCOMPUTE\r\n    除了取余操作要用DIVIDE外，其他操作都可以用此语句。本语句求值一个算术表达式，并将结果存放在一个或几个变量中。\r\n    COMPUTE  A ROUNDED,B = X*Y/(N+M)+Z.   将X*Y/(N+M)+Z的结果存放在B中，然后舍入后放入A中。\r\n\r\nMOVE \r\n    MOVE A TO B.\r\n    也可以用CORR选项。\r\n    MOVE CORR A TO B.\r\n\r\nACCEPT\r\n    从键盘或其他输入设备读取数据。\r\n    ACCEPT A FROM DEV.    从DEV读取数据到A，也可以省略FROM DEV，表示从键盘读取。\r\n    ACCEPT A FROM DATE/DAY/DAY-OF-WEEK/TIME.读取日期，表示为6个字符，如990909（1999年9月9日）。\r\n    读取当前日期在年度（前2位）中为第几天（后3位），表示为6个字符，如1994年4月1日表示为94091。\r\n    读取当前星期几，表示为1位字符。1表示星期一，7表示星期日。\r\n    读取当前时间，表示为8位字符。精确到毫秒。如下午2：41表示为14410000。\r\n\r\nDISPLAY\r\n    将数据写入输出设备。如监视器（monite），系统输出流和操作员控制台（console）。\r\n    DISPLAY AAAAA BBBBB [UPON DEV] [WITH NO ADVANCING]\r\n    如果使用UPON选项，dev要与special-names段中的硬件名相关联。\r\n    如果使用no advancing选项，则输出最后一个字符后输出设备仍然保持原位，使下一条display语句还在该位置显示。否则可能到下一行显示。\r\n\r\nINITIALIZE\r\n    初始化数据，数字和数字编辑数据项初始化为0，其他初始化为空格。\r\n\r\nINSPECT TALLYING\r\n    计算项目中该字符串出现的次数。\r\n    INSPECT AA TALLYING BB FOR ALL “EE”.  从AA中查找有多少个EE，将个数写入BB。\r\n    INSPECT AA TALLYING BB FOR CHARACTERS BEFORE “E”.  从AA中查找E前面有多少个字符，将个数写入BB。\r\n    INSPECT AA TALLYING BB FOR CHARACTERS AFTER “C” BEFORE “E”.  从AA中查找C后面E前面有多少个字符，将个数写入BB。\r\n    INSPECT AA TALLYING BB FOR LEADING “E”.  从AA中第一个字符开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。\r\n    INSPECT AA TALLYING BB FOR LEADING “E” AFTER “C”.  从AA中C后面开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。\r\n组合例子：\r\n    77 CS PIC X(9) VALUE \"REELWHEEL\".\r\n    77 COUNT-0.\r\n    77 COUNT-1.\r\n    77 COUNT-2.\r\n    MOVE 0 TO COUNT-0,COUNT-1,COUNT-2.\r\n    INSPECT CS TALLYING\r\n        COUNT-0 FOR ALL \"E\",\r\n        COUNT-1 FOR LEADING \"W\" AFTER \"L\",\r\n        COUNT-2 FOR CHARACTERS.\r\n    程序首先判断的是字符\"R\",执行COUNT-0 FOR ALL \"E\"，因为第一个字符不是\"E\"，所以程序转而执行COUNT-1 FOR LEADING \"W\" AFTER \"L\"，也不符合要求，\r\n    于是程序执行COUNT-2 FOR CHARACTERS，COUNT-2 =1。然后字符串往下一位，判断\"E\",执行COUNT-0 FOR ALL \"E\"，符合要求，则COUNT-0=1。\r\n    有了满足条件的判断，则余下的判断不再执行，字符串再往下一位，判断\"E\"，则COUNT-0=2。接着判断\"L\",则COUNT-2 =2。以此类推，最后结果为COUNT-0=4，\r\n    COUNT-1=1，COUNT-2=4。\r\n\r\n\r\nINSPECT REPLACING\r\n    用另一个字符串替换这个字符串。\r\n    还用上面的例子。\r\n    INSPECT CS REPLACING ALL \"E\" BY \"Y\".  结果\"RYYLWHYYL\"\r\n    INSPECT CS REPLACING CHARACTERS BY \"Z\" AFTER  \"L\".  结果\"REELZZZZZ\"\r\n    INSPECT CS REPLACING LEADING \"E\" BY \"Y\".  结果不变\r\n    INSPECT CS REPLACING LEADING \"E\" BY \"Z\" AFTER  \"H\".  结果\"REELWHZZL\"\r\n    INSPECT CS REPLACING FIRST \"E\" BY \"I\".  结果\"RIELWHEEL\"\r\n    INSPECT CS REPLACING FIRST \"EE\" BY \"00\",ALL \"WH\" BY \"TH\",CHARACTERS BY SPACE.  结果\" 00 TH   \"\r\n\r\nINSPECT CONVERTING\r\n    就是INSPECT REPLACING的缩写。\r\n    INSPECT CS CONVERTING \"EE\" TO \"00\". 也可以加上BEFORE，AFTER。\r\n\r\nSTRING\r\n    将几个字符串合并成一个字符串。\r\n    STRING A DELIMITED BY SPACE，\" ！\" DELIMITED BY SIZE INTO C.假设A中的内容是\"HELLO\",则结果是\"HELLO !\".\r\n    DELIMITED BY SPACE意思是碰到空格，或到A的结尾或C的结尾，则合并A字符串结束。\r\n    DELIMITED BY SIZE意思是到\" ！\"的结尾或C的结尾，则合并\" ！\"字符串结束。\r\n    STRING A INTO B POINTER C ON OVERFLOW PROC1 NOT ON OVERFLOW  PROC2.\r\n    将A字符串复制到B中由C开始的地址处。如果C小于1或大于B的长度，或A的长度大于B中C到结尾处的长度，则发生\r\n    OVERFLOW溢出，执行PROC1。\r\n\r\nUNSTRING\r\n    将一个字符串中的字符按照要求放入多个变量中。\r\n    UNSTRING AAA [DELIMITED BY [ALL] B [OR [ALL] C] ...] INTO { C [DELIMITER IN D] [COUNT IN E] } ...[WITH POINTER F] [TALLYING IN G] [ON OVERFLOW PROC1] [NOT ON OVERFLOW PROC2] [END-UNSTRING]  \r\n    将AAA中的字符放入C，如果还有其他变量，如C2，则等C放满后放入C2。\r\n    DELIMITED BY和STRING中的作用一样。表示将AAA中到B为止的字符取出。如果有OR，则表示到B或C字符为止的字符取出。如果有ALL，则如果几个相同的B在一起，则认为是一个B。\r\n    DELIMITER IN 将B放入D，知道是哪个字符为分隔符。\r\n    COUNT IN 实际复制到C中的字符数放入E中。\r\n    WITH POINTER 和STRIGN中一样。\r\n    TALLYING IN 计算有几个接受项。访问一个新的接受项，G值加1。\r\n例子：\r\n    03 CITY PIC X(10).\r\n    O3 ZIP  PIC X(10).\r\n    77 TEST PIC X(20).\r\n    MOVE \"NEW YORK,NY 10017\" TO TEST.\r\n    UNSTRING TEST DELIMITED BY \",\" INTO CITY,ZIP.\r\n    执行结果CITY值是NEW YORK.ZIP的值是NY 10017。\r\n\r\n逻辑和控制语句\r\n   IF (A [NOT] > B) 等价于 IF (A [NOT] GREATER THAN B)\r\n   IF (A [NOT] < B) 等价于 IF (A [NOT] LESS THAN B)\r\n   IF (A [NOT] = B) 等价于 IF (A [NOT] EQUAL TO B)\r\n   IF (A >= B) 等价于 IF (A GREATER THAN OR EQUAL TO B)\r\n   IF (A <= B) 等价于 IF (A LESS THAN OR EQUAL TO B)\r\n\r\n   IF (A [NOT] > B AND  C) 表示A [NOT] 大于B 而且 A [NOT] 大于C\r\n\r\n   IF A IS [NOT] NUMERIC    数字和可选符号\r\n   IF A IS [NOT] ALPHABETIC A~Z,a~z字符和空格\r\n   IF A IS [NOT] ALPHABETIC-LOWER a~z字符和空格\r\n   IF A IS [NOT] ALPHABETIC-UPPER A~Z字符和空格\r\n   IF A IS [NOT] CLASS-NAME       SPECIAL-NAMES定义的字符集\r\n    例如：SPECIAL-NAMES.\r\n              CLASS MYDEFINE IS \"12345+ABCDE-\".\r\n\r\n   判断变量是否定义了数值。这个变量是88层的，且要与一个数据项关联。\r\n    03 STATE PIC XX.\r\n    88 CON VALUES ARE \"A\",\"B\",\"C\".\r\n    IF CON ...\r\n\r\n   判断厂家定义运行开关的开/关状态。\r\n    SPECIAL-NAMES.\r\n        SWITCH-A ON STATUS IS A-ON ,OFF STATUS IS A-OFF.\r\n    IF A-ON...\r\n   若开关在开位置，则IF A-ON返回TRUE。\r\n\r\n   IF A IS [NOT] POSITIVE  判断是否大于0\r\n    IF A IS [NOT] NEGATIVE  判断是否小于0\r\n    IF A IS [NOT] ZERO      判断是否等于0\r\n\r\n   COBOL支持NOT ,AND ,OR 操作。\r\n\r\nPERFORM\r\n    过程调用，但是不传递参数。\r\n  PERFORM PROC1 [THROUGH PROC2]  \r\n    执行完PROC1再执行PROC2.没有THROUGH(THRU)就只执行PROC1.\r\n  PERFORM PROC1 [THRU PROC2] N TIMES\r\n    执行PROC1[或者还有PROC2]N次。\r\n  PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] UNTIL A NOT EUQAL 0.\r\n    执行PROC1[或者还有PROC2]直到A不等于0。WITH TEST BEFORE/AFTER指定在第一次执行之前还是之后判断条件。默认是BEFORE，执行之前判断。\r\n  PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 [AFTER D FROM E BY F UNTIL CONDITION2].\r\n    相当于FOR循环，将A的值从B开始，以C为单位递增，直到满足CONDITION1。AFTER语句是一个嵌套的FOR 循环。VARYING是外循环，AFTER是内循环。A，B可以是索引。\r\n\r\n   过程也可以直接写入PERFORM中。但是THROUGH就不好用了。语法如下 ：\r\n  PERFORM 过程语句 END-PERFORM.\r\n  PERFORM N TIMES 过程语句 END-PERFORM.\r\n  PERFORM [WITH TEST BEFORE/AFTER] UNTIL CONDITION 过程语句 END-PERFORM.\r\n  PERFORM [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 过程语句 END-PERFORM.\r\n\r\nIF语句\r\n  IF CONDITION THEN STATEMENTS1/NEXT SENTENCE ELSE STATEMENTS2 END-IF/NEXT SENTENCE/ENDIF\r\n    NEXT SENTENCE将跳出IF操作语句执行下一条语句。\r\n    IF语句中不要使用.句号。.句号将结束所有IF语句。要结束一个嵌套的IF语句，可以使用END-IF或者NEXT SENTENCE.如\r\n    IF A IF B END-IF ELSE C END-IF.或者\r\n    IF A IF B ELSE NEXT SENTENCE ELSE C END-IF.\r\n\r\nEVALUATE\r\n    相当于SWITCH CASE语句。\r\n    EVALUATE A\r\n        WHEN B ...\r\n        WHEN 0 THRU 100 ...(FROM 0 TO 100)\r\n        WHEN OTHER ...\r\n    [END-EVALUATE]\r\n    首先得到A的结果，和WHEN语句的参数比较，如果和B相等，就执行B后的操作，执行完了不再执行后面的WHEN语句。如果不等就执行下一条WHEN语句。如果没有相等的就执行WHEN OTHER语句。\r\n    EVALUATE A ALSO B\r\n        WHEN C ALSO D ...\r\n        WHEN E ALSO F ...\r\n        WHEN OTHER ...\r\n    对于有多个判断条件的，要多个条件同时满足。如上要C=A同时D=B，才执行WHEN语句。\r\n\r\nCONTINUE\r\n    继续执行下面的程序。\r\n\r\nGO TO \r\n    GO TO PROC1 [DEPENDING ON N] DEPENDING ON N将跳转到清单中的第N个PROC.\r\n\r\nEXIT\r\n    一般为最后一句话。\r\n\r\nSTOP\r\n    STOP RUN  结束程序。\r\n\r\nALTER \r\n    ALTER PROC1 TO PROC2. 不懂什么意思，反正已经从标准中废除了这个语句。\r\n\r\nENTER\r\n    使其他编程语言中的语句可以放进当前源程序中。\r\n    ENTER LANGUAGE-NAME [ROUTINE-NAME]\r\n    LANGUAGE 是厂家指定可以输入COBOL的任何语言，这个语句后面是其他编程语言的语句，然后要用ENTERCOBOL表示返回COBOL语言。\r\n    如果无法将其他语言的程序直接放入，可以用ROUTINE-NAME引用其他语言编写的程序。\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n\r\nCOBOL <wbr> <wbr>知识点集锦（下） cobol程序格式\r\ncobol源程序的格式如下：\r\n     每行开头有6个字符的序号区。可以输入000010，000020等表示行，也可以不输。\r\n     序号区后面是一个字符（第7位）的指示符区，如第一行所示。可以用*和/表示注释，_表示续行，D表示调试。\r\n     指示符区后面是4个字符（8~11位）的A区。可以放入部，节，段标题，段名，层指示符和层号01与77，\r\n            关键字DECLARATIVES和END DECLARATIVES,程序结束标题。\r\n     A区后面（12位以后）是语句体，称为B区。过程部的语句必须从B区开始。B区宽度通常为72或80个字符。\r\n            本例是70个字符。\r\n     空行的每个区都是空格\r\n\r\n标识部（2~4行），PROGRAM-ID段包含程序名，是每个程序都必须的。AUTHOR等其他段是可有可无的。\r\n          \r\n环境部（5~15行），提供与程序外部有关的项目，具体地说，就是列出程序所用的文件。如果不需要可以省略。\r\n     环境部有配置节（6~10行）和输入输出节（11~15行）。\r\n     第7行表示编译程序的计算机。如果指定WITH DEBUGGING MODE就编译调试行。\r\n     第8行表示程序运行的计算机。\r\n     第9，10行包含一组指定输出样式。这里是标准输出，可以自定义。\r\n     输入输出节只用于文件。\r\n     第13到15行表示如果程序使用文件，则这个段对每个文件包含一个项目。\r\n     文件控制项目的格式取决于文件的描述类型。\r\n          \r\n数据部（16~22行），提供程序变量的存放位置，对不同的数据类型分成不同的节：文件数据（File Section）、静态数据（Working-Storage Section）、参数（Linkage Section）、通信（Communication Section）、报表（Report Section）。\r\n     文件节（18~21行），每个文件描述中包含文件所含纪录的定义，文件节中的数据或从文件读取，\r\n         或由写文件的程序产生。\r\n     第22行表示工作存储节，这节包含程序所需的临时结果和初始化静态数据的数据。\r\n     参数（Linkage Section）包含调用程序传递的数据（其他语言中称为参数）。\r\n     通信（Communication Section）,处理COBOL程序和通信设备之间的消息。\r\n     报表（Report Section），报表节实现COBOL报告编写工具系统所需的数据。\r\n     第20，21行的PIC是PICTURE的缩写，表示定义数据格式。\r\n          X(12)表示12个字符的字符串，9(09)表示9位的整数。\r\n     可以将基本项目组成层次结构，称为组数据项或组。\r\nCOBOL程序中的数据项的定义从层号开始，01层是最高层，49层是最低层。\r\n     77层项目用于某个组的数据项，如程序中的临时变量。\r\n          66层是为特殊描述符项目保留的，可以更名现有的数据项或组，或以原定义未允许的方式组合。\r\n          88层是对特殊数据项目条件名保留的\r\n          如：\r\n          03 STATE PIC XX.\r\n          88 NEW-ENGLAND VALUES ARE \"1\",\"2\",\"3\",\"4\",\"5\".\r\n          IF NEW-ENGLAND ... then do something\r\n          \r\n过程部（23~30行），包含构成程序的过程性语句。\r\n          带DECLARATIVES的过程部。有些程序用特殊的USE语句表示遇到特殊条件时要执行的过程，\r\n                 如发生I/O错误时。\r\n                 USE语句组合在一起，放在过程部开头，由关键字DECLARATIVES和END DECLARATIVES限定。\r\n          第24行相当于定义了一个名字叫ACAB030100-PROC（）的函数。\r\n          第25，29行定义了标志，可以用GO TO 语句跳转到这个地方，执行下面的语句。\r\n          第26行在屏幕上打印，相当于printf(\"ACAB030100-START\");\r\n          第27行是调用ACAB030100-PROC（）函数。\r\n          \r\ncobol程序的要求：必须以英文句号.结束部标题、节标题、段名、项目和语句。\r\n         句号为小数点时，两边都要有数字。\r\n\r\n\r\nCOBOL <wbr> <wbr>知识点集锦（下） cobol文件操作\r\n要在COBOL中使用文件，要在3个不同的部中放上信息。\r\n    环境部，要有程序使用的每个文件的文件控制项目(FILE-CONTROL)。这个项目将程序中使用的文件名与程序外的实际文件联系起来。这些项目还定义文件的组织和访问方式。\r\n    数据部，要有每个文件的文件描述符(FD)项目，就是数据定义。\r\n    过程部，放上处理语句，OPEN,READ,WRITE,DELETE等。\r\n\r\n   环境部中主要是FILE-CONTROL和I-O-CONTROL.I-O-CONTROL很少使用。\r\n    SELECT [OPTIONAL] file-name ASSIGN TO DEV/FILE \r\n    [RESERVE N [AREA/AREAS]]\r\n    [FILE STATUS IS VAR]\r\n    SELECT必须是第一句，其他顺序无关。file-name是程序中传递使用的文件名，相当于实际文件的一个别名。OPTIONAL用于执行可能不存在的文件。\r\n    ASSIGN将file-name连接到实际的外部设备或文件。（TO好像可以省略。）\r\n    RESERVE指定文件缓冲区。\r\n    FILE STATUS指定一个变量存放文件状态，这个变量应该已在WORKING-STORAGE SECTION中定义。\r\n\r\n   对于顺序文件，还有声明如下：\r\n    [ORGANIZATION IS SEQUENTIAL]               可选，缺省为顺序组织文件\r\n    [ACCESS MODE IS SEQUENTIAL]                可选。顺序文件只允许顺序访问\r\n    [PADDING CHARACTER IS char]                指定文件在固定块长设备上时键块所用的字符，char为一个字符的数据项。\r\n    [RECORD DELIMITER IS STANDARD/usr-define]  指定如何确定变长纪录的长度。\r\n    顺序文件例子：\r\n    SELECT file-name ASSIGN TO \"/usr/file1\"\r\n    FILE STATUS IS file-status\r\n\r\n   对于相对文件，还有声明如下：\r\n    [ORGANIZATION IS RELATIVE]               是相对文件必须的\r\n    [ACCESS MODE IS SEQUENTIAL [RELATIVE KEY IS data]] 或者\r\n    [ACCESS MODE IS RANDOM/DYNAMIC RELATIVE KEY IS data] \r\n    访问方式有3种，缺省是SEQUENTIAL。\r\n    RELATIVE KEY 可选。如果存在，则文件读取操作顺利完成后，data用所读取纪录的关键字更新。data应为文件的纪录区中没有的整数数据项。\r\n    相对文件的例子：\r\n    SELECT file-name ASSIGN TO \"/usr/file2\"\r\n    ORGANIZATION IS RELATIVE\r\n    ACCESS MODE IS DYNAMIC RELATIVE KEY IS DAY-NUMBER\r\n    FILE STATUS IS file-status\r\n\r\n   对于索引文件，还有声明如下：\r\n    [ORGANIZATION IS INDEXED]               是索引文件必须的\r\n    [ACCESS MODE IS SEQUENTIAL/RANDOM/DYNAMIC] RECORD KEY IS data1\r\n    [ALTERNATE RECORD KEY IS data2 [WITH DUPLICATES]] \r\n    访问方式有3种，缺省是SEQUENTIAL。\r\n    RECORD KEY 指定文件的主纪录关键字，data1应为定义该文件的某个记录区的字母数字数据项目。这个关键字的描述及其在数据记录中的位置应该与生成文件时所用的关键字一致。\r\n    ALTERNATE RECORD KEY 如果文件有替换关键字，则其关键字用这个从句的短语指定，索引中允许重复关键字时采用DUPLICATES.COBOL要求文件记录中定义data2。重复关键字的长度及其在数据记录中的位置应该与生成文件时一致，所有替换关键字应放在文件控制项中。\r\n   索引文件的例子：\r\n    SELECT file-name ASSIGN TO \"/usr/file3\"\r\n    ORGANIZATION IS INDEXED\r\n    ACCESS MODE IS RANDOM\r\n    RECORD KEY IS NUMBER OF EMPLOYEE-RECORD\r\n    ALTERNATE RECORD KEY IS LAST-NAME OF EMPLOYEE-RECORD WITH DUPLICATES\r\n    ALTERNATE RECORD KEY IS SS-NUMBER OF EMPLOYEE-RECORD\r\n    FILE STATUS IS file-status\r\n    这里用户在程序中使用的文件名是file-name，实际文件名是file3。file-name的定义放在程序后边的数据部的文件节中。文件是索引文件，程序可以随机访问文件。文件的主关键字是NUMBER OF EMPLOYEE-RECORD，替换关键字是LAST-NAME和SS-NUMBER，都是文件记录区的字段。LAST-NAME允许重复。\r\n\r\n   文件状态：(对文件操作时返回文件状态到定义的文件状态变量)\r\n    ANY            00 成功\r\n    ANY            02 对索引文件，成功但发现重复关键字\r\n    READ           04 成功，但纪录长度不符合指定长度\r\n    OPEN           05 成功，但文件是可选的，前面不存在\r\n    OPEN,CLOSE     07 对顺序文件，成功，但媒介不是盘\r\n    READ           10 文件已到末尾\r\n    READ           14 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位\r\n    WRITE,REWRITE  21 对索引文件，顺序出错\r\n    WRITE          22 对索引和相对文件，带这个关键字的纪录已经存在\r\n    START,READ     23 对索引和相对文件，带这个关键字的纪录不存在\r\n    WRITE          24 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位\r\n    ANY            30 I/O错误\r\n    WRITE          34 对顺序文件，发生超边界错误\r\n    OPEN           35 对顺序和相对文件，未发现非可选文件\r\n    OPEN           37 对顺序和相对文件，该文件不支持指定的打开方式\r\n    OPEN           38 对顺序和相对文件，文件已经用锁关闭\r\n    OPEN           39 对顺序和相对文件，文件属性不支持程序中指定的属性\r\n    OPEN           41 文件已经打开\r\n    CLOSE          42 文件未打开\r\n    DELETE,REWRITE 43 最近的操作不是READ\r\n    WRITE,REWRITE  44 纪录长度非法\r\n    READ           46 没有有效的下一个记录\r\n    READ,START     47 文件未在INPUT或I-O方式中打开\r\n    WRITE          48 文件未在OUTPUT或EXTEND方式中打开\r\n    DELETE,REWRITE 49 文件未在I-O方式中打开\r\n    ANY            90~99 厂家定义\r\n\r\n   由上可知，文件操作时会发生错误，COBOL提供了检查错误和恢复I/O错误的公用地点。过程部开头应包括DECLARATIVES部分，放上出现错误时要执行的语句。\r\n    PROCEDURE DIVISION.\r\n    DECLARATIVES.\r\n    section-name SECTION.\r\n    USE statement(出现错误时调用的节).\r\n      paragraph-name.\r\n        sentence...\r\n    END DECLARATIVES.\r\n    section-name SECTION.\r\n      paragraph-name.\r\n        sentence...\r\n   USE AFTER STANDARD EXCEPTION/ERROR PROCEDURE ON file-name/INPUT/OUTPUT/I-O/EXTEND\r\n    只能在USE语句中指定一个文件，一种方式也只能有一个USE语句。如果既指定了文件，也指定了方式，则文件优先。\r\n\r\n   程序使用的所有文件要定义在数据部的第一节----文件节中。\r\n    FD file-name    \r\n    [BLOCK CONTAINS int-1 [TO int-2] RECORDS/CHARACTERS]\r\n    [RECORD (CONTAINS int-3 [TO int-4] CHARACTERS)/(IS VARYING IN SIZE [FROM int-5] [TO int-6] CHARACTERS)/(DEPENDING ON data1)\r\n    [LABEL (RECORD IS)/(RECORDS ARE) STANDARD/OMITTED]\r\n    [VALUE OF (implementor-name IS id-lit-1)...]\r\n    [DATA (RECORD IS)/(RECORDS ARE) data2]\r\n    BLOCK CONTAINS 指定实际纪录的具体长度或最大与最小长度的逻辑记录数或块数。一般有操作系统和文件系统指定。\r\n    RECORD 指定包含变长纪录的文件中记录的最大与最小长度或定长纪录的具体长度。\r\n    RECORD CONTAINS 如果不带TO，则int-3是每个纪录的长度；如果带TO,介于int-3和int-4之间。\r\n    RECORD IS VARYING 指定纪录长度最小int-5和最大int-6。\r\n    DEPENDING ON 如要用，则需要在data1中保存纪录长度。\r\n    LABEL RECORD 指定文件是否带标号。（过时，下个版本不包含）\r\n    VALUE 和LABEL一起检查标号的不同部分。（过时，下个版本不包含）\r\n    DATA RECORD 指定属于文件的纪录描述项（FD后的01层项目）并作为程序文档。（过时，下个版本不包含）\r\n    一般定义文件只用第一句：FD file-name\r\n  顺序文件的LINAGE声明\r\n    对顺序文件，LINAGE声明可以在文件输出是打印机或打印机兼容文件时指定一些打印细节。\r\n    [LINAGE IS BODY LINES [WITH FOOTING AT FOOT][LINES AT TOP TOP][LINES AT BOTTOM BOTTOM]] [CODE-SET IS alphabet-name]\r\n    整个文件分成TOP,BODY,BOTTOM三部分。其中BODY包含有FOOT.\r\n    CODE-SET指定文件中所用的字符集。\r\n\r\n   过程部主要是对文件的OPEN,CLOSE,READ,WRITE,START,REWRITE,DELETE等操作。\r\nOPEN\r\n    OPEN文件有4种方式：（如果文件声明为OPTIONAL，则文件不存在会创建文件，否则会报错）\r\n    OPEN INPUT FILE-NAME.    只能读取的文件。\r\n    OPEN OUTPUT FILE-NAME.   生成写入纪录的文件，读取该文件会出错。若文件已存在，已有记录会被全部删除。\r\n    OPEN I-O FILE-NAME.      可读可写的文件。\r\n    OPEN EXTEND FILE-NAME.   生成写入的文件。与UOTPUT的区别在于，若文件已存在，EXTEND将纪录加在文件末尾。\r\n    如果OPEN不成功，执行USE语句。USE语句不存在，则程序结束。\r\n    顺序文件的OPEN可以有以下方式：\r\n    OPEN INPUT FILE-NAME [(WITH NO REWIND)/REVERSED].\r\n    OPEN OUTPUT FILE-NAME [WITH NO REWIND].   \r\n    REVERSED可以逆序处理，即由后向前处理。（过时，下个版本不包含）\r\n    WITH NO REWIND 用于单卷磁带文件，如果指定文件在不适用REWIND的媒介上，忽略。\r\n    在文件描述项中指定LINAGE得顺序文件不能用EXTEND方式打开。\r\n\r\nCLOSE\r\n    所有文件的CLOSE方法：\r\n    CLOSE FILE-NAME.    关闭文件。\r\n    CLOSE FILE-NAME WITH LOCK.    关闭文件，不退出程序不能再打开此文件。\r\n    顺序文件还有其他一些选项,如关闭卷或单元，和继续处理文件：\r\n    CLOSE file-name [REEL/UNIT] [FOR REMOVAL]/WITH NO REWIND\r\n\r\nREAD\r\n    顺序访问方式读文件。一定要有NEXT字样。\r\n    READ file-name [NEXT] RECORD [INTO data1]\r\n    [AT END statements][NOT AT END statements] [END-READ]\r\n    如果READ成功且有INTO，将读到的数据写入data1。\r\n    如果文件中没有记录，执行AT ENDstatements，如果没有就执行USE。\r\n    如果READ成功，就执行NOT AT END statements。\r\n\r\n   动态访问方式读文件。(相对或索引文件)\r\n    利用OPEN语句，将文件指针设在开头。\r\n    进行各种成功的READ操作。\r\n    有START语句标识文件中的纪录。\r\n\r\n   随机访问方式读文件。\r\n    READ file-name RECORD [INTO data1]\r\n    [INVALID KEY statements][NOT INVALID KEY statements] [END-READ]\r\n    如果READ成功且有INTO，将读到的数据写入data1。\r\n    如果文件中没有记录，执行INVALID KEY statements，如果没有就执行USE。\r\n    如果READ成功，就执行NOT INVALID KEY statements。\r\n    如果是相对文件，要设置文件控制项RELATIVE KEY中指定的整型关键字值后才能执行READ.\r\n    如果是索引文件，要设置当前索引的关键字值后才能执行READ.\r\n\r\nWRITE\r\n    顺序方式。\r\n    WRITE data [FROM data1] [BEFORE/AFTER ADVANCING mnemonic-name/PAGE/N LINE(LINES)]\r\n    [AT END-OF-PAGE(EOP) statements][NOT AT END-OF-PAGE(EOP) statements][END-WRITE]\r\n    如果指定了FROM，先将data1复制到data，再写入文件。\r\n    BEFORE/AFTER ADVANCING N LINE(LINES) 在纪录间插入N个空行。\r\n    AT END-OF-PAGE(EOP) 对于带LINAGE的文件有效，在WRITE使指针进入页脚(FOOT)时，先执行WRITE，再执行AT END-OF-PAGE(EOP) statements。\r\n\r\n   相对和索引文件方式。\r\n    WRITE data [FROM data1]\r\n    [INVALID KEY statements][NOT INVALID KEY statements] [END-WRITE]\r\n\r\nREWRITE\r\n    替换文件中的一个记录。\r\n    顺序方式：REWRITE data [FROM data1] [END-REWRITE]\r\n    相对和索引方式：\r\n    REWRITE data [FROM data1]\r\n    [INVALID KEY statements][NOT INVALID KEY statements] [END-REWRITE]\r\n\r\nDELETE\r\n    删除文件中的一个记录。只能用于相对或索引组织的文件。\r\n    DELETE file-name RECORD\r\n    [INVALID KEY statements][NOT INVALID KEY statements] [END-DELETE]\r\n    顺序访问方式的话，前一个READ的纪录被删除。\r\n    随机或动态访问的话，RELATIVE KEY的内容或主关键字所表示的纪录从文件中删除。\r\n\r\nSTART\r\n    将相对或索引文件定位到某个纪录，以便对其进行顺序访问。只对相对和索引文件有效。\r\n    START file-name [KEY IS (EQUAL TO)/=/GREATER THAN/>/NOT LESS THAN/NOT < data]\r\n    [INVALID KEY statements][NOT INVALID KEY statements] [END-START]\r\n    如果执行成功，则data所属的索引变成文件的当前索引。\r\n    对于相对文件，data定义为文件的RELATIVE KEY的数据项。\r\n    对于索引文件，data为下列之一：\r\n    文件的主关键字，是RECORD KEY从句中指定的数据项。\r\n    文件的替换关键字，是ALTERNATE RECORD KEY从句指定的数据项。\r\n    从一个关键字的第一个位置开头，长度小于或等于该关键字的数据项。\r\n\r\n\r\nCOBOL <wbr> <wbr>知识点集锦（下） cobol数组操作\r\n下面是数组的例子：\r\n          01 RECORD-X.\r\n            03 MONTH OCCURS 12 TIMES.\r\n              05 NAME PIC X(12).\r\n              05 DAYS OCCURS 31 TIEMS.\r\n                07 COMMENT PIC X(20).\r\n                07 TEMP-HI PIC S999.\r\n                07 TEMP-LO PIC S999.\r\n          77 CURRENT-DAY PIC 99.\r\n          调用表示如下：\r\n          MONTH(5) : 包含NAME 和 DAYS表格的组项目。\r\n          NAME OF MONTH(5) :基本字母数字项目，长度为12个字符。\r\n          NAME(5) (1:3) 上述第5个项目的前3个字符。\r\n          TEMP-HI(1,31) 基本数字项目，长度为3个字符。前一个参数是在MONTH数组中的位置，后一个参数是在DAYS数组中的位置。相当于MONTH[1].DAYS[31].TEMP-HI。\r\n          COMMENT OF RECORD-X(5,CURRENT-DAY)(11) 基本字母数字项目第五个月的CURRENT-DAY的COMMENT字段的最后10个字符。\r\n\r\n   03 TEXT PIC XXX OCCURS 1 TO 12 TIMES DEPENDING ON IX.\r\n   定义一个变长的数组。定义的长度是12，实际以IX为准，若IX为10，则TEXT的长度就是30。\r\n\r\n索引\r\n  索引名INDEX\r\n    索引名可以用作PERFORM语句的变量，用于SET和SEARCH语句和用作下标。\r\n    03 TEXT PIC XXX OCCURS 7 TIMES INDEXED BY index\r\n      05 A PIC XXX\r\n      05 B PIC XXX\r\n    PERFORM VARYING index FROM 1 BY 1 UNTIL index >7\r\n      DISPLAY A(index),B(index)\r\n    END-PERFORM.\r\n    注意和不用索引名的比较：\r\n    77 index PIC 99\r\n    03 TEXT PIC XXX OCCURS 7 TIMES\r\n      05 A PIC XXX\r\n      05 B PIC XXX\r\n    PERFORM VARYING index FROM 1 BY 1 UNTIL index >7\r\n      DISPLAY A(index),B(index)\r\n    END-PERFORM.\r\n\r\n  关键字KEY\r\n    关键字有ASCENDING(升序，由低到高)和DESCENDING(降序，由高到低)。\r\n      03 TEXT PIC XXX OCCURS 7 TIMES ASCENDING KEY IS A,B.\r\n      05 A PIC XXX.\r\n      05 B PIC XXX.\r\n    TEXT中的元素按A升序排序，A相同的元素按B升序排序。\r\n    关键字的作用是定义SEARCH语句带ALL短语时表格的排序。\r\n\r\n  表格初始化，可以一个一个数据项单独初始化，也可以一起初始化。\r\n      03 TEXT PIC XXX OCCURS 7 TIMES VALUES SPACE.\r\n      05 A PIC XXX.\r\n      05 B PIC XXX.                          一起初始化为空格。\r\n      03 TEXT PIC XXX OCCURS 7 TIMES.\r\n      05 A PIC XXX VALUES SPACE.\r\n      05 B PIC XXX VALUES SPACE.            单独初始化。\r\n\r\nSET\r\n    保存或恢复索引值。SET A TO B.\r\n    将索引递增或递减一个整数值。SET A UP/DOWN BY N.\r\n\r\nSEARCH\r\n    SEARCH A [VARYING B] AT END C {WHEN CONDITION D}...END-SEARCH\r\n    A为带INDEXED BY 短语的表格。每一步都轮流求值CONDITION ,为真时执行D,SEARCH语句终止。    为假时，索引值递增，至最大索引时执行AT END C,SEARCH语句终止。\r\n    若一开始索引值即为最大，则不执行WHEN语句，直接执行AT END 语句。\r\n    VARYING 指定索引B，省略为A中制定的索引。\r\n    下面的例子查找月份表中下一个具有31天的月份。\r\n    01 MONTH-DATA.\r\n      03 MONTH-INFO.\r\n        05 PIC X(10) VALUES \"JANUARY\".\r\n        05 PIC X(3) VALUES \"JAN\".\r\n        05 PIC 99 VALUES 31.\r\n        05 PIC X(10) VALUES \"FEBRUARY\".\r\n        05 PIC X(3) VALUES \"FEB\".\r\n        05 PIC 99 VALUES 28.\r\n        ...(省略代码)\r\n      03 MONTH REDEFINES MONTH-INFO OCCURS 12 TIMES INDEXED BY MONTH-INDEX.\r\n        05 NAME   PIC X(10).\r\n        05 ABBREV PIC X(3).\r\n        05 DAYS   PIC 99.\r\n    77 CURRENT-MONTH PIC 99.\r\n    77 NEXT-31-DAY-MONTH PIC 99.\r\n\r\n   SET MONTH-INDEX TO CURRENT-MONTH.\r\n    SET MONTH-INDEX UP BY 1.\r\n    SEARCH MONTH\r\n        AT END MOVE 1 TO MONTH-INDEX\r\n            SEARCH MONTH \r\n                AT END MOVE 0 TO NEXT-31-DAY-MONTH\r\n                WHEN DAYS(MONTH-INDEX) = 31\r\n                    SET NEXT-31-DAY-MONTH TO MONTH-INDEX\r\n            END-SEARCH\r\n        WHEN DAYS(MONTH-INDEX) = 31\r\n            SET NEXT-31-DAY-MONTH TO MONTH-INDEX\r\n    END-SEARCH\r\n    要查找多维表格，要将SEARCH放到PERFORM中。\r\n    01 TABLE-DATA.\r\n      03 DIM-1 OCCURS 10 TIMES INDEXED BY X1.\r\n        05 DIM-2 OCCURS 20 TIMES INDEXED BY X2.\r\n          07 NAME PIC X(20).\r\n          07 STATE PIC XX.\r\n          ...\r\n    PERFORM VARYING X1 FROM 1 BY 1 UNTIL X1 > 20 \r\n        SET X2 TO 1\r\n        SEARCH DIM-2\r\n            WHEN STATE(X1,X2) = \"AL\" ....\r\n            WNEH STATE(X1,X2) = \"AZ\" ....\r\n        END SEARCH\r\n    END-PERFORM.\r\n    还有一种SEARCH是对有关键字的表格进行查找，和上面的查找差不多，主要是WHEN 条件中要用关键字作为查找条件。比如说关键字为A，则必须有WHEN A = .....\r\n\r\n \r\n\r\n \r\n\r\n\r\nCOBOL <wbr> <wbr>知识点集锦（下） cobol子程序调用\r\n内部子程序\r\n    IDENTIFICATION DIVISION.\r\n    PROGRAM-ID. PROC-A.\r\n    ENVIRONMENT DIVISION.\r\n    ...\r\n    DATA DIVISION.\r\n    ...\r\n    PROCEDURE DIVISION.\r\n    ...\r\n       IDENTIFICATION DIVISION.\r\n       PROGRAM-ID. PROC-B.\r\n       ENVIRONMENT DIVISION.\r\n       ...\r\n       DATA DIVISION.\r\n       ...\r\n       PROCEDURE DIVISION.\r\n       ...\r\n       END PROGRAM PROC-B.\r\n       IDENTIFICATION DIVISION.\r\n       PROGRAM-ID. PROC-C.\r\n       ENVIRONMENT DIVISION.\r\n       ...\r\n       DATA DIVISION.\r\n       ...\r\n       PROCEDURE DIVISION.\r\n       ...\r\n           IDENTIFICATION DIVISION.\r\n           PROGRAM-ID. PROC-D.\r\n           ENVIRONMENT DIVISION.\r\n           ...\r\n           DATA DIVISION.\r\n           ...\r\n           PROCEDURE DIVISION.\r\n           ...\r\n           END PROGRAM PROC-D.\r\n       END PROGRAM PROC-C.\r\n    END PROGRAM PROC-A.\r\n    程序A包含B,C两个子程序，其中C又包含子程序D。\r\n    A能调用B，C。C能调用D。B不能调用C，A不能调用D。\r\n    如果C声明为公用的，则B可以调用C，语法为：\r\n    PROGRAM-ID. PROC-C IS COMMON PROGRAM.\r\n\r\n   当前函数中定义的变量都只是对当前函数有效。可以用GLOBAL声明为对所有函数有效。\r\n    01 DATA-NAME IS GOLBAL ...\r\n    文件也有此声明：FD FILE-NAME IS GOLBAL ...\r\n\r\n   如果调用的不是本程序中的文件或变量，则可以用EXTERNAL声明。\r\n    FD FILE-NAME IS EXTERNAL.../01 DATA-NAME IS EXTERNAL...\r\n\r\n   CALL PROC VAR1 [ON EXCEPTION CODE1] [NOT ON EXCEPTION CODE2] END-CALL.\r\n    如果找不到PROC程序名，执行CODE1(如果有此声明)，找到将参数VAR1传递给PROC，并执行。PROC返回时执行CODE2(如果有此声明)。\r\n    参数应该在文件，工作存储或连接节中定义，应为01层数据项，77层数据项或基本数据项。\r\n    子程序要返回调用程序，执行EXIT PROGRAM\r\n\r\n   传递参数有3步:\r\n    首先在调用程序的CALL语句列出要传递的参数。\r\n    CALL PROC VAR1 .\r\n    然后在被调用程序的过程部标题，使用USING短语列出相应的参数。\r\n    PROCEDURE DIVISION USING VAR1.\r\n    最后在被调用程序的连接节(LINKAGE SECTION)提供参数的存储空间。 \r\n    LINKAGE SECTION.\r\n    01 VAR1 PIC XX.\r\n\r\n   参数传递有2中方式:\r\n    BY CONTENT    传递的参数值只在被调用函数中被改变，调用函数中的值不变。\r\n    BY REFERENCE. 传递的参数值在被调用函数中被改变，调用函数中的值也改变。\r\n    CALL PROC VAR1 BY CONTENT/REFERENCE.\r\n\r\n   再次调用子程序，子程序处于上次退出的状态（除了连接节中的数据），打开的文件依然打开。\r\n    可以用INITIAL声明函数被调用时处于初始状态。\r\n    PROGRAM-ID. PROC-C IS INITIAL PROGRAM.\r\n\r\n   如果不想每次执行都初始化，只在需要的时候初始化，可以用CANCEL PROC.初始化PROC程序，但不执行PROC。\r\n\r\nhttp://blog.sina.com.cn/s/blog_6a5ecd650100qrt4.html', '<p>COBOL <wbr> <wbr>知识点集锦（下） cobol子程序调用<br>内部子程序<br>    IDENTIFICATION DIVISION.<br>    PROGRAM-ID. PROC-A.<br>    ENVIRONMENT DIVISION.<br>    …<br>    DATA DIVISION.<br>    …<br>    PROCEDURE DIVISION.<br>    …<br>       IDENTIFICATION DIVISION.<br>       PROGRAM-ID. PROC-B.<br>       ENVIRONMENT DIVISION.<br>       …<br>       DATA DIVISION.<br>       …<br>       PROCEDURE DIVISION.<br>       …<br>       END PROGRAM PROC-B.<br>       IDENTIFICATION DIVISION.<br>       PROGRAM-ID. PROC-C.<br>       ENVIRONMENT DIVISION.<br>       …<br>       DATA DIVISION.<br>       …<br>       PROCEDURE DIVISION.<br>       …<br>           IDENTIFICATION DIVISION.<br>           PROGRAM-ID. PROC-D.<br>           ENVIRONMENT DIVISION.<br>           …<br>           DATA DIVISION.<br>           …<br>           PROCEDURE DIVISION.<br>           …<br>           END PROGRAM PROC-D.<br>       END PROGRAM PROC-C.<br>    END PROGRAM PROC-A.<br>    程序A包含B,C两个子程序，其中C又包含子程序D。<br>    A能调用B，C。C能调用D。B不能调用C，A不能调用D。<br>    如果C声明为公用的，则B可以调用C，语法为：<br>    PROGRAM-ID. PROC-C IS COMMON PROGRAM.\r\n<p>   当前函数中定义的变量都只是对当前函数有效。可以用GLOBAL声明为对所有函数有效。<br>    01 DATA-NAME IS GOLBAL …<br>    文件也有此声明：FD FILE-NAME IS GOLBAL …\r\n<p>   如果调用的不是本程序中的文件或变量，则可以用EXTERNAL声明。<br>    FD FILE-NAME IS EXTERNAL…/01 DATA-NAME IS EXTERNAL…\r\n<p>   CALL PROC VAR1 [ON EXCEPTION CODE1] [NOT ON EXCEPTION CODE2] END-CALL.<br>    如果找不到PROC程序名，执行CODE1(如果有此声明)，找到将参数VAR1传递给PROC，并执行。PROC返回时执行CODE2(如果有此声明)。<br>    参数应该在文件，工作存储或连接节中定义，应为01层数据项，77层数据项或基本数据项。<br>    子程序要返回调用程序，执行EXIT PROGRAM\r\n<p>   传递参数有3步:<br>    首先在调用程序的CALL语句列出要传递的参数。<br>    CALL PROC VAR1 .<br>    然后在被调用程序的过程部标题，使用USING短语列出相应的参数。<br>    PROCEDURE DIVISION USING VAR1.<br>    最后在被调用程序的连接节(LINKAGE SECTION)提供参数的存储空间。<br>    LINKAGE SECTION.<br>    01 VAR1 PIC XX.\r\n<p>   参数传递有2中方式:<br>    BY CONTENT    传递的参数值只在被调用函数中被改变，调用函数中的值不变。<br>    BY REFERENCE. 传递的参数值在被调用函数中被改变，调用函数中的值也改变。<br>    CALL PROC VAR1 BY CONTENT/REFERENCE.\r\n<p>   再次调用子程序，子程序处于上次退出的状态（除了连接节中的数据），打开的文件依然打开。<br>    可以用INITIAL声明函数被调用时处于初始状态。<br>    PROGRAM-ID. PROC-C IS INITIAL PROGRAM.\r\n<p>   如果不想每次执行都初始化，只在需要的时候初始化，可以用CANCEL PROC.初始化PROC程序，但不执行PROC。</p>\r\n<p>cobol 知识点集锦<br>COBOL <wbr> <wbr>知识点集锦（下） COBOL数据类型<br>        计息是银行的一项重要业务，包括日常代理客户收、付计算客户利息和年度计息等。目前，这些工作大多数是在IBM ES9000主机的SAFE应用系统平台上进行，该系统联机程序和联机计息程序是用IBM 370汇编语言实现的。为方便汇编语言读写，在VSAM文件存储的数据中，数据存放格式进行了特殊的定义。如日期存放采用X(3)型，01年03月15日，存入EBCD码为X‘010315’。在进行年度计息时，为了实现各种复杂的运算工作，一般采用COBOL语言来实现各种运算。而采用COBOL语言读取X(3)型数据时，读出的是字符型数据，不能直接进行运算，必须转换为COBOL数据类型的数据后才能进行相应处理。如刚才的X‘010315’，需要转换为内部十进制数据X‘0010315C’。本文介绍一种用COBOL语言实现字符型X(3)与内部十进制数据相互转换的方法。<br>由X(3)型转换为内部十进制<br>由于日期数据总是大于零，在COBOL语言的工作单元节定义变量DATE－FIRST后，再追加定义COBOL语言的最小数据单元X‘000C’，即十进制12。由于重定义DATE－CASE为DATE－CHANGE后，DATE－CHANGE是原日期数据的1000倍，于是要在过程部将DATE－CHANGE除以1000。<br>首先，在COBOL程序WORKING－STORAGE SECTION. 中定义如下内容：<br>WORKING－STORAGE SECTION.<br>01 DATE－CASE.<br>02 DATE－FIRST PIC X(3).<br>02 DATE－SIGN PIC 9(4) COMP VALUE 12.；定点二进制数<br>01 DATE－CHANGE REDEFINES DATE－CASE PIC 9(9) COMP－3. ；内部十进制数据<br>01 DATE－HEX PIC X（3）. ； 转换前数据<br>01 DATE－DEC PIC S9（7）COMP－3 . ； 转换后数据<br>然后，在过程部PROCEDURE DEVISION.中加入如下语句：<br>PROCEDURE DEVISION.<br>MOVE DATE－HEX TO DATE－FIRST .<br>COMPUTE DATE－CHANGE = DATE－<br>CHANGE / 1000.<br>MOVE DATE－CHANGE TO DATE－DEC.<br>由内部十进制转换为X(3)型<br>在进行相反的转换时，要消除因COBOL语言数据类型标志“C”引起的原日期数据前多加的一个0，所以需要将转换数据乘以10，再取出前6位数据即可。<br>首先，在COBOL程序WORKING－STORAGE SECTION. 中定义如下内容：<br>WORKING－STORAGE SECTION.<br>01 WORK－DATE PIC S9(7) COMP－3.<br>01 AA REDEFINES WORK－DATE.<br>02 A1 PIC X(3).<br>02 A2 PIC X(1).<br>01 DATE－HEX PIC X(3). ；转换后数据<br>01 DATE－DEC PIC S9(7) COMP－3.<br>；转换前数据<br>然后，在过程部PROCEDURE DEVISION.中加入如下语句即可：<br>PROCEDURE DIVISION.<br>MOVE DATE－DEC TO WORK－DATE。<br>COMPUTE WORK－DATE=WORK－DATE＊10.<br>MOVE A1 TO DATE－HEX .\r\n<p>COBOL <wbr> <wbr>知识点集锦（下） cobol语法<br>REDEFINES<br>    可以用不同的变量描述同一内存。<br>    01 PART_RECODE USAGE DISPLAY<br>       03 PART-TYPE PICTURE…<br>       03 PART_TYPE_A.<br>          05 PART_NUMBER PICTURE…<br>          05 PART_COST PICTURE…<br>       03 PART_TYPE_B REDEFINES PART_TYPE_A.<br>          05 UPC_CODE PICTURE…<br>       03 PART_TYPE_C REDEFINES PART_TYPE_A.<br>          05 ISBN PICTURE…<br>    根据PART_TYPE决定用PART_TYPE_A还是PART_TYPE_B还是PART_TYPE_C。<br>    规则：<br>        PART_TYPE_B和PART_TYPE_C长度不能大于PART_TYPE_A。<br>        数据项不能有VALUE。<br>        01层不能用REDEFINES.<br>        PART_TYPE_B和PART_TYPE_C中不能有OCCURS.\r\n<p>PICTURE<br>    定义基本项目的具体长度，格式，数据类型。可以简写成PIC.<br>    格式字符串最多30个字符，可以包含下列字符：<br>    A  字母A-Z,a-z,空格<br>    B  插入空格<br>    P  标量字符，代表字段中不显示的小数点位置<br>    S  代数符号，实际显示取决于项目的USAGE<br>    V  小数点位置<br>    X  任何字符<br>    Z  抑制前头的0并转换成空字符<br>    0  插入0<br>    9  数字0~9<br>    /  插入/<br>    ,  插入,(逗号不能作为字符串的最后一位，最后时逗号是分隔符)<br>    .  插入.\r\n<ul>\r\n<li>抑制前头的0并转换成*<ul>\r\n<li>正值插入+，负值插入-</li></ul>\r\n<ul>\r\n<li>正值插入空格，负值插入-<br>$  插入美元号<br>CR 正值插入两个空格，负值插入CR<br>DB 正值插入两个空格，负值插入DB<br>例子：<br>03 VAR PIC AAAAA.    VAR变量长度为5个字符，不能有数字，等价于03 STATE PIC A(5)。<br>输入ASDFG ,显示ASDFG<br>03 VAR PIC XXXXX.   VAR变量长度为5个任意字符。等价于03 FILLER PIC X(5)。<br>输入123AS ，显示123AS<br>03 VAR PIC 99/XXX/9999 长度11，输入05may2004,显示05/may/2004<br>03 VAR PIC 0ABXXX/9999 长度11，输入05may2004,显示05 may/2004<br>03 VAR PIC 9(3) 长度3，0~999之间。<br>03 VAR PIC 9(4)V99 长度6，0.00~9999.99之间。<br>03 VAR PIC S9(5)V99 长度7，-99999.99~99999.99之间。<br>03 VAR PIC 9(6)PPP 长度6，可以是1000，2000，…,999999000。输入1234，显示1000。<br>03 VAR PIC PPP999 长度3，0.000001~0.000999之间。输入123，显示0.000123。<br>03 VAR PIC ZZZ.99，输入100.50,显示100.50;输入-51.50,显示51.50;<br>输入0,显示.00.<br>03 VAR PIC $ZZZ.ZZ-，输入100.50,显示$100.50;输入-51.50,显示$51.50-;<br>输入0,显示<br>03 VAR PIC $<strong><em>,</em></strong>.99CR，输入1000,显示$<strong>1000.00;输入-1000,显示$</strong>1000.00CR;<br>输入0,显示$<strong><em>,</em></strong>.00;输入51.5,显示$<em>**,</em>51.50<br>03 VAR PIC<br>$,<br>$.99，输入100.50,显示$100.50;输入-100.50,显示$100.50;<br>输入0.777,显示$.77;输入0,显示$.00<br>03 VAR PIC $.$$$，输入1.00,显示$.00;输入0.65,显示$.65;<br>输入0,显示$.00;<br>03 VAR PIC $—，输入17.7,显示$17;输入-17.7,显示$-17;<br>   输入-5,显示$-5<br>03 VAR PIC $999.99+，输入100.50,显示$100.50+;输入-100.50,显示$100.50-;<br>03 VAR PIC 9(3)B9(3)，输入55,显示000 055;输入1000.78,显示001 000;<br>03 FILLER PIC X(44)，补上44个空位。</ul>\r\n</li></ul>\r\n<p>USAGE 表示基本或组数据的类型。有BINARY,COMPUTATIONAL(COMP),DISPLAY,INDEX,PACKED-DECIMAL.</p>\r\n<p>JUSTIFIED<br>    03 VAR1 PIC X(5) JUSTIFIED RIGHT.<br>    03 VAR2 PIC X(5).<br>    输入XYZ，VAR1显示的是”  XYZ”，VAR2显示的是”XYZ  “。\r\n<p>BLANK WHEN ZERO<br>    03 VAR PIC $999,999.99 BLANK WHEN ZERO.<br>    当字段值为0，这个项目设置为全部空格。\r\n<p>VALUE<br>    定义的时候就赋值。<br>    03 VAR PIC X(5) VALUE “ABCDE”.<br>    01 VAR VALUE ALL SPACES.<br>    03 VAR1 PIC XXX.<br>    03 VAR2 PIC XX.\r\n<p>算术语句<br>    COBOL中操作符执行顺序为：取正(+)、取负(-)最高级，指数操作(<em>*)其次，乘(</em>)、除(/)再其次，加(+)、减(-)最后。<br>    ROUNDED  舍入操作。<br>    77 A PIC 9V9 VALUE 9.1.<br>    77 B PIC 9.<br>      ADD 0.5 TO A GIVING B ON SIZE ERROR GO TO PROC1.<br>      ADD 0.5 TO A GIVING B ROUNDED ON SIZE ERROR GO TO PROC2.<br>      END-ADD.<br>ON SIZE ERROR 是当语句出现错误时执行的。本例中第一句话执行没有错误，所以ON SIZE ERROR<br>不执行PROC1.第二句话，当0.5加上9.1得到9.6，因为有ROUNDED,所以执行舍入操作，得到10。而B只有1位数字，所以发生错误，执行ON SIZE ERROR操作，跳转执行PROC2。<br>CORRESPONDING(CORR)    数据项同名时编写多条语句。ADD和SUBSTRACT有此选项。<br>    01 A.<br>       03 B.<br>          05 B1 PIC 999V99.<br>          05 B1 PIC 999V99.<br>          05 B1 PIC 999V99.<br>       03 C.<br>          05 B1 PIC 999V99.<br>          05 B1 PIC 999V99.<br>          05 B1 PIC 999V99.<br>则语句ADD CORR B TO C.相当于执行了下面3条语句。<br>    ADD B1 OF B TO B1 OF C.<br>    ADD B2 OF B TO B2 OF C.<br>    ADD B3 OF B TO B3 OF C.<br>组项目不一定要格式相同。一个组项目中的内容在另一个组项目中可以没有，数据项顺序也无关紧要。只是严格按照数据项名称对应。<br>    ADD A,B GIVING C. END-ADD.              将A,B相加放入C。<br>    SUBTRACT A,B FROM C. END-SUBTRACT.      从C中减去A,B.<br>    MULTIPLY A BY B GIVING C. END-MULTIPLY. 将A,B相乘放入C。<br>    DIVIDE A INTO B GIVING C. END-DIVIDE.   将B除于A的结果放入C.<br>    DIVIDE A BY B GIVING C. END-DIVIDE.     将A除于B的结果放入C.<br>    DIVIDE A BY B GIVING C REMAINDER D.     将A除于B的商放入C，余数放入D.<br>    D=A-B<em>C.<br>    77 C PIC S99V9.<br>    77 D PIC S99V9.<br>    DIVIDE 3 INTO 7 GIVING C REMAINDER D.<br>    C的值为2.3，D为0.1。(D=7-32.3)</p>\r\n<p>COMPUTE<br>    除了取余操作要用DIVIDE外，其他操作都可以用此语句。本语句求值一个算术表达式，并将结果存放在一个或几个变量中。<br>    COMPUTE  A ROUNDED,B = X<em>Y/(N+M)+Z.   将X</em>Y/(N+M)+Z的结果存放在B中，然后舍入后放入A中。</p>\r\n<p>MOVE<br>    MOVE A TO B.<br>    也可以用CORR选项。<br>    MOVE CORR A TO B.\r\n<p>ACCEPT<br>    从键盘或其他输入设备读取数据。<br>    ACCEPT A FROM DEV.    从DEV读取数据到A，也可以省略FROM DEV，表示从键盘读取。<br>    ACCEPT A FROM DATE/DAY/DAY-OF-WEEK/TIME.读取日期，表示为6个字符，如990909（1999年9月9日）。<br>    读取当前日期在年度（前2位）中为第几天（后3位），表示为6个字符，如1994年4月1日表示为94091。<br>    读取当前星期几，表示为1位字符。1表示星期一，7表示星期日。<br>    读取当前时间，表示为8位字符。精确到毫秒。如下午2：41表示为14410000。\r\n<p>DISPLAY<br>    将数据写入输出设备。如监视器（monite），系统输出流和操作员控制台（console）。<br>    DISPLAY AAAAA BBBBB [UPON DEV] [WITH NO ADVANCING]<br>    如果使用UPON选项，dev要与special-names段中的硬件名相关联。<br>    如果使用no advancing选项，则输出最后一个字符后输出设备仍然保持原位，使下一条display语句还在该位置显示。否则可能到下一行显示。\r\n<p>INITIALIZE<br>    初始化数据，数字和数字编辑数据项初始化为0，其他初始化为空格。\r\n<p>INSPECT TALLYING<br>    计算项目中该字符串出现的次数。<br>    INSPECT AA TALLYING BB FOR ALL “EE”.  从AA中查找有多少个EE，将个数写入BB。<br>    INSPECT AA TALLYING BB FOR CHARACTERS BEFORE “E”.  从AA中查找E前面有多少个字符，将个数写入BB。<br>    INSPECT AA TALLYING BB FOR CHARACTERS AFTER “C” BEFORE “E”.  从AA中查找C后面E前面有多少个字符，将个数写入BB。<br>    INSPECT AA TALLYING BB FOR LEADING “E”.  从AA中第一个字符开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。<br>    INSPECT AA TALLYING BB FOR LEADING “E” AFTER “C”.  从AA中C后面开始查找有多少个E，如果没有就结束操作，有就将个数写入BB，直至没有。<br>组合例子：<br>    77 CS PIC X(9) VALUE “REELWHEEL”.<br>    77 COUNT-0.<br>    77 COUNT-1.<br>    77 COUNT-2.<br>    MOVE 0 TO COUNT-0,COUNT-1,COUNT-2.<br>    INSPECT CS TALLYING<br>        COUNT-0 FOR ALL “E”,<br>        COUNT-1 FOR LEADING “W” AFTER “L”,<br>        COUNT-2 FOR CHARACTERS.<br>    程序首先判断的是字符”R”,执行COUNT-0 FOR ALL “E”，因为第一个字符不是”E”，所以程序转而执行COUNT-1 FOR LEADING “W” AFTER “L”，也不符合要求，<br>    于是程序执行COUNT-2 FOR CHARACTERS，COUNT-2 =1。然后字符串往下一位，判断”E”,执行COUNT-0 FOR ALL “E”，符合要求，则COUNT-0=1。<br>    有了满足条件的判断，则余下的判断不再执行，字符串再往下一位，判断”E”，则COUNT-0=2。接着判断”L”,则COUNT-2 =2。以此类推，最后结果为COUNT-0=4，<br>    COUNT-1=1，COUNT-2=4。\r\n<p>INSPECT REPLACING<br>    用另一个字符串替换这个字符串。<br>    还用上面的例子。<br>    INSPECT CS REPLACING ALL “E” BY “Y”.  结果”RYYLWHYYL”<br>    INSPECT CS REPLACING CHARACTERS BY “Z” AFTER  “L”.  结果”REELZZZZZ”<br>    INSPECT CS REPLACING LEADING “E” BY “Y”.  结果不变<br>    INSPECT CS REPLACING LEADING “E” BY “Z” AFTER  “H”.  结果”REELWHZZL”<br>    INSPECT CS REPLACING FIRST “E” BY “I”.  结果”RIELWHEEL”<br>    INSPECT CS REPLACING FIRST “EE” BY “00”,ALL “WH” BY “TH”,CHARACTERS BY SPACE.  结果” 00 TH   “\r\n<p>INSPECT CONVERTING<br>    就是INSPECT REPLACING的缩写。<br>    INSPECT CS CONVERTING “EE” TO “00”. 也可以加上BEFORE，AFTER。\r\n<p>STRING<br>    将几个字符串合并成一个字符串。<br>    STRING A DELIMITED BY SPACE，” ！” DELIMITED BY SIZE INTO C.假设A中的内容是”HELLO”,则结果是”HELLO !”.<br>    DELIMITED BY SPACE意思是碰到空格，或到A的结尾或C的结尾，则合并A字符串结束。<br>    DELIMITED BY SIZE意思是到” ！”的结尾或C的结尾，则合并” ！”字符串结束。<br>    STRING A INTO B POINTER C ON OVERFLOW PROC1 NOT ON OVERFLOW  PROC2.<br>    将A字符串复制到B中由C开始的地址处。如果C小于1或大于B的长度，或A的长度大于B中C到结尾处的长度，则发生<br>    OVERFLOW溢出，执行PROC1。\r\n<p>UNSTRING<br>    将一个字符串中的字符按照要求放入多个变量中。<br>    UNSTRING AAA [DELIMITED BY [ALL] B [OR [ALL] C] …] INTO { C [DELIMITER IN D] [COUNT IN E] } …[WITH POINTER F] [TALLYING IN G] [ON OVERFLOW PROC1] [NOT ON OVERFLOW PROC2] [END-UNSTRING]<br>    将AAA中的字符放入C，如果还有其他变量，如C2，则等C放满后放入C2。<br>    DELIMITED BY和STRING中的作用一样。表示将AAA中到B为止的字符取出。如果有OR，则表示到B或C字符为止的字符取出。如果有ALL，则如果几个相同的B在一起，则认为是一个B。<br>    DELIMITER IN 将B放入D，知道是哪个字符为分隔符。<br>    COUNT IN 实际复制到C中的字符数放入E中。<br>    WITH POINTER 和STRIGN中一样。<br>    TALLYING IN 计算有几个接受项。访问一个新的接受项，G值加1。<br>例子：<br>    03 CITY PIC X(10).<br>    O3 ZIP  PIC X(10).<br>    77 TEST PIC X(20).<br>    MOVE “NEW YORK,NY 10017” TO TEST.<br>    UNSTRING TEST DELIMITED BY “,” INTO CITY,ZIP.<br>    执行结果CITY值是NEW YORK.ZIP的值是NY 10017。\r\n<p>逻辑和控制语句<br>   IF (A [NOT] &gt; B) 等价于 IF (A [NOT] GREATER THAN B)<br>   IF (A [NOT] &lt; B) 等价于 IF (A [NOT] LESS THAN B)<br>   IF (A [NOT] = B) 等价于 IF (A [NOT] EQUAL TO B)<br>   IF (A &gt;= B) 等价于 IF (A GREATER THAN OR EQUAL TO B)<br>   IF (A <= B) 等价于 IF (A LESS THAN OR EQUAL TO B)\r\n<p>   IF (A [NOT] &gt; B AND  C) 表示A [NOT] 大于B 而且 A [NOT] 大于C</p>\r\n<p>   IF A IS [NOT] NUMERIC    数字和可选符号<br>   IF A IS [NOT] ALPHABETIC A~Z,a~z字符和空格<br>   IF A IS [NOT] ALPHABETIC-LOWER a~z字符和空格<br>   IF A IS [NOT] ALPHABETIC-UPPER A~Z字符和空格<br>   IF A IS [NOT] CLASS-NAME       SPECIAL-NAMES定义的字符集<br>    例如：SPECIAL-NAMES.<br>              CLASS MYDEFINE IS “12345+ABCDE-“.\r\n<p>   判断变量是否定义了数值。这个变量是88层的，且要与一个数据项关联。<br>    03 STATE PIC XX.<br>    88 CON VALUES ARE “A”,”B”,”C”.<br>    IF CON …\r\n<p>   判断厂家定义运行开关的开/关状态。<br>    SPECIAL-NAMES.<br>        SWITCH-A ON STATUS IS A-ON ,OFF STATUS IS A-OFF.<br>    IF A-ON…<br>   若开关在开位置，则IF A-ON返回TRUE。\r\n<p>   IF A IS [NOT] POSITIVE  判断是否大于0<br>    IF A IS [NOT] NEGATIVE  判断是否小于0<br>    IF A IS [NOT] ZERO      判断是否等于0\r\n<p>   COBOL支持NOT ,AND ,OR 操作。</p>\r\n<p>PERFORM<br>    过程调用，但是不传递参数。<br>  PERFORM PROC1 [THROUGH PROC2]<br>    执行完PROC1再执行PROC2.没有THROUGH(THRU)就只执行PROC1.<br>  PERFORM PROC1 [THRU PROC2] N TIMES<br>    执行PROC1[或者还有PROC2]N次。<br>  PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] UNTIL A NOT EUQAL 0.<br>    执行PROC1[或者还有PROC2]直到A不等于0。WITH TEST BEFORE/AFTER指定在第一次执行之前还是之后判断条件。默认是BEFORE，执行之前判断。<br>  PERFORM PROC1 [THRU PROC2] [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 [AFTER D FROM E BY F UNTIL CONDITION2].<br>    相当于FOR循环，将A的值从B开始，以C为单位递增，直到满足CONDITION1。AFTER语句是一个嵌套的FOR 循环。VARYING是外循环，AFTER是内循环。A，B可以是索引。\r\n<p>   过程也可以直接写入PERFORM中。但是THROUGH就不好用了。语法如下 ：<br>  PERFORM 过程语句 END-PERFORM.<br>  PERFORM N TIMES 过程语句 END-PERFORM.<br>  PERFORM [WITH TEST BEFORE/AFTER] UNTIL CONDITION 过程语句 END-PERFORM.<br>  PERFORM [WITH TEST BEFORE/AFTER] VARYING A FROM B BY C UNTIL CONDITION1 过程语句 END-PERFORM.\r\n<p>IF语句<br>  IF CONDITION THEN STATEMENTS1/NEXT SENTENCE ELSE STATEMENTS2 END-IF/NEXT SENTENCE/ENDIF<br>    NEXT SENTENCE将跳出IF操作语句执行下一条语句。<br>    IF语句中不要使用.句号。.句号将结束所有IF语句。要结束一个嵌套的IF语句，可以使用END-IF或者NEXT SENTENCE.如<br>    IF A IF B END-IF ELSE C END-IF.或者<br>    IF A IF B ELSE NEXT SENTENCE ELSE C END-IF.\r\n<p>EVALUATE<br>    相当于SWITCH CASE语句。<br>    EVALUATE A<br>        WHEN B …<br>        WHEN 0 THRU 100 …(FROM 0 TO 100)<br>        WHEN OTHER …<br>    [END-EVALUATE]<br>    首先得到A的结果，和WHEN语句的参数比较，如果和B相等，就执行B后的操作，执行完了不再执行后面的WHEN语句。如果不等就执行下一条WHEN语句。如果没有相等的就执行WHEN OTHER语句。<br>    EVALUATE A ALSO B<br>        WHEN C ALSO D …<br>        WHEN E ALSO F …<br>        WHEN OTHER …<br>    对于有多个判断条件的，要多个条件同时满足。如上要C=A同时D=B，才执行WHEN语句。\r\n<p>CONTINUE<br>    继续执行下面的程序。\r\n<p>GO TO<br>    GO TO PROC1 [DEPENDING ON N] DEPENDING ON N将跳转到清单中的第N个PROC.\r\n<p>EXIT<br>    一般为最后一句话。\r\n<p>STOP<br>    STOP RUN  结束程序。\r\n<p>ALTER<br>    ALTER PROC1 TO PROC2. 不懂什么意思，反正已经从标准中废除了这个语句。\r\n<p>ENTER<br>    使其他编程语言中的语句可以放进当前源程序中。<br>    ENTER LANGUAGE-NAME [ROUTINE-NAME]<br>    LANGUAGE 是厂家指定可以输入COBOL的任何语言，这个语句后面是其他编程语言的语句，然后要用ENTERCOBOL表示返回COBOL语言。<br>    如果无法将其他语言的程序直接放入，可以用ROUTINE-NAME引用其他语言编写的程序。\r\n<p>COBOL <wbr> <wbr>知识点集锦（下） cobol程序格式<br>cobol源程序的格式如下：<br>     每行开头有6个字符的序号区。可以输入000010，000020等表示行，也可以不输。<br>     序号区后面是一个字符（第7位）的指示符区，如第一行所示。可以用*和/表示注释，_表示续行，D表示调试。<br>     指示符区后面是4个字符（8~11位）的A区。可以放入部，节，段标题，段名，层指示符和层号01与77，<br>            关键字DECLARATIVES和END DECLARATIVES,程序结束标题。<br>     A区后面（12位以后）是语句体，称为B区。过程部的语句必须从B区开始。B区宽度通常为72或80个字符。<br>            本例是70个字符。<br>     空行的每个区都是空格\r\n<p>标识部（2~4行），PROGRAM-ID段包含程序名，是每个程序都必须的。AUTHOR等其他段是可有可无的。</p>\r\n<p>环境部（5~15行），提供与程序外部有关的项目，具体地说，就是列出程序所用的文件。如果不需要可以省略。<br>     环境部有配置节（6~10行）和输入输出节（11~15行）。<br>     第7行表示编译程序的计算机。如果指定WITH DEBUGGING MODE就编译调试行。<br>     第8行表示程序运行的计算机。<br>     第9，10行包含一组指定输出样式。这里是标准输出，可以自定义。<br>     输入输出节只用于文件。<br>     第13到15行表示如果程序使用文件，则这个段对每个文件包含一个项目。<br>     文件控制项目的格式取决于文件的描述类型。\r\n<p>数据部（16~22行），提供程序变量的存放位置，对不同的数据类型分成不同的节：文件数据（File Section）、静态数据（Working-Storage Section）、参数（Linkage Section）、通信（Communication Section）、报表（Report Section）。<br>     文件节（18~21行），每个文件描述中包含文件所含纪录的定义，文件节中的数据或从文件读取，<br>         或由写文件的程序产生。<br>     第22行表示工作存储节，这节包含程序所需的临时结果和初始化静态数据的数据。<br>     参数（Linkage Section）包含调用程序传递的数据（其他语言中称为参数）。<br>     通信（Communication Section）,处理COBOL程序和通信设备之间的消息。<br>     报表（Report Section），报表节实现COBOL报告编写工具系统所需的数据。<br>     第20，21行的PIC是PICTURE的缩写，表示定义数据格式。<br>          X(12)表示12个字符的字符串，9(09)表示9位的整数。<br>     可以将基本项目组成层次结构，称为组数据项或组。<br>COBOL程序中的数据项的定义从层号开始，01层是最高层，49层是最低层。<br>     77层项目用于某个组的数据项，如程序中的临时变量。<br>          66层是为特殊描述符项目保留的，可以更名现有的数据项或组，或以原定义未允许的方式组合。<br>          88层是对特殊数据项目条件名保留的<br>          如：<br>          03 STATE PIC XX.<br>          88 NEW-ENGLAND VALUES ARE “1”,”2”,”3”,”4”,”5”.<br>          IF NEW-ENGLAND … then do something\r\n<p>过程部（23~30行），包含构成程序的过程性语句。<br>          带DECLARATIVES的过程部。有些程序用特殊的USE语句表示遇到特殊条件时要执行的过程，<br>                 如发生I/O错误时。<br>                 USE语句组合在一起，放在过程部开头，由关键字DECLARATIVES和END DECLARATIVES限定。<br>          第24行相当于定义了一个名字叫ACAB030100-PROC（）的函数。<br>          第25，29行定义了标志，可以用GO TO 语句跳转到这个地方，执行下面的语句。<br>          第26行在屏幕上打印，相当于printf(“ACAB030100-START”);<br>          第27行是调用ACAB030100-PROC（）函数。\r\n<p>cobol程序的要求：必须以英文句号.结束部标题、节标题、段名、项目和语句。<br>         句号为小数点时，两边都要有数字。\r\n<p>COBOL <wbr> <wbr>知识点集锦（下） cobol文件操作<br>要在COBOL中使用文件，要在3个不同的部中放上信息。<br>    环境部，要有程序使用的每个文件的文件控制项目(FILE-CONTROL)。这个项目将程序中使用的文件名与程序外的实际文件联系起来。这些项目还定义文件的组织和访问方式。<br>    数据部，要有每个文件的文件描述符(FD)项目，就是数据定义。<br>    过程部，放上处理语句，OPEN,READ,WRITE,DELETE等。\r\n<p>   环境部中主要是FILE-CONTROL和I-O-CONTROL.I-O-CONTROL很少使用。<br>    SELECT [OPTIONAL] file-name ASSIGN TO DEV/FILE<br>    [RESERVE N [AREA/AREAS]]<br>    [FILE STATUS IS VAR]<br>    SELECT必须是第一句，其他顺序无关。file-name是程序中传递使用的文件名，相当于实际文件的一个别名。OPTIONAL用于执行可能不存在的文件。<br>    ASSIGN将file-name连接到实际的外部设备或文件。（TO好像可以省略。）<br>    RESERVE指定文件缓冲区。<br>    FILE STATUS指定一个变量存放文件状态，这个变量应该已在WORKING-STORAGE SECTION中定义。\r\n<p>   对于顺序文件，还有声明如下：<br>    [ORGANIZATION IS SEQUENTIAL]               可选，缺省为顺序组织文件<br>    [ACCESS MODE IS SEQUENTIAL]                可选。顺序文件只允许顺序访问<br>    [PADDING CHARACTER IS char]                指定文件在固定块长设备上时键块所用的字符，char为一个字符的数据项。<br>    [RECORD DELIMITER IS STANDARD/usr-define]  指定如何确定变长纪录的长度。<br>    顺序文件例子：<br>    SELECT file-name ASSIGN TO “/usr/file1”<br>    FILE STATUS IS file-status\r\n<p>   对于相对文件，还有声明如下：<br>    [ORGANIZATION IS RELATIVE]               是相对文件必须的<br>    [ACCESS MODE IS SEQUENTIAL [RELATIVE KEY IS data]] 或者<br>    [ACCESS MODE IS RANDOM/DYNAMIC RELATIVE KEY IS data]<br>    访问方式有3种，缺省是SEQUENTIAL。<br>    RELATIVE KEY 可选。如果存在，则文件读取操作顺利完成后，data用所读取纪录的关键字更新。data应为文件的纪录区中没有的整数数据项。<br>    相对文件的例子：<br>    SELECT file-name ASSIGN TO “/usr/file2”<br>    ORGANIZATION IS RELATIVE<br>    ACCESS MODE IS DYNAMIC RELATIVE KEY IS DAY-NUMBER<br>    FILE STATUS IS file-status\r\n<p>   对于索引文件，还有声明如下：<br>    [ORGANIZATION IS INDEXED]               是索引文件必须的<br>    [ACCESS MODE IS SEQUENTIAL/RANDOM/DYNAMIC] RECORD KEY IS data1<br>    [ALTERNATE RECORD KEY IS data2 [WITH DUPLICATES]]<br>    访问方式有3种，缺省是SEQUENTIAL。<br>    RECORD KEY 指定文件的主纪录关键字，data1应为定义该文件的某个记录区的字母数字数据项目。这个关键字的描述及其在数据记录中的位置应该与生成文件时所用的关键字一致。<br>    ALTERNATE RECORD KEY 如果文件有替换关键字，则其关键字用这个从句的短语指定，索引中允许重复关键字时采用DUPLICATES.COBOL要求文件记录中定义data2。重复关键字的长度及其在数据记录中的位置应该与生成文件时一致，所有替换关键字应放在文件控制项中。<br>   索引文件的例子：<br>    SELECT file-name ASSIGN TO “/usr/file3”<br>    ORGANIZATION IS INDEXED<br>    ACCESS MODE IS RANDOM<br>    RECORD KEY IS NUMBER OF EMPLOYEE-RECORD<br>    ALTERNATE RECORD KEY IS LAST-NAME OF EMPLOYEE-RECORD WITH DUPLICATES<br>    ALTERNATE RECORD KEY IS SS-NUMBER OF EMPLOYEE-RECORD<br>    FILE STATUS IS file-status<br>    这里用户在程序中使用的文件名是file-name，实际文件名是file3。file-name的定义放在程序后边的数据部的文件节中。文件是索引文件，程序可以随机访问文件。文件的主关键字是NUMBER OF EMPLOYEE-RECORD，替换关键字是LAST-NAME和SS-NUMBER，都是文件记录区的字段。LAST-NAME允许重复。\r\n<p>   文件状态：(对文件操作时返回文件状态到定义的文件状态变量)<br>    ANY            00 成功<br>    ANY            02 对索引文件，成功但发现重复关键字<br>    READ           04 成功，但纪录长度不符合指定长度<br>    OPEN           05 成功，但文件是可选的，前面不存在<br>    OPEN,CLOSE     07 对顺序文件，成功，但媒介不是盘<br>    READ           10 文件已到末尾<br>    READ           14 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位<br>    WRITE,REWRITE  21 对索引文件，顺序出错<br>    WRITE          22 对索引和相对文件，带这个关键字的纪录已经存在<br>    START,READ     23 对索引和相对文件，带这个关键字的纪录不存在<br>    WRITE          24 对相对文件，相对纪录号的有效位超过相对关键字数据项允许的位<br>    ANY            30 I/O错误<br>    WRITE          34 对顺序文件，发生超边界错误<br>    OPEN           35 对顺序和相对文件，未发现非可选文件<br>    OPEN           37 对顺序和相对文件，该文件不支持指定的打开方式<br>    OPEN           38 对顺序和相对文件，文件已经用锁关闭<br>    OPEN           39 对顺序和相对文件，文件属性不支持程序中指定的属性<br>    OPEN           41 文件已经打开<br>    CLOSE          42 文件未打开<br>    DELETE,REWRITE 43 最近的操作不是READ<br>    WRITE,REWRITE  44 纪录长度非法<br>    READ           46 没有有效的下一个记录<br>    READ,START     47 文件未在INPUT或I-O方式中打开<br>    WRITE          48 文件未在OUTPUT或EXTEND方式中打开<br>    DELETE,REWRITE 49 文件未在I-O方式中打开<br>    ANY            90~99 厂家定义\r\n<p>   由上可知，文件操作时会发生错误，COBOL提供了检查错误和恢复I/O错误的公用地点。过程部开头应包括DECLARATIVES部分，放上出现错误时要执行的语句。<br>    PROCEDURE DIVISION.<br>    DECLARATIVES.<br>    section-name SECTION.<br>    USE statement(出现错误时调用的节).<br>      paragraph-name.<br>        sentence…<br>    END DECLARATIVES.<br>    section-name SECTION.<br>      paragraph-name.<br>        sentence…<br>   USE AFTER STANDARD EXCEPTION/ERROR PROCEDURE ON file-name/INPUT/OUTPUT/I-O/EXTEND<br>    只能在USE语句中指定一个文件，一种方式也只能有一个USE语句。如果既指定了文件，也指定了方式，则文件优先。\r\n<p>   程序使用的所有文件要定义在数据部的第一节——文件节中。<br>    FD file-name<br>    [BLOCK CONTAINS int-1 [TO int-2] RECORDS/CHARACTERS]<br>    [RECORD (CONTAINS int-3 [TO int-4] CHARACTERS)/(IS VARYING IN SIZE [FROM int-5] [TO int-6] CHARACTERS)/(DEPENDING ON data1)<br>    [LABEL (RECORD IS)/(RECORDS ARE) STANDARD/OMITTED]<br>    [VALUE OF (implementor-name IS id-lit-1)…]<br>    [DATA (RECORD IS)/(RECORDS ARE) data2]<br>    BLOCK CONTAINS 指定实际纪录的具体长度或最大与最小长度的逻辑记录数或块数。一般有操作系统和文件系统指定。<br>    RECORD 指定包含变长纪录的文件中记录的最大与最小长度或定长纪录的具体长度。<br>    RECORD CONTAINS 如果不带TO，则int-3是每个纪录的长度；如果带TO,介于int-3和int-4之间。<br>    RECORD IS VARYING 指定纪录长度最小int-5和最大int-6。<br>    DEPENDING ON 如要用，则需要在data1中保存纪录长度。<br>    LABEL RECORD 指定文件是否带标号。（过时，下个版本不包含）<br>    VALUE 和LABEL一起检查标号的不同部分。（过时，下个版本不包含）<br>    DATA RECORD 指定属于文件的纪录描述项（FD后的01层项目）并作为程序文档。（过时，下个版本不包含）<br>    一般定义文件只用第一句：FD file-name<br>  顺序文件的LINAGE声明<br>    对顺序文件，LINAGE声明可以在文件输出是打印机或打印机兼容文件时指定一些打印细节。<br>    [LINAGE IS BODY LINES [WITH FOOTING AT FOOT][LINES AT TOP TOP][LINES AT BOTTOM BOTTOM]] [CODE-SET IS alphabet-name]<br>    整个文件分成TOP,BODY,BOTTOM三部分。其中BODY包含有FOOT.<br>    CODE-SET指定文件中所用的字符集。\r\n<p>   过程部主要是对文件的OPEN,CLOSE,READ,WRITE,START,REWRITE,DELETE等操作。<br>OPEN<br>    OPEN文件有4种方式：（如果文件声明为OPTIONAL，则文件不存在会创建文件，否则会报错）<br>    OPEN INPUT FILE-NAME.    只能读取的文件。<br>    OPEN OUTPUT FILE-NAME.   生成写入纪录的文件，读取该文件会出错。若文件已存在，已有记录会被全部删除。<br>    OPEN I-O FILE-NAME.      可读可写的文件。<br>    OPEN EXTEND FILE-NAME.   生成写入的文件。与UOTPUT的区别在于，若文件已存在，EXTEND将纪录加在文件末尾。<br>    如果OPEN不成功，执行USE语句。USE语句不存在，则程序结束。<br>    顺序文件的OPEN可以有以下方式：<br>    OPEN INPUT FILE-NAME [(WITH NO REWIND)/REVERSED].<br>    OPEN OUTPUT FILE-NAME [WITH NO REWIND].<br>    REVERSED可以逆序处理，即由后向前处理。（过时，下个版本不包含）<br>    WITH NO REWIND 用于单卷磁带文件，如果指定文件在不适用REWIND的媒介上，忽略。<br>    在文件描述项中指定LINAGE得顺序文件不能用EXTEND方式打开。\r\n<p>CLOSE<br>    所有文件的CLOSE方法：<br>    CLOSE FILE-NAME.    关闭文件。<br>    CLOSE FILE-NAME WITH LOCK.    关闭文件，不退出程序不能再打开此文件。<br>    顺序文件还有其他一些选项,如关闭卷或单元，和继续处理文件：<br>    CLOSE file-name [REEL/UNIT] [FOR REMOVAL]/WITH NO REWIND\r\n<p>READ<br>    顺序访问方式读文件。一定要有NEXT字样。<br>    READ file-name [NEXT] RECORD [INTO data1]<br>    [AT END statements][NOT AT END statements] [END-READ]<br>    如果READ成功且有INTO，将读到的数据写入data1。<br>    如果文件中没有记录，执行AT ENDstatements，如果没有就执行USE。<br>    如果READ成功，就执行NOT AT END statements。\r\n<p>   动态访问方式读文件。(相对或索引文件)<br>    利用OPEN语句，将文件指针设在开头。<br>    进行各种成功的READ操作。<br>    有START语句标识文件中的纪录。\r\n<p>   随机访问方式读文件。<br>    READ file-name RECORD [INTO data1]<br>    [INVALID KEY statements][NOT INVALID KEY statements] [END-READ]<br>    如果READ成功且有INTO，将读到的数据写入data1。<br>    如果文件中没有记录，执行INVALID KEY statements，如果没有就执行USE。<br>    如果READ成功，就执行NOT INVALID KEY statements。<br>    如果是相对文件，要设置文件控制项RELATIVE KEY中指定的整型关键字值后才能执行READ.<br>    如果是索引文件，要设置当前索引的关键字值后才能执行READ.\r\n<p>WRITE<br>    顺序方式。<br>    WRITE data [FROM data1] [BEFORE/AFTER ADVANCING mnemonic-name/PAGE/N LINE(LINES)]<br>    [AT END-OF-PAGE(EOP) statements][NOT AT END-OF-PAGE(EOP) statements][END-WRITE]<br>    如果指定了FROM，先将data1复制到data，再写入文件。<br>    BEFORE/AFTER ADVANCING N LINE(LINES) 在纪录间插入N个空行。<br>    AT END-OF-PAGE(EOP) 对于带LINAGE的文件有效，在WRITE使指针进入页脚(FOOT)时，先执行WRITE，再执行AT END-OF-PAGE(EOP) statements。\r\n<p>   相对和索引文件方式。<br>    WRITE data [FROM data1]<br>    [INVALID KEY statements][NOT INVALID KEY statements] [END-WRITE]\r\n<p>REWRITE<br>    替换文件中的一个记录。<br>    顺序方式：REWRITE data [FROM data1] [END-REWRITE]<br>    相对和索引方式：<br>    REWRITE data [FROM data1]<br>    [INVALID KEY statements][NOT INVALID KEY statements] [END-REWRITE]\r\n<p>DELETE<br>    删除文件中的一个记录。只能用于相对或索引组织的文件。<br>    DELETE file-name RECORD<br>    [INVALID KEY statements][NOT INVALID KEY statements] [END-DELETE]<br>    顺序访问方式的话，前一个READ的纪录被删除。<br>    随机或动态访问的话，RELATIVE KEY的内容或主关键字所表示的纪录从文件中删除。\r\n<p>START<br>    将相对或索引文件定位到某个纪录，以便对其进行顺序访问。只对相对和索引文件有效。<br>    START file-name [KEY IS (EQUAL TO)/=/GREATER THAN/&gt;/NOT LESS THAN/NOT &lt; data]<br>    [INVALID KEY statements][NOT INVALID KEY statements] [END-START]<br>    如果执行成功，则data所属的索引变成文件的当前索引。<br>    对于相对文件，data定义为文件的RELATIVE KEY的数据项。<br>    对于索引文件，data为下列之一：<br>    文件的主关键字，是RECORD KEY从句中指定的数据项。<br>    文件的替换关键字，是ALTERNATE RECORD KEY从句指定的数据项。<br>    从一个关键字的第一个位置开头，长度小于或等于该关键字的数据项。\r\n<p>COBOL <wbr> <wbr>知识点集锦（下） cobol数组操作<br>下面是数组的例子：<br>          01 RECORD-X.<br>            03 MONTH OCCURS 12 TIMES.<br>              05 NAME PIC X(12).<br>              05 DAYS OCCURS 31 TIEMS.<br>                07 COMMENT PIC X(20).<br>                07 TEMP-HI PIC S999.<br>                07 TEMP-LO PIC S999.<br>          77 CURRENT-DAY PIC 99.<br>          调用表示如下：<br>          MONTH(5) : 包含NAME 和 DAYS表格的组项目。<br>          NAME OF MONTH(5) :基本字母数字项目，长度为12个字符。<br>          NAME(5) (1:3) 上述第5个项目的前3个字符。<br>          TEMP-HI(1,31) 基本数字项目，长度为3个字符。前一个参数是在MONTH数组中的位置，后一个参数是在DAYS数组中的位置。相当于MONTH[1].DAYS[31].TEMP-HI。<br>          COMMENT OF RECORD-X(5,CURRENT-DAY)(11) 基本字母数字项目第五个月的CURRENT-DAY的COMMENT字段的最后10个字符。\r\n<p>   03 TEXT PIC XXX OCCURS 1 TO 12 TIMES DEPENDING ON IX.<br>   定义一个变长的数组。定义的长度是12，实际以IX为准，若IX为10，则TEXT的长度就是30。\r\n<p>索引<br>  索引名INDEX<br>    索引名可以用作PERFORM语句的变量，用于SET和SEARCH语句和用作下标。<br>    03 TEXT PIC XXX OCCURS 7 TIMES INDEXED BY index<br>      05 A PIC XXX<br>      05 B PIC XXX<br>    PERFORM VARYING index FROM 1 BY 1 UNTIL index &gt;7<br>      DISPLAY A(index),B(index)<br>    END-PERFORM.<br>    注意和不用索引名的比较：<br>    77 index PIC 99<br>    03 TEXT PIC XXX OCCURS 7 TIMES<br>      05 A PIC XXX<br>      05 B PIC XXX<br>    PERFORM VARYING index FROM 1 BY 1 UNTIL index &gt;7<br>      DISPLAY A(index),B(index)<br>    END-PERFORM.\r\n<p>  关键字KEY<br>    关键字有ASCENDING(升序，由低到高)和DESCENDING(降序，由高到低)。<br>      03 TEXT PIC XXX OCCURS 7 TIMES ASCENDING KEY IS A,B.<br>      05 A PIC XXX.<br>      05 B PIC XXX.<br>    TEXT中的元素按A升序排序，A相同的元素按B升序排序。<br>    关键字的作用是定义SEARCH语句带ALL短语时表格的排序。\r\n<p>  表格初始化，可以一个一个数据项单独初始化，也可以一起初始化。<br>      03 TEXT PIC XXX OCCURS 7 TIMES VALUES SPACE.<br>      05 A PIC XXX.<br>      05 B PIC XXX.                          一起初始化为空格。<br>      03 TEXT PIC XXX OCCURS 7 TIMES.<br>      05 A PIC XXX VALUES SPACE.<br>      05 B PIC XXX VALUES SPACE.            单独初始化。\r\n<p>SET<br>    保存或恢复索引值。SET A TO B.<br>    将索引递增或递减一个整数值。SET A UP/DOWN BY N.\r\n<p>SEARCH<br>    SEARCH A [VARYING B] AT END C {WHEN CONDITION D}…END-SEARCH<br>    A为带INDEXED BY 短语的表格。每一步都轮流求值CONDITION ,为真时执行D,SEARCH语句终止。    为假时，索引值递增，至最大索引时执行AT END C,SEARCH语句终止。<br>    若一开始索引值即为最大，则不执行WHEN语句，直接执行AT END 语句。<br>    VARYING 指定索引B，省略为A中制定的索引。<br>    下面的例子查找月份表中下一个具有31天的月份。<br>    01 MONTH-DATA.<br>      03 MONTH-INFO.<br>        05 PIC X(10) VALUES “JANUARY”.<br>        05 PIC X(3) VALUES “JAN”.<br>        05 PIC 99 VALUES 31.<br>        05 PIC X(10) VALUES “FEBRUARY”.<br>        05 PIC X(3) VALUES “FEB”.<br>        05 PIC 99 VALUES 28.<br>        …(省略代码)<br>      03 MONTH REDEFINES MONTH-INFO OCCURS 12 TIMES INDEXED BY MONTH-INDEX.<br>        05 NAME   PIC X(10).<br>        05 ABBREV PIC X(3).<br>        05 DAYS   PIC 99.<br>    77 CURRENT-MONTH PIC 99.<br>    77 NEXT-31-DAY-MONTH PIC 99.\r\n<p>   SET MONTH-INDEX TO CURRENT-MONTH.<br>    SET MONTH-INDEX UP BY 1.<br>    SEARCH MONTH<br>        AT END MOVE 1 TO MONTH-INDEX<br>            SEARCH MONTH<br>                AT END MOVE 0 TO NEXT-31-DAY-MONTH<br>                WHEN DAYS(MONTH-INDEX) = 31<br>                    SET NEXT-31-DAY-MONTH TO MONTH-INDEX<br>            END-SEARCH<br>        WHEN DAYS(MONTH-INDEX) = 31<br>            SET NEXT-31-DAY-MONTH TO MONTH-INDEX<br>    END-SEARCH<br>    要查找多维表格，要将SEARCH放到PERFORM中。<br>    01 TABLE-DATA.<br>      03 DIM-1 OCCURS 10 TIMES INDEXED BY X1.<br>        05 DIM-2 OCCURS 20 TIMES INDEXED BY X2.<br>          07 NAME PIC X(20).<br>          07 STATE PIC XX.<br>          …<br>    PERFORM VARYING X1 FROM 1 BY 1 UNTIL X1 &gt; 20<br>        SET X2 TO 1<br>        SEARCH DIM-2<br>            WHEN STATE(X1,X2) = “AL” ….<br>            WNEH STATE(X1,X2) = “AZ” ….<br>        END SEARCH<br>    END-PERFORM.<br>    还有一种SEARCH是对有关键字的表格进行查找，和上面的查找差不多，主要是WHEN 条件中要用关键字作为查找条件。比如说关键字为A，则必须有WHEN A = …..\r\n<p>COBOL <wbr> <wbr>知识点集锦（下） cobol子程序调用<br>内部子程序<br>    IDENTIFICATION DIVISION.<br>    PROGRAM-ID. PROC-A.<br>    ENVIRONMENT DIVISION.<br>    …<br>    DATA DIVISION.<br>    …<br>    PROCEDURE DIVISION.<br>    …<br>       IDENTIFICATION DIVISION.<br>       PROGRAM-ID. PROC-B.<br>       ENVIRONMENT DIVISION.<br>       …<br>       DATA DIVISION.<br>       …<br>       PROCEDURE DIVISION.<br>       …<br>       END PROGRAM PROC-B.<br>       IDENTIFICATION DIVISION.<br>       PROGRAM-ID. PROC-C.<br>       ENVIRONMENT DIVISION.<br>       …<br>       DATA DIVISION.<br>       …<br>       PROCEDURE DIVISION.<br>       …<br>           IDENTIFICATION DIVISION.<br>           PROGRAM-ID. PROC-D.<br>           ENVIRONMENT DIVISION.<br>           …<br>           DATA DIVISION.<br>           …<br>           PROCEDURE DIVISION.<br>           …<br>           END PROGRAM PROC-D.<br>       END PROGRAM PROC-C.<br>    END PROGRAM PROC-A.<br>    程序A包含B,C两个子程序，其中C又包含子程序D。<br>    A能调用B，C。C能调用D。B不能调用C，A不能调用D。<br>    如果C声明为公用的，则B可以调用C，语法为：<br>    PROGRAM-ID. PROC-C IS COMMON PROGRAM.\r\n<p>   当前函数中定义的变量都只是对当前函数有效。可以用GLOBAL声明为对所有函数有效。<br>    01 DATA-NAME IS GOLBAL …<br>    文件也有此声明：FD FILE-NAME IS GOLBAL …\r\n<p>   如果调用的不是本程序中的文件或变量，则可以用EXTERNAL声明。<br>    FD FILE-NAME IS EXTERNAL…/01 DATA-NAME IS EXTERNAL…\r\n<p>   CALL PROC VAR1 [ON EXCEPTION CODE1] [NOT ON EXCEPTION CODE2] END-CALL.<br>    如果找不到PROC程序名，执行CODE1(如果有此声明)，找到将参数VAR1传递给PROC，并执行。PROC返回时执行CODE2(如果有此声明)。<br>    参数应该在文件，工作存储或连接节中定义，应为01层数据项，77层数据项或基本数据项。<br>    子程序要返回调用程序，执行EXIT PROGRAM\r\n<p>   传递参数有3步:<br>    首先在调用程序的CALL语句列出要传递的参数。<br>    CALL PROC VAR1 .<br>    然后在被调用程序的过程部标题，使用USING短语列出相应的参数。<br>    PROCEDURE DIVISION USING VAR1.<br>    最后在被调用程序的连接节(LINKAGE SECTION)提供参数的存储空间。<br>    LINKAGE SECTION.<br>    01 VAR1 PIC XX.\r\n<p>   参数传递有2中方式:<br>    BY CONTENT    传递的参数值只在被调用函数中被改变，调用函数中的值不变。<br>    BY REFERENCE. 传递的参数值在被调用函数中被改变，调用函数中的值也改变。<br>    CALL PROC VAR1 BY CONTENT/REFERENCE.\r\n<p>   再次调用子程序，子程序处于上次退出的状态（除了连接节中的数据），打开的文件依然打开。<br>    可以用INITIAL声明函数被调用时处于初始状态。<br>    PROGRAM-ID. PROC-C IS INITIAL PROGRAM.\r\n<p>   如果不想每次执行都初始化，只在需要的时候初始化，可以用CANCEL PROC.初始化PROC程序，但不执行PROC。</p>\r\n<p><a href=\"http://blog.sina.com.cn/s/blog_6a5ecd650100qrt4.html\">http://blog.sina.com.cn/s/blog_6a5ecd650100qrt4.html</a></p>\r\n', null, null, null, '2020-10-18 21:18:10', '2020-10-18 21:25:58', '1');
INSERT INTO `articles` VALUES ('51', '1', '日语语音之清音、浊音、半浊音、长音、促音、拨音、拗音', '', '清音あ ア a い イ i う ウ u え エ e お オ o\r\nか カ ka き キ ki く ク ku け ケ ke こ コ ko\r\nさ サ sa し シ si/shi す ス su せ セ se そ ソ so\r\nた タ ta ち チ chi つ ツ tsu て テ te と ト to\r\nな ナ na に ニ ni ぬ ヌ nu ね ネ ne の ノ no\r\nは ハ ha ひ ヒ hi ふ フ fu へ ヘ he ほ ホ ho\r\nま マ ma み ミ mi む ム mu め メ me も モ mo\r\nや ヤ ya ゆ ユ yu よ ヨ yo\r\nら ラ ra り リ ri る ル ru れ レ re ろ ロ ro\r\nわ ワ wa を ヲ o/wo\r\nん ン n\r\n\r\n浊音\r\n日语的浊音是由清音假名「か」、「さ」、「た」、「は」四行派生出来的，共20个。浊音符号为「ﾞ」，书写方法是在清音假名的右上角添加即可。\r\n\r\nが 行\r\n平假名 　　が 　　ぎ 　　ぐ 　　げ 　　ご\r\n片假名 　　ガ 　　ギ 　　グ 　　ゲ 　　ゴ\r\n罗马字 　　ga gi gu ge go\r\nが行五个假名「が」、「ぎ」、「ぐ」、「げ」、「ご」，是由辅音[g]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。が行假名位于词中或词尾时有鼻浊音现象，这时发音由[η]加元音拼合而成。\r\n\r\nざ 行\r\n平假名 　　ざ 　　じ 　　ず 　　ぜ 　　ぞ\r\n片假名 　　ザ 　　ジ 　　ズ 　　ゼ 　　ゾ\r\n罗马字 　　za zi zu ze zo\r\nざ行假名五个假名「ざ」、「じ」、「ず」、「ぜ」、「ぞ」，是由辅音[z]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。其中「じ」发音成[ji]，「ず」发音成[zi]。\r\n\r\nだ 行\r\n平假名 　　だ 　　ぢ 　　づ 　　で 　　ど\r\n片假名 　　ダ 　　ヂ 　　ヅ 　　デ 　　ド\r\n罗马字 da di du de do\r\nだ行五个假名「だ」、「ぢ」、「づ」、「で」、「ど」，是由辅音[d]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。\r\n注：だ行的假名「ぢ」、「づ」与ざ行的假名「じ」、「ず」的发音完全相同。现代日语中除了连浊现象及某些习惯用法外，一般都用「じ」和「ず」\r\n例：はなぢ（鼻血）中的「ぢ」属于连浊现象。\r\n\r\nば 行\r\n平假名 　　ば 　　び 　　ぶ 　　べ 　　ぼ\r\n片假名 　　バ 　　ビ 　　ブ 　　ベ 　　ボ\r\n罗马字 　　ba bi bu be bo\r\nば行五个假名「ば」、「び」、「ぶ」、「べ」、「ぼ」，是由辅音[b]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。\r\n\r\n半浊音\r\n日语的半浊音只有一行，共5个。其书写方法是在「は」行假名的右上角添加半浊音符号「ﾟ」即可。\r\n\r\nぱ 行\r\n平假名 　　ぱ 　　ぴ 　　ぷ 　　ぺ 　　ぽ\r\n片假名 　　パ 　　ピ 　　プ 　　ペ 　　ポ\r\n罗马字 pa pi pu pe po\r\nぱ行五个假名「ぱ」、「ぴ」、「ぷ」、「ぺ」、「ぽ」，是由辅音[p]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。\r\n\r\n长音\r\n日语的音节有短音节和长音节的区别。一个假名就是一个音节，也就是一拍，称为短音。把假名的发音时间延长一拍就成了长音，其长度相当于两个音拍。其书写方法是：片假名的长音用“－”来表示，平假名的长音是有规律的，表记规则如下\r\n\r\nあ段假名后用「あ」\r\n例：おかあさん（妈妈）おばあさん（奶奶）\r\n\r\nい段假名后用「い」\r\n例：おにいさん（哥哥）おじいさん（爷爷）\r\n\r\nう段假名后用「う」\r\n例：つうやく（口语翻译）くうき （空气）\r\n\r\nえ段假名后用「い」或「え」，不过常用「い」\r\n例：せんせい（老师） えいが（电影）おねえさん（用「え」）\r\n\r\nお段假名后用「う」或「お」，不过常用「う」\r\n例：おとうさん（爸爸）とうよう（东洋） おおきい （用「お」）\r\n\r\n片假名用「―」\r\n例：カード（卡片） センター （中心）\r\n\r\n注：一定要记住长音是拉长一拍，不要读后面所跟的假名，所以おかあさん只需拉长か再读さん即可。\r\n\r\n促音\r\n日语中促音是用小写「つ」来表示的，即「っ」。一般不发音，促音的要点就是为准备下一个音而等待一拍，所以促音虽然不发音却也占一拍。\r\n例：はっきり（清晰地，清楚地）中「っ」不发音，它只是为准备下一个[k]音而等待一拍。\r\n\r\n注：促音虽然不发音，但是有无促音也会改变词义。\r\n例：さっか是作家的意思，さか却是坡的意思。\r\n\r\n拨音\r\n日语中的「ん」称为拨音，其平假名的书写是「ん」，片假名是「ン」，罗马字是[n]。它不能单独使用，只能附在其他假名后面。发音时，拨音占一拍。\r\n\r\n发拨音时：声带震动，小舌下垂，后舌面抬高，堵住口腔通道，使气流从鼻腔流出。相当于汉语“新”“森”的末尾音，不同的是拨音本身要占一拍。\r\n\r\n拗音\r\n\r\n片假名　平假名　罗马字拼音　汉语读音　\r\n\r\n\r\nキャ　キュ　キョ　きゃ　きゅ　きょ　KYA　KYU　KYO克衣呀　克衣由　克哟　\r\n\r\n\r\nシャ　シュ　ショ　しゃ　しゅ　しょ　SYA　SYU　SYO西衣呀　西衣由　西哟　\r\n\r\n\r\nチャ　チュ　チョ　ちゃ　ちゅ　ちょ　CHA　CHU　CHO七衣呀　七衣由　七哟　\r\n\r\n\r\nニャ　ニュ　ニョ　にゃ　にゅ　にょ　NYA　NYU　NYO呢衣呀　呢衣由　呢哟　\r\n\r\n\r\nヒャ　ヒュ　ヒョ　ひゃ　ひゅ　ひょ　HYA　HYU　HYO喝衣呀　喝衣由　喝哟　\r\n\r\n\r\nミャ　ミュ　ミョ　みゃ　みゅ　みょ　MYA　MYU　MYO咪衣呀　咪衣由　咪哟', '<p>清音あ ア a い イ i う ウ u え エ e お オ o<br>か カ ka き キ ki く ク ku け ケ ke こ コ ko<br>さ サ sa し シ si/shi す ス su せ セ se そ ソ so<br>た タ ta ち チ chi つ ツ tsu て テ te と ト to<br>な ナ na に ニ ni ぬ ヌ nu ね ネ ne の ノ no<br>は ハ ha ひ ヒ hi ふ フ fu へ ヘ he ほ ホ ho<br>ま マ ma み ミ mi む ム mu め メ me も モ mo<br>や ヤ ya ゆ ユ yu よ ヨ yo<br>ら ラ ra り リ ri る ル ru れ レ re ろ ロ ro<br>わ ワ wa を ヲ o/wo<br>ん ン n\r\n<p>浊音<br>日语的浊音是由清音假名「か」、「さ」、「た」、「は」四行派生出来的，共20个。浊音符号为「ﾞ」，书写方法是在清音假名的右上角添加即可。\r\n<p>が 行<br>平假名 　　が 　　ぎ 　　ぐ 　　げ 　　ご<br>片假名 　　ガ 　　ギ 　　グ 　　ゲ 　　ゴ<br>罗马字 　　ga gi gu ge go<br>が行五个假名「が」、「ぎ」、「ぐ」、「げ」、「ご」，是由辅音[g]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。が行假名位于词中或词尾时有鼻浊音现象，这时发音由[η]加元音拼合而成。\r\n<p>ざ 行<br>平假名 　　ざ 　　じ 　　ず 　　ぜ 　　ぞ<br>片假名 　　ザ 　　ジ 　　ズ 　　ゼ 　　ゾ<br>罗马字 　　za zi zu ze zo<br>ざ行假名五个假名「ざ」、「じ」、「ず」、「ぜ」、「ぞ」，是由辅音[z]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。其中「じ」发音成[ji]，「ず」发音成[zi]。\r\n<p>だ 行<br>平假名 　　だ 　　ぢ 　　づ 　　で 　　ど<br>片假名 　　ダ 　　ヂ 　　ヅ 　　デ 　　ド<br>罗马字 da di du de do<br>だ行五个假名「だ」、「ぢ」、「づ」、「で」、「ど」，是由辅音[d]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。<br>注：だ行的假名「ぢ」、「づ」与ざ行的假名「じ」、「ず」的发音完全相同。现代日语中除了连浊现象及某些习惯用法外，一般都用「じ」和「ず」<br>例：はなぢ（鼻血）中的「ぢ」属于连浊现象。\r\n<p>ば 行<br>平假名 　　ば 　　び 　　ぶ 　　べ 　　ぼ<br>片假名 　　バ 　　ビ 　　ブ 　　ベ 　　ボ<br>罗马字 　　ba bi bu be bo<br>ば行五个假名「ば」、「び」、「ぶ」、「べ」、「ぼ」，是由辅音[b]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。\r\n<p>半浊音<br>日语的半浊音只有一行，共5个。其书写方法是在「は」行假名的右上角添加半浊音符号「ﾟ」即可。\r\n<p>ぱ 行<br>平假名 　　ぱ 　　ぴ 　　ぷ 　　ぺ 　　ぽ<br>片假名 　　パ 　　ピ 　　プ 　　ペ 　　ポ<br>罗马字 pa pi pu pe po<br>ぱ行五个假名「ぱ」、「ぴ」、「ぷ」、「ぺ」、「ぽ」，是由辅音[p]分别与あ行五个元音「あ」、「い」、「う」、「え」、「お」拼合而成。\r\n<p>长音<br>日语的音节有短音节和长音节的区别。一个假名就是一个音节，也就是一拍，称为短音。把假名的发音时间延长一拍就成了长音，其长度相当于两个音拍。其书写方法是：片假名的长音用“－”来表示，平假名的长音是有规律的，表记规则如下\r\n<p>あ段假名后用「あ」<br>例：おかあさん（妈妈）おばあさん（奶奶）\r\n<p>い段假名后用「い」<br>例：おにいさん（哥哥）おじいさん（爷爷）\r\n<p>う段假名后用「う」<br>例：つうやく（口语翻译）くうき （空气）\r\n<p>え段假名后用「い」或「え」，不过常用「い」<br>例：せんせい（老师） えいが（电影）おねえさん（用「え」）\r\n<p>お段假名后用「う」或「お」，不过常用「う」<br>例：おとうさん（爸爸）とうよう（东洋） おおきい （用「お」）\r\n<p>片假名用「―」<br>例：カード（卡片） センター （中心）\r\n<p>注：一定要记住长音是拉长一拍，不要读后面所跟的假名，所以おかあさん只需拉长か再读さん即可。</p>\r\n<p>促音<br>日语中促音是用小写「つ」来表示的，即「っ」。一般不发音，促音的要点就是为准备下一个音而等待一拍，所以促音虽然不发音却也占一拍。<br>例：はっきり（清晰地，清楚地）中「っ」不发音，它只是为准备下一个[k]音而等待一拍。\r\n<p>注：促音虽然不发音，但是有无促音也会改变词义。<br>例：さっか是作家的意思，さか却是坡的意思。\r\n<p>拨音<br>日语中的「ん」称为拨音，其平假名的书写是「ん」，片假名是「ン」，罗马字是[n]。它不能单独使用，只能附在其他假名后面。发音时，拨音占一拍。\r\n<p>发拨音时：声带震动，小舌下垂，后舌面抬高，堵住口腔通道，使气流从鼻腔流出。相当于汉语“新”“森”的末尾音，不同的是拨音本身要占一拍。</p>\r\n<p>拗音</p>\r\n<p>片假名　平假名　罗马字拼音　汉语读音　</p>\r\n<p>キャ　キュ　キョ　きゃ　きゅ　きょ　KYA　KYU　KYO克衣呀　克衣由　克哟　</p>\r\n<p>シャ　シュ　ショ　しゃ　しゅ　しょ　SYA　SYU　SYO西衣呀　西衣由　西哟　</p>\r\n<p>チャ　チュ　チョ　ちゃ　ちゅ　ちょ　CHA　CHU　CHO七衣呀　七衣由　七哟　</p>\r\n<p>ニャ　ニュ　ニョ　にゃ　にゅ　にょ　NYA　NYU　NYO呢衣呀　呢衣由　呢哟　</p>\r\n<p>ヒャ　ヒュ　ヒョ　ひゃ　ひゅ　ひょ　HYA　HYU　HYO喝衣呀　喝衣由　喝哟　</p>\r\n<p>ミャ　ミュ　ミョ　みゃ　みゅ　みょ　MYA　MYU　MYO咪衣呀　咪衣由　咪哟</p>\r\n', null, null, null, '2020-10-18 21:28:51', '2020-10-18 21:28:51', '1');
INSERT INTO `articles` VALUES ('52', '1', '日语五十音图快速记忆法', '', '日语五十音图快速记忆法\r\n\r\n \r\n\r\nいイ i ‘い’通汉字‘以’，也念i，所以很好记的。‘イ’呢，我每次看到它就会想起汉字‘依’，也就记住了。\r\n\r\n \r\n\r\nうウ u ‘う’表示你发音时的样子，上嘴唇倾斜，下巴朝上撅，就发出了u。‘ウ’代表一个人，左胳膊好好的，右胳膊给生生截掉一半，他疼啊，在55的哭呢。念u。\r\n\r\n \r\n\r\nえ  エ e ‘え’通汉字‘衣’，读音稍微改变了一些，成了e。‘エ’可以看成大写的英文字母I，很自然就读出e音来了。\r\n\r\n \r\n\r\nお  オ o ‘お’是一个人帽子被风吹走了，他急了，嗷嗷叫着去追帽子，所以读o。‘オ’片假名像是哈里波特穿上了一件魔法斗篷在空中飞翔，好爽啊，他激动的嗷嗷大叫。读o。\r\n\r\n \r\n\r\nかカ ka ‘か’各位应该比较熟悉吧？在漫画中经常会出现这个字，表示卡卡的声音，这个假名应该记起来不难，再说，力量给人的感觉就是干净利索的，发ka也让人感到有力。‘カ’跟‘か’很接近，书写正规些而已，容易记，ka。\r\n\r\n \r\n\r\nきキ ki ‘き’是一把刀子在刻东西，已经刻了一点了，刻就是ki了。‘キ’只剩下刀子了，但也是刻，ki。\r\n\r\n \r\n\r\nくク ku ‘く’很容易记，你把嘴的角度调整成‘く’的样子，是不是自然而然就发出了ku音呢？‘ク’是一只没有眼珠眼睛（是侧面图，片假名‘タ’是有眼珠的眼睛），为什么看不到眼珠呢？因为她在哭，念ku。\r\n\r\n \r\n\r\nけケ ke ’け’是一扇门，门锁被打开了，门自然就开了，读ke。‘ケ’片假名是眼睛，但明显要比‘ク’大，因为眼睛张开了，（眼珠呢？可能张太大掉了），读ke。\r\n\r\n \r\n\r\nこコ ko ‘こ’是你读ko时的嘴型，嘴分得很开。‘コ’也是嘴型，只不过方向变了一下，嘴分开，大声念，ko。\r\n\r\n \r\n\r\nさサ sa ‘さ’通‘杀’，仔细看的话，像一把匕首刺入了一个人的脖子，杀人啦，所以是sa。‘サ’也是在杀人，左边的一竖是一个人，右边的一竖是他手中的弓，那一横表示他在开弓放箭，还是杀人，读sa。\r\n\r\n \r\n\r\nしシ si ‘し’这个平假名像是一只喝饮料的吸管，所以念xi。‘シ’这个片假名要跟后面那个‘ミ（mi）’结合起来记忆，合起来不就是米西吗。米西之前，眼儿眯着，嘴儿抿着，就是‘ミ’这个样子，开始米西了，瞪着眼，伸直了胳膊去抢，就成了‘シ’。\r\n\r\n \r\n\r\nすス su ’す’ 这个平假名看起来像挂在竹竿上的丝线，所以念si。’ス’呢，是晾晒完毕的丝线开始加工了，两股合为一股，所以也是si。\r\n\r\n \r\n\r\nせセ se ‘せ’这个平假名是一只手在往口袋里面塞东西呢，念se。塞呀塞，塞进去了，好了，就成了‘セ’了。\r\n\r\n \r\n\r\nそソ so ‘そ’这个平假名，讲了一个女人不守妇道的故事，这个女人啊，很不像话，下面露着肚子，上面露出她尖尖的小奶，好不风骚，所以念so。‘ソ’这个片假名我是很犯难的，它跟后面的‘ン’很像，容易搞混，所以最好把它看做英文字母‘y’，因为‘そ’是比较骚的，所以你不得不对她yy啦。记住了，读so。\r\n\r\n \r\n\r\nたタ ta ‘た’这个平假名通汉字‘他’，读ta。‘タ’呢，是一只眼睛，还有黑眼珠，你自己肯定不能从侧面看到你的眼睛啦，肯定是看他人的时候啦。所以这不是你的眼睛，是ta。\r\n\r\n \r\n\r\nちチ ti ‘ち’这个平假名很像是七，虽然下面多了一些零碎，但也是七，你把它看成七就成了，很好记，读音是qi。‘チ’看起来不像七了，倒像是千，没关系，千的发音也很像qi。\r\n\r\n \r\n\r\nつツ tu ‘つ’是日语中的促音，是很常见的，促音的发音也是tsu，很容易记。‘ツ’是你发音时的样子，两个鼻孔张开，嘴成一条缝，蛮形象的。\r\n\r\n \r\n\r\nてテ te ‘て’这个平假名引人注目的是下面那个半圆，像什么呢？像是孕妇的大肚子，看来是怀胎了，所以读te。‘テ’呢，说明这个人重男轻女，一开始生了个女孩，不满意，又要了第二胎，二表示是二胎，下面那个小东西说明生了个带把儿的，这下满意啦？记住读te。\r\n\r\n \r\n\r\nとト to ‘と’是一个男人正跪在那里费力的脱裤子，所以读to。‘ト’呢，很明显，裤子脱掉了，男人还很没羞的站了起来，就成这个样子了。总之都是to。\r\n\r\n \r\n\r\nなナ na ‘な’这个平假名不太好写，但是记起来却不难。仔细看，上面的十字和点中间形成了一个小缺口，下面的那个东西好像一个人在指向那个缺口，想像一下警匪片中，警察追捕坏人，但是拐了一个弯儿坏人不见了，一个警察扫视了一下周围的环境，发现了一个缺口，伸手一指，大声说：长官，哪儿！所以这个假名就读na 了，我这么记，记得很牢固。再看‘ナ’，这个片假名左看右看都少了点东西，要是再多个捺就好了，可惜了一个大字。少什么你就念什么就可以了，所以就念na 了。\r\n\r\n \r\n\r\nに二ni因为‘二’通汉字‘尔’，也就是你的意思，所以‘に’这个平假名看主体就是表示你，所以读ni。‘二’更明显了，明显就是ni嘛。\r\n\r\n \r\n\r\nぬヌ nu ‘ぬ’通汉字‘奴’，非常好记，读nu。‘ヌ’呢，是对劳动中的奴隶的一只胳膊的特写，请注意看，胳膊上还带着手铐，唉，悲惨的奴隶。\r\n\r\n \r\n\r\nねネ ne ‘ね’的左边是一个小孩，瘦小柔弱，右边是妈**乳房（下垂扁平而又大头），母亲在奶自己的孩子，是nai。‘ネ’呢，大家看，孩子已经长大了，成了顶天立地的男子汉了，他的母亲已经苍凉，mimi已经成为了干瘪的一点。一个感人的故事，关于nai的故事。\r\n\r\n \r\n\r\nのノ no ‘の’这个假名我不想多讲了，这个是极其常见的一个日语假名，是‘的’的意思，读音是no，这个不用刻意去记也记住了。‘ノ’是‘の’的一个简写，只保留了‘の’的第一笔，也挺好记的，不啰嗦了。\r\n\r\n \r\n\r\nはハ ha ‘は’这个平假名左边是一个人在翩翩起舞，右边是站成一条线的围观的人，有人跳舞给大家看，大家当然高兴啦，每个人都笑哈哈。读ha。‘ハ’呢，请尽量去联系汉字‘哈’来记，‘ハ’相当于哈的右上部分，请多多联系。\r\n\r\n \r\n\r\nひヒ hi ‘ひ’是一个人在微笑的笑脸，虽然有些夸张，但还是能看出是在：）来，笑的有点大，所以出声了，嘿嘿的笑，读hi。‘ヒ’呢是一把匕首，这把匕首能让你白刀子进去黑刀子出来，为什么是黑刀子呢？因为在这里写字不具有彩色功能，没办法，只好黑刀子啦。这把刀子现在已经黑啦，就读hi。\r\n\r\n \r\n\r\nふフ hu ‘ふ’充分展现了一个大丈夫的形象，就是上面的大头很小，下面的小头却很大，哈哈，好猛啊，是个大丈夫。读fu。‘フ’说明大丈夫在家里却没什么了不起，见了太太照样要低三下四，还要卑躬屈膝，好惨啊。‘フ’是大丈夫在下跪呢。\r\n\r\n \r\n\r\nへへ he ‘へ’这个平假名让人想起了大海上的波涛，读he。片假名‘へ’与平假名极其相似，这个记起来就容易多了。\r\n\r\n \r\n\r\nほホ ho ‘ほ’呢，还是大家在看一个人在跳舞，不过这次舞者在头上顶了一个盘子跳，这可是真功夫，有水平，大家都给她叫好，所以你见了也要叫ho。过了一会儿，跳舞的姑娘旋转起来，裙子都像伞一样撑开了，成了‘ホ’，好精彩啊，你还不叫好？\r\n\r\n \r\n\r\nまマ ma ‘ま’通‘马’，是一个人骑在马背上的俯视图，读ma。‘マ’是‘马’的缩写，写完第一笔后，其余的缩成一个点，但还是个马。\r\n\r\n \r\n\r\nみミ mi ‘み’这个假名看起来乱七八糟的，其实不然，你要善于抓住重点。看仔细了，左边那个小圈，还有点下垂，明显是一个大头的mimi嘛（汗，这样的mimi也太有特色了），忍忍吧，为了记住这个假名，它就是个大mimi啦，读mi。‘ミ’这个片假名要跟前面那个‘シ（xi）’结合起来记忆，合起来不就是米西吗。米西之前，眼儿眯着，嘴儿抿着，就是‘ミ’这个样子，开始米西了，瞪着眼，伸直了胳膊去抢，就成了‘シ’。\r\n\r\n \r\n\r\nむム mu ‘む’像一头牛，正在mu，mu叫着呢。‘ム’呢，是牟的一部分，二者联系起来的话，很容易记住。读mu。\r\n\r\n \r\n\r\nめメ me ‘め’很像‘女’字，而‘メ’像是一把匕首，你想想用刀子逼迫一个女人还能干什么呢？当然是拿去让她卖啦，所以读me。\r\n\r\n \r\n\r\nもモ mo ‘も’一眼看上去就像是汉字‘毛’，日本人为了不让别人说他一毛不拔，就狠狠心拔了一毛，成了现在这个样子，很好记，你看成毛就可以了。‘モ’写得更正规了一些，更像毛了，读音也是mo。\r\n\r\n \r\n\r\nやヤ ya以前网上有个帖子，讨论用马桶大便的时候如何压水花的问题，日本人在这里给出了解释。你看‘や’，坐在马桶上，便便已经快落进去了，但是水花没有压好，溅出来了一点，好臭啊，没压好。而‘ヤ’就很棒，一点都没有水花，因为坐得靠前了嘛。这就是ya。\r\n\r\n \r\n\r\nゆユ yu ‘ゆ’在我看来就是一个幼女的‘幼’的草写，一看到它，就是yu了。‘ユ’呢，很明显是一只手，四指握拳，大拇指朝右，给你指方向呢。读yu。\r\n\r\n \r\n\r\nよヨ yo ‘よ’这个假名我看了一眼就记住了，因为它的样子就像一把钥匙，读yo就很自然了。‘ヨ’呢，是所有假名里面含数字‘1（读yao）’最多的一个假名，横竖加起来有4个1，自然，由1组成的‘ヨ’也就读yo啦。\r\n\r\n \r\n\r\nらラ ra ‘ら’这个假名相当好笑，你看那个人低着头蹲那儿在干什么呢？拉屎呗，那这个假名就是la了。‘ラ’也相当好记，拉完了，人走了，只剩下了马桶，而且马桶盖也盖上了，这个是拉完了的la。\r\n\r\nりリ ri ‘り’也是一个容易记忆的假名，两个人立在哪儿，自然就是li了。‘リ’立得更直一些了，反正都是li。\r\n\r\n \r\n\r\nるル ru ‘る’表示的是发音时的口型，先发‘L’音，此时你的舌头是向上翘的，‘る’的上半部分就是代表向上的舌头，下面是一个大圈加一个小圈，代表你发’U’音的时候，你的口型由大变小。所以你看到‘る’这个假名，自然而然就把它读出来了。‘ル’呢，是写得比较夸张的‘LU’，也是表示出了读音，lu。\r\n\r\n \r\n\r\nれレ re ‘れ’我看着像礼品的‘礼’，当有人提着礼品来了，你肯定会迫不及待地冲人家喊，来来来，所以见了礼，你就喊le就行了。刚才是别人拿着礼，现在这个‘レ’是你看到礼来了的表现，你仰着脖子，大喊，来—————\r\n\r\n \r\n\r\nろ  ロ  lo  ‘ろ’也是发音时的口型，上面是发‘L’时的口型，下面嘴大张着，这是在发‘O’呢，所以一看到‘ろ’你就张嘴发lo。‘ロ’呢，是用两个‘L’组成了发音时的口型，很自然就发出了lo音了。\r\n\r\n \r\n\r\nわワ wa这个假名念wa，一般人在惊讶的情况下才会哇的一声，这里也是这个样子。‘わ’表示一位亭亭玉立的少女，突然裙子被大风给卷起来了，你看了不替她着急吗？一急就wa的一声叫出来了。‘ワ’看上去是一张大张着的嘴，右边那一竖是一串黄鼻涕，快进到嘴里去啦。wa！\r\n\r\n \r\n\r\nをヲ wo ‘を’这个假名呢，代表比较刺激的事情，才会嗷嗷叫。‘を’好像一个人去游泳，先把一只脚放到水池里试一试水温，wa，好凉。（其实把‘を’看成体位的话会更生动啦）。‘ヲ’呢，你有办法把它想成体位也可以啦，如果不能，你就可以把它看成一个人在滑雪或冲浪，正在腾空而起，好刺激。所以读o。\r\n\r\n \r\n\r\nんン n ‘ん’很像字母‘n’，只不过头上长了一些，你把它当成n就记住了。‘ン’呢，又是一个发音表情，上边一点表示鼻子，下面一画表示闭着的嘴，怎么样？你发n的时候是不是这个样子呢？这个假名轻读n。\r\n\r\n  \r\n\r\nあア a‘あ’看上去像是一个武术高手施展了一个扫堂腿，敌人肯定被扫得冷落花流水，啊的一声倒下去啦，所以读a。‘ア’片假名指示出了你发音的样子，嘴巴张开，舌头放到下面，a。', '<p>日语五十音图快速记忆法</p>\r\n<p>いイ i ‘い’通汉字‘以’，也念i，所以很好记的。‘イ’呢，我每次看到它就会想起汉字‘依’，也就记住了。</p>\r\n<p>うウ u ‘う’表示你发音时的样子，上嘴唇倾斜，下巴朝上撅，就发出了u。‘ウ’代表一个人，左胳膊好好的，右胳膊给生生截掉一半，他疼啊，在55的哭呢。念u。</p>\r\n<p>え  エ e ‘え’通汉字‘衣’，读音稍微改变了一些，成了e。‘エ’可以看成大写的英文字母I，很自然就读出e音来了。</p>\r\n<p>お  オ o ‘お’是一个人帽子被风吹走了，他急了，嗷嗷叫着去追帽子，所以读o。‘オ’片假名像是哈里波特穿上了一件魔法斗篷在空中飞翔，好爽啊，他激动的嗷嗷大叫。读o。</p>\r\n<p>かカ ka ‘か’各位应该比较熟悉吧？在漫画中经常会出现这个字，表示卡卡的声音，这个假名应该记起来不难，再说，力量给人的感觉就是干净利索的，发ka也让人感到有力。‘カ’跟‘か’很接近，书写正规些而已，容易记，ka。</p>\r\n<p>きキ ki ‘き’是一把刀子在刻东西，已经刻了一点了，刻就是ki了。‘キ’只剩下刀子了，但也是刻，ki。</p>\r\n<p>くク ku ‘く’很容易记，你把嘴的角度调整成‘く’的样子，是不是自然而然就发出了ku音呢？‘ク’是一只没有眼珠眼睛（是侧面图，片假名‘タ’是有眼珠的眼睛），为什么看不到眼珠呢？因为她在哭，念ku。</p>\r\n<p>けケ ke ’け’是一扇门，门锁被打开了，门自然就开了，读ke。‘ケ’片假名是眼睛，但明显要比‘ク’大，因为眼睛张开了，（眼珠呢？可能张太大掉了），读ke。</p>\r\n<p>こコ ko ‘こ’是你读ko时的嘴型，嘴分得很开。‘コ’也是嘴型，只不过方向变了一下，嘴分开，大声念，ko。</p>\r\n<p>さサ sa ‘さ’通‘杀’，仔细看的话，像一把匕首刺入了一个人的脖子，杀人啦，所以是sa。‘サ’也是在杀人，左边的一竖是一个人，右边的一竖是他手中的弓，那一横表示他在开弓放箭，还是杀人，读sa。</p>\r\n<p>しシ si ‘し’这个平假名像是一只喝饮料的吸管，所以念xi。‘シ’这个片假名要跟后面那个‘ミ（mi）’结合起来记忆，合起来不就是米西吗。米西之前，眼儿眯着，嘴儿抿着，就是‘ミ’这个样子，开始米西了，瞪着眼，伸直了胳膊去抢，就成了‘シ’。</p>\r\n<p>すス su ’す’ 这个平假名看起来像挂在竹竿上的丝线，所以念si。’ス’呢，是晾晒完毕的丝线开始加工了，两股合为一股，所以也是si。</p>\r\n<p>せセ se ‘せ’这个平假名是一只手在往口袋里面塞东西呢，念se。塞呀塞，塞进去了，好了，就成了‘セ’了。</p>\r\n<p>そソ so ‘そ’这个平假名，讲了一个女人不守妇道的故事，这个女人啊，很不像话，下面露着肚子，上面露出她尖尖的小奶，好不风骚，所以念so。‘ソ’这个片假名我是很犯难的，它跟后面的‘ン’很像，容易搞混，所以最好把它看做英文字母‘y’，因为‘そ’是比较骚的，所以你不得不对她yy啦。记住了，读so。</p>\r\n<p>たタ ta ‘た’这个平假名通汉字‘他’，读ta。‘タ’呢，是一只眼睛，还有黑眼珠，你自己肯定不能从侧面看到你的眼睛啦，肯定是看他人的时候啦。所以这不是你的眼睛，是ta。</p>\r\n<p>ちチ ti ‘ち’这个平假名很像是七，虽然下面多了一些零碎，但也是七，你把它看成七就成了，很好记，读音是qi。‘チ’看起来不像七了，倒像是千，没关系，千的发音也很像qi。</p>\r\n<p>つツ tu ‘つ’是日语中的促音，是很常见的，促音的发音也是tsu，很容易记。‘ツ’是你发音时的样子，两个鼻孔张开，嘴成一条缝，蛮形象的。</p>\r\n<p>てテ te ‘て’这个平假名引人注目的是下面那个半圆，像什么呢？像是孕妇的大肚子，看来是怀胎了，所以读te。‘テ’呢，说明这个人重男轻女，一开始生了个女孩，不满意，又要了第二胎，二表示是二胎，下面那个小东西说明生了个带把儿的，这下满意啦？记住读te。</p>\r\n<p>とト to ‘と’是一个男人正跪在那里费力的脱裤子，所以读to。‘ト’呢，很明显，裤子脱掉了，男人还很没羞的站了起来，就成这个样子了。总之都是to。</p>\r\n<p>なナ na ‘な’这个平假名不太好写，但是记起来却不难。仔细看，上面的十字和点中间形成了一个小缺口，下面的那个东西好像一个人在指向那个缺口，想像一下警匪片中，警察追捕坏人，但是拐了一个弯儿坏人不见了，一个警察扫视了一下周围的环境，发现了一个缺口，伸手一指，大声说：长官，哪儿！所以这个假名就读na 了，我这么记，记得很牢固。再看‘ナ’，这个片假名左看右看都少了点东西，要是再多个捺就好了，可惜了一个大字。少什么你就念什么就可以了，所以就念na 了。</p>\r\n<p>に二ni因为‘二’通汉字‘尔’，也就是你的意思，所以‘に’这个平假名看主体就是表示你，所以读ni。‘二’更明显了，明显就是ni嘛。</p>\r\n<p>ぬヌ nu ‘ぬ’通汉字‘奴’，非常好记，读nu。‘ヌ’呢，是对劳动中的奴隶的一只胳膊的特写，请注意看，胳膊上还带着手铐，唉，悲惨的奴隶。</p>\r\n<p>ねネ ne ‘ね’的左边是一个小孩，瘦小柔弱，右边是妈**乳房（下垂扁平而又大头），母亲在奶自己的孩子，是nai。‘ネ’呢，大家看，孩子已经长大了，成了顶天立地的男子汉了，他的母亲已经苍凉，mimi已经成为了干瘪的一点。一个感人的故事，关于nai的故事。</p>\r\n<p>のノ no ‘の’这个假名我不想多讲了，这个是极其常见的一个日语假名，是‘的’的意思，读音是no，这个不用刻意去记也记住了。‘ノ’是‘の’的一个简写，只保留了‘の’的第一笔，也挺好记的，不啰嗦了。</p>\r\n<p>はハ ha ‘は’这个平假名左边是一个人在翩翩起舞，右边是站成一条线的围观的人，有人跳舞给大家看，大家当然高兴啦，每个人都笑哈哈。读ha。‘ハ’呢，请尽量去联系汉字‘哈’来记，‘ハ’相当于哈的右上部分，请多多联系。</p>\r\n<p>ひヒ hi ‘ひ’是一个人在微笑的笑脸，虽然有些夸张，但还是能看出是在：）来，笑的有点大，所以出声了，嘿嘿的笑，读hi。‘ヒ’呢是一把匕首，这把匕首能让你白刀子进去黑刀子出来，为什么是黑刀子呢？因为在这里写字不具有彩色功能，没办法，只好黑刀子啦。这把刀子现在已经黑啦，就读hi。</p>\r\n<p>ふフ hu ‘ふ’充分展现了一个大丈夫的形象，就是上面的大头很小，下面的小头却很大，哈哈，好猛啊，是个大丈夫。读fu。‘フ’说明大丈夫在家里却没什么了不起，见了太太照样要低三下四，还要卑躬屈膝，好惨啊。‘フ’是大丈夫在下跪呢。</p>\r\n<p>へへ he ‘へ’这个平假名让人想起了大海上的波涛，读he。片假名‘へ’与平假名极其相似，这个记起来就容易多了。</p>\r\n<p>ほホ ho ‘ほ’呢，还是大家在看一个人在跳舞，不过这次舞者在头上顶了一个盘子跳，这可是真功夫，有水平，大家都给她叫好，所以你见了也要叫ho。过了一会儿，跳舞的姑娘旋转起来，裙子都像伞一样撑开了，成了‘ホ’，好精彩啊，你还不叫好？</p>\r\n<p>まマ ma ‘ま’通‘马’，是一个人骑在马背上的俯视图，读ma。‘マ’是‘马’的缩写，写完第一笔后，其余的缩成一个点，但还是个马。</p>\r\n<p>みミ mi ‘み’这个假名看起来乱七八糟的，其实不然，你要善于抓住重点。看仔细了，左边那个小圈，还有点下垂，明显是一个大头的mimi嘛（汗，这样的mimi也太有特色了），忍忍吧，为了记住这个假名，它就是个大mimi啦，读mi。‘ミ’这个片假名要跟前面那个‘シ（xi）’结合起来记忆，合起来不就是米西吗。米西之前，眼儿眯着，嘴儿抿着，就是‘ミ’这个样子，开始米西了，瞪着眼，伸直了胳膊去抢，就成了‘シ’。</p>\r\n<p>むム mu ‘む’像一头牛，正在mu，mu叫着呢。‘ム’呢，是牟的一部分，二者联系起来的话，很容易记住。读mu。</p>\r\n<p>めメ me ‘め’很像‘女’字，而‘メ’像是一把匕首，你想想用刀子逼迫一个女人还能干什么呢？当然是拿去让她卖啦，所以读me。</p>\r\n<p>もモ mo ‘も’一眼看上去就像是汉字‘毛’，日本人为了不让别人说他一毛不拔，就狠狠心拔了一毛，成了现在这个样子，很好记，你看成毛就可以了。‘モ’写得更正规了一些，更像毛了，读音也是mo。</p>\r\n<p>やヤ ya以前网上有个帖子，讨论用马桶大便的时候如何压水花的问题，日本人在这里给出了解释。你看‘や’，坐在马桶上，便便已经快落进去了，但是水花没有压好，溅出来了一点，好臭啊，没压好。而‘ヤ’就很棒，一点都没有水花，因为坐得靠前了嘛。这就是ya。</p>\r\n<p>ゆユ yu ‘ゆ’在我看来就是一个幼女的‘幼’的草写，一看到它，就是yu了。‘ユ’呢，很明显是一只手，四指握拳，大拇指朝右，给你指方向呢。读yu。</p>\r\n<p>よヨ yo ‘よ’这个假名我看了一眼就记住了，因为它的样子就像一把钥匙，读yo就很自然了。‘ヨ’呢，是所有假名里面含数字‘1（读yao）’最多的一个假名，横竖加起来有4个1，自然，由1组成的‘ヨ’也就读yo啦。</p>\r\n<p>らラ ra ‘ら’这个假名相当好笑，你看那个人低着头蹲那儿在干什么呢？拉屎呗，那这个假名就是la了。‘ラ’也相当好记，拉完了，人走了，只剩下了马桶，而且马桶盖也盖上了，这个是拉完了的la。</p>\r\n<p>りリ ri ‘り’也是一个容易记忆的假名，两个人立在哪儿，自然就是li了。‘リ’立得更直一些了，反正都是li。</p>\r\n<p>るル ru ‘る’表示的是发音时的口型，先发‘L’音，此时你的舌头是向上翘的，‘る’的上半部分就是代表向上的舌头，下面是一个大圈加一个小圈，代表你发’U’音的时候，你的口型由大变小。所以你看到‘る’这个假名，自然而然就把它读出来了。‘ル’呢，是写得比较夸张的‘LU’，也是表示出了读音，lu。</p>\r\n<p>れレ re ‘れ’我看着像礼品的‘礼’，当有人提着礼品来了，你肯定会迫不及待地冲人家喊，来来来，所以见了礼，你就喊le就行了。刚才是别人拿着礼，现在这个‘レ’是你看到礼来了的表现，你仰着脖子，大喊，来—————</p>\r\n<p>ろ  ロ  lo  ‘ろ’也是发音时的口型，上面是发‘L’时的口型，下面嘴大张着，这是在发‘O’呢，所以一看到‘ろ’你就张嘴发lo。‘ロ’呢，是用两个‘L’组成了发音时的口型，很自然就发出了lo音了。</p>\r\n<p>わワ wa这个假名念wa，一般人在惊讶的情况下才会哇的一声，这里也是这个样子。‘わ’表示一位亭亭玉立的少女，突然裙子被大风给卷起来了，你看了不替她着急吗？一急就wa的一声叫出来了。‘ワ’看上去是一张大张着的嘴，右边那一竖是一串黄鼻涕，快进到嘴里去啦。wa！</p>\r\n<p>をヲ wo ‘を’这个假名呢，代表比较刺激的事情，才会嗷嗷叫。‘を’好像一个人去游泳，先把一只脚放到水池里试一试水温，wa，好凉。（其实把‘を’看成体位的话会更生动啦）。‘ヲ’呢，你有办法把它想成体位也可以啦，如果不能，你就可以把它看成一个人在滑雪或冲浪，正在腾空而起，好刺激。所以读o。</p>\r\n<p>んン n ‘ん’很像字母‘n’，只不过头上长了一些，你把它当成n就记住了。‘ン’呢，又是一个发音表情，上边一点表示鼻子，下面一画表示闭着的嘴，怎么样？你发n的时候是不是这个样子呢？这个假名轻读n。</p>\r\n<p>あア a‘あ’看上去像是一个武术高手施展了一个扫堂腿，敌人肯定被扫得冷落花流水，啊的一声倒下去啦，所以读a。‘ア’片假名指示出了你发音的样子，嘴巴张开，舌头放到下面，a。</p>\r\n', null, null, null, '2020-10-18 21:29:39', '2020-10-18 21:29:39', '1');
INSERT INTO `articles` VALUES ('53', '1', '日语基本句型', '', '编辑导读:日语基本句型5.1.…は…です例：これはふく（服）です。这是衣服。（一般は前面用代词，例如：これ（这个）、それ（那个）5.2.…は…ですか例：それはふく（服）ですか。那是衣服吗？5.3.…はなんですか例：これは何...\r\n 日语基本句型 \r\n5.1. …は…です \r\n例： これはふく（服）です。 \r\n这是衣服。 \r\n（一般は前面用代词，例如：これ（这个）、それ（那个） \r\n5.2. …は…ですか \r\n 例： それはふく（服）ですか。 \r\n那是衣服吗？ \r\n5.3. …はなんですか \r\n 例： これは何（なん）ですか \r\n这是什么？ \r\n5.4. …は…にあります \r\n 例： 本（ほん）は机（つくえ）の上（うえ）にあります。 \r\n桌子上有本书。\r\n5.5. …は…にいます \r\n 例： 部屋は人（ひと）にいます \r\n屋子里有人。 \r\n（ある用于无生命的东西存在，あります是ある终结式，います是いる的终结式） \r\n（いる用于有生命的存在） \r\n5.6. …に…が（も）あります \r\n 例： 部屋に机や椅子（いす）などがあります。 /屋子里有桌子还有椅子等等。 \r\n部屋にラジオ(radio)もあります。 / 屋子里也有收音机。 \r\n5.7. …に…がいます \r\n 例： 椅子の上に猫（ねこ）がいます。 \r\n椅子上有只猫。 \r\n（某处有某个生命体存在） \r\n5.8. …には…があります \r\n 例： そこにはポットがありますか。 \r\n那里有热水瓶吗？ \r\n5.9. …には…はありません \r\n 例： いいえ、ここにはポット(pot)はありません。 \r\n没有，这里没有热水瓶。 \r\n（这两个句子一般用于对话。） \r\n5.10. …に…がいくつありますか \r\n 例： 部屋（へや）に机（つくえ）がいくつ（幾つ）ありますか。 \r\n屋里桌子有几张？ \r\n（いくつ是数词。多少的意思） \r\n5.11. …や…など \r\n 例： そこには本やノート(note)などがあります。 \r\n在那里有书还有本子等。 \r\n（には强调地点） \r\n5.12. …は…ではありません \r\n 例： ここは学校（がっこう）ではありません \r\n学校不在这里。 \r\n     \r\nはい、そうです。 \r\n是，是这样的。 \r\n  \r\nいいえ、ちがい（違い）ます。 \r\n不是，不是的。 \r\n5.13. …を… \r\n 表示移动性的离开、经过、移动等。 \r\n            \r\n 例： 私は毎朝（まいあさ）七時（しちじ）に家（うち）を出（だ）ます \r\n我每天早上七点离开家。 \r\n5.14. 体言（名词） + になる \r\n 例： もう七時になりました。 \r\n已经七点了。 \r\n（表一个状态转向另一个状态） \r\n5.15. …は…が… \r\n 例： 私は料理（りょうり）を作（つく）るのが上手（じょうず）です。 \r\n我会做饭。 \r\n（用于表示人的感情、感觉、巧拙、愿望、拥有、需要、可能等） \r\n5.16. BよりAのほうが…です \r\n 例： 昨日より今日のほど暑（あつ）いです。 \r\n今天比昨天热。 \r\n （与B相比A更…） \r\n5.17. AはBより…です \r\n 例： 中国（ちゅうご）は日本より広（ひろ）いです。 \r\n中国比日本大。\r\n（A比B…）\r\n5.18. …う（よう）と思（おも）います（第一人称） \r\n…う(よう)思っています （第三人称） \r\n? 想…，讲话人讲话时的心理 \r\n? 含讲话时的一段时间的心理 \r\n? 问句用第二人称 \r\n \r\n 例： 将来（しょうらい）、教師（きょうし）になろうと思います。\r\n我将来想当老师。\r\n\r\n父（ちち）はいい家（いえ）を買（か）おうと思っていろいろ見（み）て歩（ある）きました。\r\n父亲想买所好房子看了不少地方。\r\n\r\nあなたは大学（だいがく）に入（い）ろうと思いますか。\r\n你想进大学吗？\r\n5.19. 用言（动词）连体形 + のです \r\n名词 + なのです \r\n口语中常用…んです \r\n（用于解释、说明事实、理由、根据或强调必然的结果。 ）\r\n\r\n 例： その日（ひ）は雨（あめ）が降（眨─盲皮い郡韦扦埂?\r\n那天下雨来着。 \r\n5.20. …つもりです \r\n （表打算做…）\r\n （用つもりです结句时可用第一人称 ）\r\n\r\n 例： 小学生（しょうがくせい）の時（とき）、医者（いしゃ）になるつもりです。\r\n还是小学生的时候想当一名医生。\r\n5.21. 定语 + ために \r\n （表目的。定语可以为名词也可以是动词现在时。 ）\r\n\r\n 例： なんのために日本語を勉強（べんきょう）していますか。\r\n你学习日语是为了什么？\r\n5.22. …は…と言（げん/こと）います \r\n （表示某东西可说成…）\r\n\r\n 例： この町（まち）の名前（なまえ）はホンヴゃオと言（げん/こと）います。 \r\n这个镇叫做[虹桥]。\r\n5.23. …は（…に）…と言います \r\n （某人（对某人）说…）\r\n            \r\n 例： 日本人は朝（あさ）人（ひと）に会（あ）った時（とき）に「おはようございます」と言います。\r\n   日本人对早上遇见的人说：“おはようございます”。\r\n5.24. …を…と言います \r\n （把…叫做…）\r\n            \r\n 例： 日本語ではそれをあいさつの言葉（ことば）と言います。 \r\n 日语中把那个叫做寒暄语。\r\n5.25. …へ…を…に行きます（来ます） \r\n （へ表示来去场所，に表示来去目的）\r\n            \r\n 例： 東京へ何をしに来ましたか。 \r\n   来东京做什么？ \r\n5.26. …ばいい（よい） \r\n （只要…就行）\r\n            \r\n 例： これはどうすればいいですか。\r\n   这怎么做好呢？\r\n5.27. …と思います \r\n …と思いました（思っています \r\n            \r\n （结句时主体一般是わたし。 ）\r\n （结句時主体可以是说话人也可是第三人称。 ）\r\n\r\n 例： 今日はいい天気（てんき）だと思います。 \r\n   我认为今天是个好天气。 \r\n\r\n   田中さんは今日は雨が降ると思いました。\r\n   田中先生认为今天会下雨。\r\n5.28. …（する）前（まえ）に \r\n …（した）後（あと）で \r\n\r\n （…之前 ）\r\n （…之后 ）\r\n\r\n 例： 行く前に.電話（でんわ）で知（し）らせました。\r\n   去之前给对方打个电话。\r\n\r\n   ご飯（はん）を食べた後（あと）で勉強します。\r\n   吃饭之后学习。\r\n5.29. …でしょう\r\n 接各类终止形后，表示推测，意为“大概…吧”。\r\n\r\n 例： ことしの冬（ふゆ）は寒（さむ）くないでしょう。/今年冬天大概不冷吧。\r\n5.30. あまり…ない\r\n [あまり]与否定形式[ない.ません]呼应，表示“不太…”之意。\r\n\r\n 例： 上海の夏（なつ）はあまり暑（あつ）くないです。/上海的夏天不太热。\r\n5.31. …より…のほうが…\r\n 这是比较句的强调句式，意为“与…相比，…（一方）更…”。\r\n\r\n 例： みかんよりぶどうのほうが高（たか）いです。/与桔子相比，葡萄更贵。\r\n5.32. …や…や…など\r\n 意为：“…啦…啦…等等”\r\n\r\n 例： 町には映画館や公園などがあります。/城里有电影院啦公园等。\r\n   テレビやラジオのどは田中さんの部屋にあります。/电视机啦收音机等等都在田中的房间里。\r\n5.33. 疑问词 + も…否定式\r\n 表示全盘否定，意为“（什么）也没有”、“（什么）都不”。\r\n\r\n 例： 部屋にはだれもいません。/房间里一个人也没有。\r\n   いいえ，なんでもありません。/不，什么也不是。\r\n5.34. …も…も\r\n [も]叠加使用，含“…和…都…”之意。\r\n\r\n 例： 李さんも王さんも三年生です。/小李和小王都是大三的学生。\r\n   猫（ねこ）も犬（いぬ）もいません。/猫和狗都没有。\r\n5.35. …（の）ために，…\r\n 接体言加[の]或动词终止形后，表示目的，含“为了…”之意。\r\n\r\n 例： お正月を迎えるために大掃除をしました。/为了迎接新年，做了大扫除。\r\n   父のためにお酒を買いました。/为家父买了酒。\r\n5.36.&n\r\n更多咨询请访问： www.neworldjp.com', '<p>编辑导读:日语基本句型5.1.…は…です例：これはふく（服）です。这是衣服。（一般は前面用代词，例如：これ（这个）、それ（那个）5.2.…は…ですか例：それはふく（服）ですか。那是衣服吗？5.3.…はなんですか例：これは何…<br> 日语基本句型<br>5.1. …は…です<br>例： これはふく（服）です。<br>这是衣服。<br>（一般は前面用代词，例如：これ（这个）、それ（那个）<br>5.2. …は…ですか<br> 例： それはふく（服）ですか。<br>那是衣服吗？<br>5.3. …はなんですか<br> 例： これは何（なん）ですか<br>这是什么？<br>5.4. …は…にあります<br> 例： 本（ほん）は机（つくえ）の上（うえ）にあります。<br>桌子上有本书。<br>5.5. …は…にいます<br> 例： 部屋は人（ひと）にいます<br>屋子里有人。<br>（ある用于无生命的东西存在，あります是ある终结式，います是いる的终结式）<br>（いる用于有生命的存在）<br>5.6. …に…が（も）あります<br> 例： 部屋に机や椅子（いす）などがあります。 /屋子里有桌子还有椅子等等。<br>部屋にラジオ(radio)もあります。 / 屋子里也有收音机。<br>5.7. …に…がいます<br> 例： 椅子の上に猫（ねこ）がいます。<br>椅子上有只猫。<br>（某处有某个生命体存在）<br>5.8. …には…があります<br> 例： そこにはポットがありますか。<br>那里有热水瓶吗？<br>5.9. …には…はありません<br> 例： いいえ、ここにはポット(pot)はありません。<br>没有，这里没有热水瓶。<br>（这两个句子一般用于对话。）<br>5.10. …に…がいくつありますか<br> 例： 部屋（へや）に机（つくえ）がいくつ（幾つ）ありますか。<br>屋里桌子有几张？<br>（いくつ是数词。多少的意思）<br>5.11. …や…など<br> 例： そこには本やノート(note)などがあります。<br>在那里有书还有本子等。<br>（には强调地点）<br>5.12. …は…ではありません<br> 例： ここは学校（がっこう）ではありません<br>学校不在这里。 \r\n<p>はい、そうです。<br>是，是这样的。 \r\n<p>いいえ、ちがい（違い）ます。<br>不是，不是的。<br>5.13. …を…<br> 表示移动性的离开、经过、移动等。 \r\n<p> 例： 私は毎朝（まいあさ）七時（しちじ）に家（うち）を出（だ）ます<br>我每天早上七点离开家。<br>5.14. 体言（名词） + になる<br> 例： もう七時になりました。<br>已经七点了。<br>（表一个状态转向另一个状态）<br>5.15. …は…が…<br> 例： 私は料理（りょうり）を作（つく）るのが上手（じょうず）です。<br>我会做饭。<br>（用于表示人的感情、感觉、巧拙、愿望、拥有、需要、可能等）<br>5.16. BよりAのほうが…です<br> 例： 昨日より今日のほど暑（あつ）いです。<br>今天比昨天热。<br> （与B相比A更…）<br>5.17. AはBより…です<br> 例： 中国（ちゅうご）は日本より広（ひろ）いです。<br>中国比日本大。<br>（A比B…）<br>5.18. …う（よう）と思（おも）います（第一人称）<br>…う(よう)思っています （第三人称）<br>? 想…，讲话人讲话时的心理<br>? 含讲话时的一段时间的心理<br>? 问句用第二人称 \r\n<p> 例： 将来（しょうらい）、教師（きょうし）になろうと思います。<br>我将来想当老师。\r\n<p>父（ちち）はいい家（いえ）を買（か）おうと思っていろいろ見（み）て歩（ある）きました。<br>父亲想买所好房子看了不少地方。\r\n<p>あなたは大学（だいがく）に入（い）ろうと思いますか。<br>你想进大学吗？<br>5.19. 用言（动词）连体形 + のです<br>名词 + なのです<br>口语中常用…んです<br>（用于解释、说明事实、理由、根据或强调必然的结果。 ）\r\n<p> 例： その日（ひ）は雨（あめ）が降（眨─盲皮い郡韦扦埂?<br>那天下雨来着。<br>5.20. …つもりです<br> （表打算做…）<br> （用つもりです结句时可用第一人称 ）\r\n<p> 例： 小学生（しょうがくせい）の時（とき）、医者（いしゃ）になるつもりです。<br>还是小学生的时候想当一名医生。<br>5.21. 定语 + ために<br> （表目的。定语可以为名词也可以是动词现在时。 ）\r\n<p> 例： なんのために日本語を勉強（べんきょう）していますか。<br>你学习日语是为了什么？<br>5.22. …は…と言（げん/こと）います<br> （表示某东西可说成…）\r\n<p> 例： この町（まち）の名前（なまえ）はホンヴゃオと言（げん/こと）います。<br>这个镇叫做[虹桥]。<br>5.23. …は（…に）…と言います<br> （某人（对某人）说…）\r\n<p> 例： 日本人は朝（あさ）人（ひと）に会（あ）った時（とき）に「おはようございます」と言います。<br>   日本人对早上遇见的人说：“おはようございます”。<br>5.24. …を…と言います<br> （把…叫做…）\r\n<p> 例： 日本語ではそれをあいさつの言葉（ことば）と言います。<br> 日语中把那个叫做寒暄语。<br>5.25. …へ…を…に行きます（来ます）<br> （へ表示来去场所，に表示来去目的）\r\n<p> 例： 東京へ何をしに来ましたか。<br>   来东京做什么？<br>5.26. …ばいい（よい）<br> （只要…就行）\r\n<p> 例： これはどうすればいいですか。<br>   这怎么做好呢？<br>5.27. …と思います<br> …と思いました（思っています \r\n<p> （结句时主体一般是わたし。 ）<br> （结句時主体可以是说话人也可是第三人称。 ）\r\n<p> 例： 今日はいい天気（てんき）だと思います。<br>   我认为今天是个好天气。 \r\n<p>   田中さんは今日は雨が降ると思いました。<br>   田中先生认为今天会下雨。<br>5.28. …（する）前（まえ）に<br> …（した）後（あと）で \r\n<p> （…之前 ）<br> （…之后 ）\r\n<p> 例： 行く前に.電話（でんわ）で知（し）らせました。<br>   去之前给对方打个电话。\r\n<p>   ご飯（はん）を食べた後（あと）で勉強します。<br>   吃饭之后学习。<br>5.29. …でしょう<br> 接各类终止形后，表示推测，意为“大概…吧”。\r\n<p> 例： ことしの冬（ふゆ）は寒（さむ）くないでしょう。/今年冬天大概不冷吧。<br>5.30. あまり…ない<br> [あまり]与否定形式[ない.ません]呼应，表示“不太…”之意。\r\n<p> 例： 上海の夏（なつ）はあまり暑（あつ）くないです。/上海的夏天不太热。<br>5.31. …より…のほうが…<br> 这是比较句的强调句式，意为“与…相比，…（一方）更…”。\r\n<p> 例： みかんよりぶどうのほうが高（たか）いです。/与桔子相比，葡萄更贵。<br>5.32. …や…や…など<br> 意为：“…啦…啦…等等”\r\n<p> 例： 町には映画館や公園などがあります。/城里有电影院啦公园等。<br>   テレビやラジオのどは田中さんの部屋にあります。/电视机啦收音机等等都在田中的房间里。<br>5.33. 疑问词 + も…否定式<br> 表示全盘否定，意为“（什么）也没有”、“（什么）都不”。\r\n<p> 例： 部屋にはだれもいません。/房间里一个人也没有。<br>   いいえ，なんでもありません。/不，什么也不是。<br>5.34. …も…も<br> [も]叠加使用，含“…和…都…”之意。\r\n<p> 例： 李さんも王さんも三年生です。/小李和小王都是大三的学生。<br>   猫（ねこ）も犬（いぬ）もいません。/猫和狗都没有。<br>5.35. …（の）ために，…<br> 接体言加[の]或动词终止形后，表示目的，含“为了…”之意。\r\n<p> 例： お正月を迎えるために大掃除をしました。/为了迎接新年，做了大扫除。<br>   父のためにお酒を買いました。/为家父买了酒。<br>5.36.&amp;n<br>更多咨询请访问： www.neworldjp.com\r\n', null, null, null, '2020-10-18 21:30:52', '2020-10-18 21:30:52', '1');
INSERT INTO `articles` VALUES ('54', '1', '日语N4主要句型分享', '', '1.（动词否定形）あまり…／不怎么……；不太……\r\n　　2.（名词）をください／请给我（们）……\r\n\r\n　　3.（动词て形）てください／请你（为我或我们）做……\r\n\r\n　　4.（动词简体否定形）ないでください／请你不要……\r\n\r\n　　5.（动词て形）てくださいませんか／请您给我（们）做某事好吗？\r\n\r\n　　6.（动词ます形）ませんか?ましょう（か）／……好吗？\r\n\r\n　　7.（名词）が欲しい（です）／我想得到……；我想要……；我想有……\r\n\r\n　　8.（名词或动词简体＋こと）が好きです?嫌いです／我喜欢（爱好）……或喜欢（爱好）做…\r\n\r\n　　9.（动词ます形）たい（です）／我想（做某事）\r\n\r\n　　10.（动词ます形）ながら／（同时进行）一边……一边……\r\n\r\n　　11.（动词て形）て（から）／……之后，……补充：（動詞て形）て／表示动作行为的方式，方法，手段；材料；先后关系；并列\r\n\r\n　　12.（动词原形?名詞の?時間名詞）前（に）／在……之前\r\n\r\n　　13.（动词た形）たあとで／在……之后\r\n\r\n　　14.（名词、动词、形容词た形）たり…たりする（です）／（表示动作等交替进行或状态等交替出现）一会儿……一会儿；又……又；有时……有时；……啦……啦\r\n\r\n　　15.（名词、动词、形容词简体）でしょう／表示推量，相当于汉语的“……吧”。“だろう”（男性用语）是“でしょう”（男女都可用）的简体形式\r\n\r\n　　16.（名词）になる／变成……；当……\r\n\r\n　　17.（い形形容词词干）くなる／变得……\r\n\r\n　　18.（な形形容词词干）になる／变得……\r\n\r\n　　19.（名词）を（名詞）にする／把……变成……；把……搞成……\r\n\r\n　　20.(名词)を（い形形容词词干）くする／把……变成……\r\n\r\n　　21.（名词）を（な形形容词词干）にする／把……变成，使……变得……\r\n\r\n　　22.（体言）から（体言）まで／从……到……\r\n\r\n　　23.（动词简体?い形形容词简体）からです／（表示原因、理由）因为……\r\n\r\n　　（名词、动词、い形形容词、な形形容词简体或者敬体）から（表示原因、理由）因为……\r\n\r\n　　24.（名詞の?動詞原形?動詞た形）時（に）在……时（候）\r\n\r\n　　25.（名詞）も＋（名詞）も／…也，…也…；…和…都…\r\n\r\n　　26.（動詞て形）てある表示说话人带有某种目的和意图的行为所带来的状态。\r\n\r\n　　27.もう＋肯定或者否定\r\n\r\n　　第一：（表示情况、状态已经发生了变化，常和过去时态连用）已经……；\r\n\r\n　　第二：（表示在已有标准或状态的基础上进行追加，其后常接时间段名词或表示次数的词）再，还有，另外……；\r\n\r\n　　第三：（表示某种动作或状态即将发生，常和现在时态连用）马上就要……，快要……\r\n\r\n　　28.まだ＋否定表现／还没有（尚未）……\r\n\r\n　　29.まだ＋肯定表现／还……\r\n\r\n　　30.（動詞て形）ている\r\n\r\n　　第一：（动作行为正在进行之中）正在……\r\n\r\n　　第二：（习惯反复发生的动作行为，常与等副词连用）\r\n\r\n　　第三：（动作行为所残留的状态）……着', '<p>1.（动词否定形）あまり…／不怎么……；不太……<br>　　2.（名词）をください／请给我（们）……\r\n<p>　　3.（动词て形）てください／请你（为我或我们）做……</p>\r\n<p>　　4.（动词简体否定形）ないでください／请你不要……</p>\r\n<p>　　5.（动词て形）てくださいませんか／请您给我（们）做某事好吗？</p>\r\n<p>　　6.（动词ます形）ませんか?ましょう（か）／……好吗？</p>\r\n<p>　　7.（名词）が欲しい（です）／我想得到……；我想要……；我想有……</p>\r\n<p>　　8.（名词或动词简体＋こと）が好きです?嫌いです／我喜欢（爱好）……或喜欢（爱好）做…</p>\r\n<p>　　9.（动词ます形）たい（です）／我想（做某事）</p>\r\n<p>　　10.（动词ます形）ながら／（同时进行）一边……一边……</p>\r\n<p>　　11.（动词て形）て（から）／……之后，……补充：（動詞て形）て／表示动作行为的方式，方法，手段；材料；先后关系；并列</p>\r\n<p>　　12.（动词原形?名詞の?時間名詞）前（に）／在……之前</p>\r\n<p>　　13.（动词た形）たあとで／在……之后</p>\r\n<p>　　14.（名词、动词、形容词た形）たり…たりする（です）／（表示动作等交替进行或状态等交替出现）一会儿……一会儿；又……又；有时……有时；……啦……啦</p>\r\n<p>　　15.（名词、动词、形容词简体）でしょう／表示推量，相当于汉语的“……吧”。“だろう”（男性用语）是“でしょう”（男女都可用）的简体形式</p>\r\n<p>　　16.（名词）になる／变成……；当……</p>\r\n<p>　　17.（い形形容词词干）くなる／变得……</p>\r\n<p>　　18.（な形形容词词干）になる／变得……</p>\r\n<p>　　19.（名词）を（名詞）にする／把……变成……；把……搞成……</p>\r\n<p>　　20.(名词)を（い形形容词词干）くする／把……变成……</p>\r\n<p>　　21.（名词）を（な形形容词词干）にする／把……变成，使……变得……</p>\r\n<p>　　22.（体言）から（体言）まで／从……到……</p>\r\n<p>　　23.（动词简体?い形形容词简体）からです／（表示原因、理由）因为……</p>\r\n<p>　　（名词、动词、い形形容词、な形形容词简体或者敬体）から（表示原因、理由）因为……</p>\r\n<p>　　24.（名詞の?動詞原形?動詞た形）時（に）在……时（候）</p>\r\n<p>　　25.（名詞）も＋（名詞）も／…也，…也…；…和…都…</p>\r\n<p>　　26.（動詞て形）てある表示说话人带有某种目的和意图的行为所带来的状态。</p>\r\n<p>　　27.もう＋肯定或者否定</p>\r\n<p>　　第一：（表示情况、状态已经发生了变化，常和过去时态连用）已经……；</p>\r\n<p>　　第二：（表示在已有标准或状态的基础上进行追加，其后常接时间段名词或表示次数的词）再，还有，另外……；</p>\r\n<p>　　第三：（表示某种动作或状态即将发生，常和现在时态连用）马上就要……，快要……</p>\r\n<p>　　28.まだ＋否定表现／还没有（尚未）……</p>\r\n<p>　　29.まだ＋肯定表现／还……</p>\r\n<p>　　30.（動詞て形）ている</p>\r\n<p>　　第一：（动作行为正在进行之中）正在……</p>\r\n<p>　　第二：（习惯反复发生的动作行为，常与等副词连用）</p>\r\n<p>　　第三：（动作行为所残留的状态）……着</p>\r\n', null, null, null, '2020-10-18 21:31:28', '2020-10-18 21:31:28', '1');
INSERT INTO `articles` VALUES ('55', '1', '日语“比较”句型', '', '日语中表“比较”的句型1、甲は乙より...です这是表示“甲比乙~”的句型。“…”部分由形容词或形容动词构成。注意日语“より”的位置和汉语“比”的位置不同。例如，今天比昨天热。今日は昨日より暑いです。在这个例...\r\n日语中表“比较”的句型\r\n1、 甲は乙より...です\r\n    这是表示“甲比乙~”的句型。“…”部分由形容词或形容动词构成。注意日语“より”的位置和汉语“比”的位置不同。\r\n    例如，今天比昨天热。\r\n          今日は昨日より暑いです。\r\n    在这个例子中，甲是今天，乙是昨天。中国的“比”在乙的前面，日语的“より”在乙的后面。\r\n\r\n2、 甲は乙ほど...くないです/ではありません\r\n    这个句型表示“甲不如乙…”也就是“乙比甲…”。“…”部分为形容词时，句尾用“くないです”。形容动词时，句尾用“ではありません”。\r\n例，今日は昨日ほど暑くないです。\r\n彼の部屋は私の部屋ほどきれいではありません。\r\n\r\n3、   (乙より)甲のほうが...です\r\n    这个句型表示“与乙相比甲更…”,也就是“甲比乙…”\r\n例，日本より中国のほうが広いです。\r\n\r\n4、   甲はいちばん...です\r\n    比较甲乙丙等三者以上事物时，用来表示“甲最…”\r\n例，この花はいちばん美しいです。\r\n\r\n5、 甲と乙はどちらが...ですか\r\n    当询问甲乙相比的情况下用此句型。\r\n例，音楽と映画とどちらが好きですか。\r\n\r\n6、 どれ/どこ/いつ/どの...がいちばん...ですか\r\n    当询问甲乙丙等三个以上事物哪个最~时，用此句型。\r\n例，日本でどの山がいちばん高いですか。', '<p>日语中表“比较”的句型1、甲は乙より…です这是表示“甲比乙~”的句型。“…”部分由形容词或形容动词构成。注意日语“より”的位置和汉语“比”的位置不同。例如，今天比昨天热。今日は昨日より暑いです。在这个例…<br>日语中表“比较”的句型<br>1、 甲は乙より…です<br>    这是表示“甲比乙~”的句型。“…”部分由形容词或形容动词构成。注意日语“より”的位置和汉语“比”的位置不同。<br>    例如，今天比昨天热。<br>          今日は昨日より暑いです。<br>    在这个例子中，甲是今天，乙是昨天。中国的“比”在乙的前面，日语的“より”在乙的后面。\r\n<p>2、 甲は乙ほど…くないです/ではありません<br>    这个句型表示“甲不如乙…”也就是“乙比甲…”。“…”部分为形容词时，句尾用“くないです”。形容动词时，句尾用“ではありません”。<br>例，今日は昨日ほど暑くないです。<br>彼の部屋は私の部屋ほどきれいではありません。\r\n<p>3、   (乙より)甲のほうが…です<br>    这个句型表示“与乙相比甲更…”,也就是“甲比乙…”<br>例，日本より中国のほうが広いです。\r\n<p>4、   甲はいちばん…です<br>    比较甲乙丙等三者以上事物时，用来表示“甲最…”<br>例，この花はいちばん美しいです。\r\n<p>5、 甲と乙はどちらが…ですか<br>    当询问甲乙相比的情况下用此句型。<br>例，音楽と映画とどちらが好きですか。\r\n<p>6、 どれ/どこ/いつ/どの…がいちばん…ですか<br>    当询问甲乙丙等三个以上事物哪个最~时，用此句型。<br>例，日本でどの山がいちばん高いですか。\r\n', null, null, null, '2020-10-18 21:31:58', '2020-10-18 21:31:58', '1');
INSERT INTO `articles` VALUES ('56', '1', '日语形容词变化规律总结', '', '日语的 形容词词形与动词一样，分词干和词尾两部分。简单来说，形容词的活用就是指词尾い的形态变化，形容词的词尾变化只有未然形、连用形、终止形、连体形、推量形，而没有命令形。\r\n\r\n\r\n\r\n形容词各个活用形的用法\r\n\r\n1、未然形（或推量形）\r\n未然形“かろ”后续“う”，构成简体推量形。表示对客观事物的推测。\r\n\r\n【变化规律】：词尾い变成かろ 苦しい＝＝苦しかろ\r\n\r\n【用例】物価が高い東京のことだから、生活が苦しかろう。（东京物价很高，生活很辛苦吧。）\r\n【注】 但实际上未然形不大用，“…かろ”的形式虽然时规范的口语形容词的活用形，但通常情况下都是用终止形加“だろう”来代替，如：長かろ(う)一般说成長いだろう\r\n\r\n\r\n2、连用形\r\n日语形容词的连用形有“く”连用形和“かっ”连用形两种，这里分别作以解释：\r\n\r\n\r\n\r\nI “く”连用形\r\n【变化规律】：词尾い变成く 苦しい＝＝苦しく\r\n（1）置于所修饰的用言前作状语\r\n\r\n【用例】いつものように、つまらなく家に帰った。（像往常一样，无精打采的回家了。）\r\n\r\n（2）与“なる”、“する”结合表示变化。“…が…なる”“…を…する”。前者表示客观的变化，后者表示人为地使其改变。\r\n【用例】春が来ると、暖かくなる。（春天来了，天气变暖。）\r\n環境を美しくしてください。（请把环境建设得更美好。）\r\n（3）中顿 两个用言并列，前者为形容词时可以用其连用形表示中顿。（并列，原因等关系）\r\n【用例1】あの女の子は美しく頭がいい。（那个女孩子既漂亮又聪明。）（并列）\r\n【用例2】頭が痛く、学校を休んだ。（头疼，所以请假了。）（原因）\r\n\r\n（4）后续补助形容词“ない”，表示否定。\r\n\r\n【用例】この料理は美味しくない。（这道菜不好吃。）\r\n\r\n（5）后续接续助词て、ても、ては ，表示并列、原因、转折、条件等语法意义。\r\n\r\n【用例1】この教科書は大きくて薄い。（这本书既大又薄。）（表并列）\r\n【用例2】天気が悪くて、出掛けない。（天气不好，所以不出去。）（原因）\r\n【用例3】寒くても、泳ぎに行きます。（即使天气冷，也要去游泳。）（转折）\r\n\r\n【用例4】そんなに高くては、買えないだろう。（如果那么贵的话，就买不起了吧。）（假设条件）\r\n\r\n\r\n\r\nII、“かっ”连用形\r\n【变化规律】：词尾い变成かっ　　 苦しい＝＝苦しかっ\r\n\r\n（1）后续过去完了助动词“た”，表示过去时态。简体。\r\n【用例】去年の冬は寒かった。（去年冬天很冷）\r\n\r\n（2）后续并列助词“たり”\r\n【用例】値段が高かったり、安かったりして、季節によって違います。（价钱因季节而不同，有 时贵、有时便宜。）\r\n\r\n\r\n\r\n4、终止形\r\n【变化规律】：词尾无变化\r\n（1）作谓语结句，简体。\r\n【用例】お湯が熱い。（开水很热。）\r\n\r\n（2）后续接续助词から、けれども、し等。\r\n【用例1】寮にはうるさいから、外へ出て、本を読みに行く。（因为宿舍里太吵，到外面去看书。）\r\n【用例2】この西瓜が安いけれども、美味しくない。（这个西瓜虽然便宜，但不好吃。）\r\n【用例3】この店は料理がおいしいし、値段も安いから、いつもひとが多いです。（这家店菜味道也好，价钱也便宜，所以总是人很多。）\r\n\r\n（3）后续语气助词か、よ、ね\r\n【用例1】痛いか。（疼吗？疑问）\r\n【用例2】映画より小説のほうが面白いよ。（小说比电影好看。叮嘱、强调）\r\n\r\n\r\n\r\n5、连体形\r\n【变化规律】：词尾无变化 修饰名词做定语\r\n\r\n【用例1】つらい仕事をしている。（正从事很艰苦的工作。）\r\n【用例2】赤い花が美しい。（红色的花很美）\r\n\r\n\r\n\r\n6、假定形\r\n假定形只有一个用法，就是后续接续助词ば表示假定条件。 例如： よければ、やすければ等。\r\n【变化规律】：词尾い变成けれ　　 苦しい＝＝苦しけれ\r\n【用例1】安ければ、買う。 （如果便宜就买。）\r\n【用例2】天気がよければ、スケッチに出掛ける。（如果天气好的话，就出去写生。）\r\n\r\n日语形容词变化规律总结 http://www.pkusky.com/post/xuexi/2161.html', '<p>日语的 形容词词形与动词一样，分词干和词尾两部分。简单来说，形容词的活用就是指词尾い的形态变化，形容词的词尾变化只有未然形、连用形、终止形、连体形、推量形，而没有命令形。</p>\r\n<p>形容词各个活用形的用法</p>\r\n<p>1、未然形（或推量形）<br>未然形“かろ”后续“う”，构成简体推量形。表示对客观事物的推测。\r\n<p>【变化规律】：词尾い变成かろ 苦しい＝＝苦しかろ</p>\r\n<p>【用例】物価が高い東京のことだから、生活が苦しかろう。（东京物价很高，生活很辛苦吧。）<br>【注】 但实际上未然形不大用，“…かろ”的形式虽然时规范的口语形容词的活用形，但通常情况下都是用终止形加“だろう”来代替，如：長かろ(う)一般说成長いだろう\r\n<p>2、连用形<br>日语形容词的连用形有“く”连用形和“かっ”连用形两种，这里分别作以解释：\r\n<p>I “く”连用形<br>【变化规律】：词尾い变成く 苦しい＝＝苦しく<br>（1）置于所修饰的用言前作状语\r\n<p>【用例】いつものように、つまらなく家に帰った。（像往常一样，无精打采的回家了。）</p>\r\n<p>（2）与“なる”、“する”结合表示变化。“…が…なる”“…を…する”。前者表示客观的变化，后者表示人为地使其改变。<br>【用例】春が来ると、暖かくなる。（春天来了，天气变暖。）<br>環境を美しくしてください。（请把环境建设得更美好。）<br>（3）中顿 两个用言并列，前者为形容词时可以用其连用形表示中顿。（并列，原因等关系）<br>【用例1】あの女の子は美しく頭がいい。（那个女孩子既漂亮又聪明。）（并列）<br>【用例2】頭が痛く、学校を休んだ。（头疼，所以请假了。）（原因）\r\n<p>（4）后续补助形容词“ない”，表示否定。</p>\r\n<p>【用例】この料理は美味しくない。（这道菜不好吃。）</p>\r\n<p>（5）后续接续助词て、ても、ては ，表示并列、原因、转折、条件等语法意义。</p>\r\n<p>【用例1】この教科書は大きくて薄い。（这本书既大又薄。）（表并列）<br>【用例2】天気が悪くて、出掛けない。（天气不好，所以不出去。）（原因）<br>【用例3】寒くても、泳ぎに行きます。（即使天气冷，也要去游泳。）（转折）\r\n<p>【用例4】そんなに高くては、買えないだろう。（如果那么贵的话，就买不起了吧。）（假设条件）</p>\r\n<p>II、“かっ”连用形<br>【变化规律】：词尾い变成かっ　　 苦しい＝＝苦しかっ\r\n<p>（1）后续过去完了助动词“た”，表示过去时态。简体。<br>【用例】去年の冬は寒かった。（去年冬天很冷）\r\n<p>（2）后续并列助词“たり”<br>【用例】値段が高かったり、安かったりして、季節によって違います。（价钱因季节而不同，有 时贵、有时便宜。）\r\n<p>4、终止形<br>【变化规律】：词尾无变化<br>（1）作谓语结句，简体。<br>【用例】お湯が熱い。（开水很热。）\r\n<p>（2）后续接续助词から、けれども、し等。<br>【用例1】寮にはうるさいから、外へ出て、本を読みに行く。（因为宿舍里太吵，到外面去看书。）<br>【用例2】この西瓜が安いけれども、美味しくない。（这个西瓜虽然便宜，但不好吃。）<br>【用例3】この店は料理がおいしいし、値段も安いから、いつもひとが多いです。（这家店菜味道也好，价钱也便宜，所以总是人很多。）\r\n<p>（3）后续语气助词か、よ、ね<br>【用例1】痛いか。（疼吗？疑问）<br>【用例2】映画より小説のほうが面白いよ。（小说比电影好看。叮嘱、强调）\r\n<p>5、连体形<br>【变化规律】：词尾无变化 修饰名词做定语\r\n<p>【用例1】つらい仕事をしている。（正从事很艰苦的工作。）<br>【用例2】赤い花が美しい。（红色的花很美）\r\n<p>6、假定形<br>假定形只有一个用法，就是后续接续助词ば表示假定条件。 例如： よければ、やすければ等。<br>【变化规律】：词尾い变成けれ　　 苦しい＝＝苦しけれ<br>【用例1】安ければ、買う。 （如果便宜就买。）<br>【用例2】天気がよければ、スケッチに出掛ける。（如果天气好的话，就出去写生。）\r\n<p>日语形容词变化规律总结 <a href=\"http://www.pkusky.com/post/xuexi/2161.html\">http://www.pkusky.com/post/xuexi/2161.html</a></p>\r\n', null, null, null, '2020-10-18 21:32:33', '2020-10-18 21:32:33', '1');
INSERT INTO `articles` VALUES ('57', '1', '日语最常用100常用语', '', '1、こんにちは。  你好。\r\n\r\n2、こんばんは。  晚上好。\r\n\r\n3、おはようございます。  早上好。\r\n\r\n4、お休(やす)みなさい。  晚安。\r\n\r\n5、お元気(げんき)ですか。  您还好吧。\r\n\r\n6、いくらですか。  多少钱？\r\n\r\n7、すみません。 不好意思，麻烦你…。用于向别人开口时。\r\n\r\n8、ごめんなさい。 对不起。\r\n\r\n9、どういうことですか。  什么意思呢？\r\n\r\n10、山田さんは中国語(ちゅうごくご)が上手(じょうず)ですね。\r\n\r\n山田的中国话说的真好。\r\n\r\n11、まだまだです。  没什么。没什么。（自谦）\r\n\r\n12、どうしたの。 \r\n    どうしたんですか。  发生了什么事啊。\r\n\r\n13、なんでもない。 没什么事。\r\n\r\n14、ちょっと待ってください。请稍等一下。可以简单地表达为：ちょっと\r\n\r\n15、約束(やくそく)します。  就这么说定了。\r\n\r\n16、これでいいですか。  这样可以吗？\r\n\r\n17、けっこうです。 \r\n    もういいです。不用了。\r\n\r\n18、どうして。\r\n     なぜ。     为什么啊？\r\n\r\n19、いただきます  那我开动了。（吃饭动筷子前）\r\n\r\n20、ごちそうさまでした。  我吃饱了。（吃完后）\r\n\r\n21、ありがとうございます。 谢谢。\r\n\r\n22、どういたしまして。  别客气。\r\n\r\n23、本当(ほんとう)ですか。 真的？\r\n\r\n24、うれしい。  我好高兴。（女性用语）\r\n\r\n25、よし。いくぞ。  好！出发（行动）。 （男性用语）\r\n\r\n26、いってきます。 我走了。（离开某地对别人说的话）\r\n\r\n27、いってらしゃい。 您好走。（对要离开的人说的话）\r\n28、いらしゃいませ。 欢迎光临。\r\n\r\n29、また、どうぞお越(こ) しください。欢迎下次光临。\r\n\r\n30、じゃ、またね。\r\n    では、また。再见（比较通用的用法）\r\n\r\n31、信(しん) じられない。真令人难以相信。\r\n\r\n32、どうも。 \r\n    该词意思模糊。有多谢、不好意思、对不起等多种意思，可以说是个万能词。\r\n\r\n33、あ、そうだ。啊，对了。表示突然想起另一个话题或事情。（男性用语居多）\r\n\r\n34、えへ？ 表示轻微惊讶的感叹语。\r\n\r\n35、うん、いいわよ。 恩，好的。（女性用语）\r\n\r\n36、ううん、そうじゃない。不，不是那样的。（女性用语）\r\n\r\n37、がんばってください。 请加油。（日本人临别时多用此语）\r\n\r\n38、がんばります。 我会加油的。\r\n\r\n39ご苦労(くろう) さま。 辛苦了。（用于上级对下级）\r\n\r\n40、お疲(つか)れさま。 辛苦了。（用于下级对上级和平级间）\r\n\r\n41、どうぞ遠慮(えんりょ) なく。 请别客气。\r\n42、おひさしぶりです。\r\n     しばらくですね。 好久不见了。\r\n\r\n43、きれい。\r\n    好漂亮啊。（可用于建筑，装饰品，首饰，画，女性的相貌等等，范围很广）\r\n\r\n44、ただいま。 我回来了。（日本人回家到家门口说的话）\r\n\r\n45、おかえり。 您回来啦。（家里人对回家的人的应答）\r\n\r\n46、いよいよぼくの本番(ほんばん)だ。 总算到我正式出场了。（男性用语）\r\n\r\n47、関係(かんけい) ないでしょう。 这和你没关系吧？（对八卦的人常用的一句话）\r\n\r\n48、電話番号(でんわばんごう) を教えてください。 请告诉我您的电话号码。\r\n\r\n49、日本語(にほんご) はむずかしいことばがはなせませんが、やさしいことばがなんとかはなせます。\r\n日语难的说不上来，简单的还能对付几句。\r\n\r\n50、たいへん！ 不得了啦。\r\n\r\n51、おじゃまします。 打搅了。到别人的处所时进门时说的话。\r\n\r\n52、おじゃましました。 打搅了。离开别人的处所时讲的话。\r\n\r\n53、はじめまして。 初次见面请多关照。\r\n\r\n54どうぞよろしくおねがいします。 请多关照。\r\n\r\n55、いままでおせわになにました。\r\n    いままでありがとうございます。\r\n    多谢您长久以来的关照。（要离开某地或跳槽时对身边的人说的。）\r\n\r\n56、お待たせいたしました。 让您久等了。\r\n\r\n57、別(べつ)に。 没什么。当别人问你发生了什么事时你的回答。\r\n\r\n58、冗談(じょうだん) を言わないでください。 请别开玩笑。\r\n\r\n59、おねがいします。 拜托了。（如果是跪着时说这句话，那意思就是“求求您了”）\r\n\r\n60、そのとおりです。 说的对。\r\n\r\n61、なるほど。原来如此啊。\r\n\r\n62、どうしようかな\r\n    どうすればいい我该怎么办啊？\r\n\r\n63、やめなさいよ。 住手。\r\n\r\n64、先生(せんせい) でさえわからないだから、まして学生(がくせい) のわたしならなおさらである。\r\n连老师都不会，况且是学生的我那就更不用提了\r\n\r\nhttp://blog.sina.com.cn/s/blog_6b465dab0100ouhy.html', '<p>1、こんにちは。  你好。</p>\r\n<p>2、こんばんは。  晚上好。</p>\r\n<p>3、おはようございます。  早上好。</p>\r\n<p>4、お休(やす)みなさい。  晚安。</p>\r\n<p>5、お元気(げんき)ですか。  您还好吧。</p>\r\n<p>6、いくらですか。  多少钱？</p>\r\n<p>7、すみません。 不好意思，麻烦你…。用于向别人开口时。</p>\r\n<p>8、ごめんなさい。 对不起。</p>\r\n<p>9、どういうことですか。  什么意思呢？</p>\r\n<p>10、山田さんは中国語(ちゅうごくご)が上手(じょうず)ですね。</p>\r\n<p>山田的中国话说的真好。</p>\r\n<p>11、まだまだです。  没什么。没什么。（自谦）</p>\r\n<p>12、どうしたの。<br>    どうしたんですか。  发生了什么事啊。\r\n<p>13、なんでもない。 没什么事。</p>\r\n<p>14、ちょっと待ってください。请稍等一下。可以简单地表达为：ちょっと</p>\r\n<p>15、約束(やくそく)します。  就这么说定了。</p>\r\n<p>16、これでいいですか。  这样可以吗？</p>\r\n<p>17、けっこうです。<br>    もういいです。不用了。\r\n<p>18、どうして。<br>     なぜ。     为什么啊？\r\n<p>19、いただきます  那我开动了。（吃饭动筷子前）</p>\r\n<p>20、ごちそうさまでした。  我吃饱了。（吃完后）</p>\r\n<p>21、ありがとうございます。 谢谢。</p>\r\n<p>22、どういたしまして。  别客气。</p>\r\n<p>23、本当(ほんとう)ですか。 真的？</p>\r\n<p>24、うれしい。  我好高兴。（女性用语）</p>\r\n<p>25、よし。いくぞ。  好！出发（行动）。 （男性用语）</p>\r\n<p>26、いってきます。 我走了。（离开某地对别人说的话）</p>\r\n<p>27、いってらしゃい。 您好走。（对要离开的人说的话）<br>28、いらしゃいませ。 欢迎光临。\r\n<p>29、また、どうぞお越(こ) しください。欢迎下次光临。</p>\r\n<p>30、じゃ、またね。<br>    では、また。再见（比较通用的用法）\r\n<p>31、信(しん) じられない。真令人难以相信。</p>\r\n<p>32、どうも。<br>    该词意思模糊。有多谢、不好意思、对不起等多种意思，可以说是个万能词。\r\n<p>33、あ、そうだ。啊，对了。表示突然想起另一个话题或事情。（男性用语居多）</p>\r\n<p>34、えへ？ 表示轻微惊讶的感叹语。</p>\r\n<p>35、うん、いいわよ。 恩，好的。（女性用语）</p>\r\n<p>36、ううん、そうじゃない。不，不是那样的。（女性用语）</p>\r\n<p>37、がんばってください。 请加油。（日本人临别时多用此语）</p>\r\n<p>38、がんばります。 我会加油的。</p>\r\n<p>39ご苦労(くろう) さま。 辛苦了。（用于上级对下级）</p>\r\n<p>40、お疲(つか)れさま。 辛苦了。（用于下级对上级和平级间）</p>\r\n<p>41、どうぞ遠慮(えんりょ) なく。 请别客气。<br>42、おひさしぶりです。<br>     しばらくですね。 好久不见了。\r\n<p>43、きれい。<br>    好漂亮啊。（可用于建筑，装饰品，首饰，画，女性的相貌等等，范围很广）\r\n<p>44、ただいま。 我回来了。（日本人回家到家门口说的话）</p>\r\n<p>45、おかえり。 您回来啦。（家里人对回家的人的应答）</p>\r\n<p>46、いよいよぼくの本番(ほんばん)だ。 总算到我正式出场了。（男性用语）</p>\r\n<p>47、関係(かんけい) ないでしょう。 这和你没关系吧？（对八卦的人常用的一句话）</p>\r\n<p>48、電話番号(でんわばんごう) を教えてください。 请告诉我您的电话号码。</p>\r\n<p>49、日本語(にほんご) はむずかしいことばがはなせませんが、やさしいことばがなんとかはなせます。<br>日语难的说不上来，简单的还能对付几句。\r\n<p>50、たいへん！ 不得了啦。</p>\r\n<p>51、おじゃまします。 打搅了。到别人的处所时进门时说的话。</p>\r\n<p>52、おじゃましました。 打搅了。离开别人的处所时讲的话。</p>\r\n<p>53、はじめまして。 初次见面请多关照。</p>\r\n<p>54どうぞよろしくおねがいします。 请多关照。</p>\r\n<p>55、いままでおせわになにました。<br>    いままでありがとうございます。<br>    多谢您长久以来的关照。（要离开某地或跳槽时对身边的人说的。）\r\n<p>56、お待たせいたしました。 让您久等了。</p>\r\n<p>57、別(べつ)に。 没什么。当别人问你发生了什么事时你的回答。</p>\r\n<p>58、冗談(じょうだん) を言わないでください。 请别开玩笑。</p>\r\n<p>59、おねがいします。 拜托了。（如果是跪着时说这句话，那意思就是“求求您了”）</p>\r\n<p>60、そのとおりです。 说的对。</p>\r\n<p>61、なるほど。原来如此啊。</p>\r\n<p>62、どうしようかな<br>    どうすればいい我该怎么办啊？\r\n<p>63、やめなさいよ。 住手。</p>\r\n<p>64、先生(せんせい) でさえわからないだから、まして学生(がくせい) のわたしならなおさらである。<br>连老师都不会，况且是学生的我那就更不用提了\r\n<p><a href=\"http://blog.sina.com.cn/s/blog_6b465dab0100ouhy.html\">http://blog.sina.com.cn/s/blog_6b465dab0100ouhy.html</a></p>\r\n', null, null, null, '2020-10-18 21:32:57', '2020-10-18 21:32:57', '1');
INSERT INTO `articles` VALUES ('58', '1', '日语常见自、他动词对照表', '', '自动词就是后面不能接宾语的动词，即表示动作、作用等由主语自身发生的动词；他动词就是能接宾语的动词，即有明确的动作对象的动词。日语中比较常见的自动词、他动词有：\r\n　　一、规则的自动词、他动词\r\n　　１、（が） あ段假名＋る-------------（を） え段假名＋る\r\n　　あがる （“上、登、提高”等）------あげる（“举、抬、提高”等）\r\n　　あつまる（“集合、集中”）----------あつめる（“召集、搜集”）\r\n　　かかる（“悬挂、架设、花费”等）-かける（“戴、挂、花费、架设”等）\r\n　　きまる（“决定、规定、合适”等）-きめる（“决定、合适、合乎要求”等）\r\n　　しまる（“勒紧、紧张、紧闭”等）--しめる（“勒紧、紧张起来、关闭”等）\r\n　　とまる（“停止、栖、落、留”等）--とめる（“止住、停住、使固定”等）\r\n　　はじまる（“开始”）-------------------はじめる（“开始、创办”）\r\n　　かわる（“变化、变动”等）---------かえる（“改变，更改”等）\r\n　　例：「ドアーがしまる。」<------------->「ドアーをしめる。」\r\n　　　　「人があつまる。」 <------------->「切手を集める。」\r\n　　２、（が） う段假名-------------------（を） え段假名＋る\r\n　　あく（“空、闲、开”等）------------- あける（“空出、腾出、打开”等）\r\n　　たつ（“站立、处于、维持”等）----たてる（“竖立、使出现、维持”等）\r\n　　つく（“沾上、配有、感觉”等）-----つける（“涂抹、增加、着手做”等）\r\n　　とどく（“达到、实现”等）-----------とどける（“送到、报告”等）\r\n　　例：「電氣がつく。」<----------------->「電氣をつける。」\r\n　　３、（が） る--------------------------------（を） す\r\n　　かえる（“复原、回答、回复”等）------かえす（“归还、还原、返回”等）\r\n　　まわる（“旋转、围绕、巡回”等）------まわす（“转、围上、转移”等）\r\n　　なおる（“修好、复原、改正”等）------なおす（“修理、改正、改变”等）\r\n　　例：「病氣がなおる。」<----------------->「医者が病氣を治す。」\r\n　　４、（が） 一段假名＋る---------------（を） お段假名＋す\r\n　　おきる（“起立、起床、发生”等）----おこす（“使起来、叫醒、产生”等）\r\n　　おちる（“落下、掉、下降”等）-------おとす（“使落下、去掉、降低”等）\r\n　　例：「子供が起きる。」<-------------->「子供を起こす。」\r\n　　５、（が） える---------------------------（を） やす\r\n　　ひえる（“冷、变凉、冷淡”等）------ひやす（“冰镇、使冷静、镇定”）\r\n　　ふえる（“增加、增多”）--------------ふやす（“增加、增多”）\r\n　　例：「人口がふえる。」<------------->「財産をふやす。」\r\n　　６、（が） え段假名＋る-----------------（を） あ段假名＋る\r\n　　でる（“出来、出发、出现”等）---------だす（“取出、派出、产生”等）\r\n　　とける（“松开、消除、解决”等）------とかす（“梳理、溶解”）\r\n　　さめる（“变凉、减退、降低”等）------さます（“弄凉、降低、减少”等）\r\n　　例：「ねこが窗から出る。」<------------>「猫を外に出す.」\r\n　　７、（が） れる------------------------------（を） す\r\n　　こわれる（“坏、破损、出毛病”等）----こわす（“弄坏、破坏、损坏”等）\r\n　　たおれる（“倒下、垮台、病倒”等）----たおす（“弄倒、推倒”等）\r\n　　よごれる（“脏、污浊”等）---------------よごす（“弄脏、玷污”）\r\n　　例：「自動車がこわれる。」<----------->「わざと自動車をこわす。」\r\n　　８、（が） れる-----------------------------（を） る\r\n　　おれる（“折断、弯曲、转弯”等）-------おる（“折断、弯曲、叠”等）\r\n　　きれる（“中断、失效、偏离”等）-------きる（“切断、中断、转弯”等）\r\n　　やぶれる（“破裂、破灭、失败”）------やぶる（“弄破、搅乱、击败”等）\r\n　　例：「皿がわれる。」<------------------->「皿をわる。」\r\n二、不规则的自动词、他动词\r\n　　 きえる（“消失”）----------けす（“灭掉、关闭、消除”等）\r\n　　 ひらく（“开着、展开、开放”等）------ひらく（“打开、召开、开设”等）', '<p>自动词就是后面不能接宾语的动词，即表示动作、作用等由主语自身发生的动词；他动词就是能接宾语的动词，即有明确的动作对象的动词。日语中比较常见的自动词、他动词有：<br>　　一、规则的自动词、他动词<br>　　１、（が） あ段假名＋る——————-（を） え段假名＋る<br>　　あがる （“上、登、提高”等）———あげる（“举、抬、提高”等）<br>　　あつまる（“集合、集中”）—————あつめる（“召集、搜集”）<br>　　かかる（“悬挂、架设、花费”等）-かける（“戴、挂、花费、架设”等）<br>　　きまる（“决定、规定、合适”等）-きめる（“决定、合适、合乎要求”等）<br>　　しまる（“勒紧、紧张、紧闭”等）—しめる（“勒紧、紧张起来、关闭”等）<br>　　とまる（“停止、栖、落、留”等）—とめる（“止住、停住、使固定”等）<br>　　はじまる（“开始”）—————————-はじめる（“开始、创办”）<br>　　かわる（“变化、变动”等）————-かえる（“改变，更改”等）<br>　　例：「ドアーがしまる。」&lt;——————-&gt;「ドアーをしめる。」<br>　　　　「人があつまる。」 &lt;——————-&gt;「切手を集める。」<br>　　２、（が） う段假名—————————-（を） え段假名＋る<br>　　あく（“空、闲、开”等）——————- あける（“空出、腾出、打开”等）<br>　　たつ（“站立、处于、维持”等）——たてる（“竖立、使出现、维持”等）<br>　　つく（“沾上、配有、感觉”等）——-つける（“涂抹、增加、着手做”等）<br>　　とどく（“达到、实现”等）—————-とどける（“送到、报告”等）<br>　　例：「電氣がつく。」&lt;————————-&gt;「電氣をつける。」<br>　　３、（が） る————————————————（を） す<br>　　かえる（“复原、回答、回复”等）———かえす（“归还、还原、返回”等）<br>　　まわる（“旋转、围绕、巡回”等）———まわす（“转、围上、转移”等）<br>　　なおる（“修好、复原、改正”等）———なおす（“修理、改正、改变”等）<br>　　例：「病氣がなおる。」&lt;————————-&gt;「医者が病氣を治す。」<br>　　４、（が） 一段假名＋る———————-（を） お段假名＋す<br>　　おきる（“起立、起床、发生”等）——おこす（“使起来、叫醒、产生”等）<br>　　おちる（“落下、掉、下降”等）———-おとす（“使落下、去掉、降低”等）<br>　　例：「子供が起きる。」&lt;———————&gt;「子供を起こす。」<br>　　５、（が） える—————————————-（を） やす<br>　　ひえる（“冷、变凉、冷淡”等）———ひやす（“冰镇、使冷静、镇定”）<br>　　ふえる（“增加、增多”）———————ふやす（“增加、增多”）<br>　　例：「人口がふえる。」&lt;——————-&gt;「財産をふやす。」<br>　　６、（が） え段假名＋る————————-（を） あ段假名＋る<br>　　でる（“出来、出发、出现”等）————-だす（“取出、派出、产生”等）<br>　　とける（“松开、消除、解决”等）———とかす（“梳理、溶解”）<br>　　さめる（“变凉、减退、降低”等）———さます（“弄凉、降低、减少”等）<br>　　例：「ねこが窗から出る。」&lt;——————&gt;「猫を外に出す.」<br>　　７、（が） れる———————————————（を） す<br>　　こわれる（“坏、破损、出毛病”等）——こわす（“弄坏、破坏、损坏”等）<br>　　たおれる（“倒下、垮台、病倒”等）——たおす（“弄倒、推倒”等）<br>　　よごれる（“脏、污浊”等）———————-よごす（“弄脏、玷污”）<br>　　例：「自動車がこわれる。」&lt;—————-&gt;「わざと自動車をこわす。」<br>　　８、（が） れる——————————————-（を） る<br>　　おれる（“折断、弯曲、转弯”等）———-おる（“折断、弯曲、叠”等）<br>　　きれる（“中断、失效、偏离”等）———-きる（“切断、中断、转弯”等）<br>　　やぶれる（“破裂、破灭、失败”）———やぶる（“弄破、搅乱、击败”等）<br>　　例：「皿がわれる。」&lt;—————————-&gt;「皿をわる。」<br>二、不规则的自动词、他动词<br>　　 きえる（“消失”）—————けす（“灭掉、关闭、消除”等）<br>　　 ひらく（“开着、展开、开放”等）———ひらく（“打开、召开、开设”等）\r\n', null, null, null, '2020-10-18 21:34:52', '2020-10-18 21:34:52', '1');
INSERT INTO `articles` VALUES ('59', '1', 'Docker 常用命令', '', '###查看 Docker 版本\r\n`docker version`\r\n###从 Docker 文件构建 Docker 映像\r\n`docker build -t image-name docker-file-location`\r\n###运行 Docker 映像\r\n`docker run -d image-name`\r\n###查看可用的 Docker 映像\r\n`docker images`\r\n###查看最近的运行容器\r\n`docker ps -l`\r\n###查看所有正在运行的容器\r\n`docker ps -a`\r\n###停止运行容器\r\n`docker stop container_id`\r\n###删除一个镜像\r\n`docker rmi image-name`\r\n###删除所有镜像\r\n`docker rmi $(docker images -q)`\r\n###强制删除所有镜像\r\n`docker rmi -r $(docker images -q)`\r\n###删除所有虚悬镜像\r\n`docker rmi $(docker images -q -f dangling=true)`\r\n###删除所有容器\r\n`docker rm $(docker ps -a -q)`\r\n###进入 Docker 容器\r\n`docker exec -it container-id /bin/bash`\r\n###查看所有数据卷\r\n`docker volume ls`\r\n###删除指定数据卷\r\n`docker volume rm [volume_name]`\r\n###删除所有未关联的数据卷\r\n`docker volume rm $(docker volume ls -qf dangling=true)`\r\n###从主机复制文件到容器\r\n`sudo docker cp host_path containerID:container_path`\r\n###从容器复制文件到主机\r\n`sudo docker cp containerID:container_path host_path`', '<h3 id=\"h3--docker-\"><a name=\"查看 Docker 版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看 Docker 版本</h3><p><code>docker version</code></p>\r\n<h3 id=\"h3--docker-docker-\"><a name=\"从 Docker 文件构建 Docker 映像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从 Docker 文件构建 Docker 映像</h3><p><code>docker build -t image-name docker-file-location</code></p>\r\n<h3 id=\"h3--docker-\"><a name=\"运行 Docker 映像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行 Docker 映像</h3><p><code>docker run -d image-name</code></p>\r\n<h3 id=\"h3--docker-\"><a name=\"查看可用的 Docker 映像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看可用的 Docker 映像</h3><p><code>docker images</code></p>\r\n<h3 id=\"h3-u67E5u770Bu6700u8FD1u7684u8FD0u884Cu5BB9u5668\"><a name=\"查看最近的运行容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看最近的运行容器</h3><p><code>docker ps -l</code></p>\r\n<h3 id=\"h3-u67E5u770Bu6240u6709u6B63u5728u8FD0u884Cu7684u5BB9u5668\"><a name=\"查看所有正在运行的容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看所有正在运行的容器</h3><p><code>docker ps -a</code></p>\r\n<h3 id=\"h3-u505Cu6B62u8FD0u884Cu5BB9u5668\"><a name=\"停止运行容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止运行容器</h3><p><code>docker stop container_id</code></p>\r\n<h3 id=\"h3-u5220u9664u4E00u4E2Au955Cu50CF\"><a name=\"删除一个镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除一个镜像</h3><p><code>docker rmi image-name</code></p>\r\n<h3 id=\"h3-u5220u9664u6240u6709u955Cu50CF\"><a name=\"删除所有镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除所有镜像</h3><p><code>docker rmi $(docker images -q)</code></p>\r\n<h3 id=\"h3-u5F3Au5236u5220u9664u6240u6709u955Cu50CF\"><a name=\"强制删除所有镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>强制删除所有镜像</h3><p><code>docker rmi -r $(docker images -q)</code></p>\r\n<h3 id=\"h3-u5220u9664u6240u6709u865Au60ACu955Cu50CF\"><a name=\"删除所有虚悬镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除所有虚悬镜像</h3><p><code>docker rmi $(docker images -q -f dangling=true)</code></p>\r\n<h3 id=\"h3-u5220u9664u6240u6709u5BB9u5668\"><a name=\"删除所有容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除所有容器</h3><p><code>docker rm $(docker ps -a -q)</code></p>\r\n<h3 id=\"h3--docker-\"><a name=\"进入 Docker 容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>进入 Docker 容器</h3><p><code>docker exec -it container-id /bin/bash</code></p>\r\n<h3 id=\"h3-u67E5u770Bu6240u6709u6570u636Eu5377\"><a name=\"查看所有数据卷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看所有数据卷</h3><p><code>docker volume ls</code></p>\r\n<h3 id=\"h3-u5220u9664u6307u5B9Au6570u636Eu5377\"><a name=\"删除指定数据卷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除指定数据卷</h3><p><code>docker volume rm [volume_name]</code></p>\r\n<h3 id=\"h3-u5220u9664u6240u6709u672Au5173u8054u7684u6570u636Eu5377\"><a name=\"删除所有未关联的数据卷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除所有未关联的数据卷</h3><p><code>docker volume rm $(docker volume ls -qf dangling=true)</code></p>\r\n<h3 id=\"h3-u4ECEu4E3Bu673Au590Du5236u6587u4EF6u5230u5BB9u5668\"><a name=\"从主机复制文件到容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从主机复制文件到容器</h3><p><code>sudo docker cp host_path containerID:container_path</code></p>\r\n<h3 id=\"h3-u4ECEu5BB9u5668u590Du5236u6587u4EF6u5230u4E3Bu673A\"><a name=\"从容器复制文件到主机\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从容器复制文件到主机</h3><p><code>sudo docker cp containerID:container_path host_path</code></p>\r\n', null, null, null, '2020-10-19 21:11:00', '2020-10-19 21:11:00', '1');
INSERT INTO `articles` VALUES ('60', '1', '使用 Dockerfile 定制镜像', '', '### Dockerfile 定制镜像\r\n从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。\r\n\r\nDockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\r\n\r\n还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。\r\n\r\n在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：\r\n\r\n    $ mkdir mynginx\r\n    $ cd mynginx\r\n    $ touch Dockerfile\r\n其内容为：\r\n\r\n    FROM nginx\r\n    RUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\r\n这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。\r\n\r\n###FROM 指定基础镜像\r\n所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。\r\n\r\n在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。\r\n\r\n如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。\r\n\r\n除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。\r\n\r\n`FROM scratch`\r\n...\r\n如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\r\n\r\n不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。\r\n\r\n###RUN 执行命令\r\nRUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：\r\n\r\nshell 格式：RUN <命令>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。\r\n    RUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\r\nexec 格式：RUN [\"可执行文件\", \"参数1\", \"参数2\"]，这更像是函数调用中的格式。\r\n既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：\r\n\r\n    FROM debian:jessie\r\n    \r\n    RUN apt-get update\r\n    RUN apt-get install -y gcc libc6-dev make\r\n    RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\r\n    RUN mkdir -p /usr/src/redis\r\n    RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1\r\n    RUN make -C /usr/src/redis\r\n    RUN make -C /usr/src/redis install\r\n之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。\r\n\r\n而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。\r\n\r\nUnion FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。\r\n\r\n上面的 Dockerfile 正确的写法应该是这样：\r\n\r\n    FROM debian:jessie\r\n    \r\n    RUN buildDeps=\'gcc libc6-dev make\' \\\r\n        && apt-get update \\\r\n        && apt-get install -y $buildDeps \\\r\n        && wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\" \\\r\n        && mkdir -p /usr/src/redis \\\r\n        && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\\r\n        && make -C /usr/src/redis \\\r\n        && make -C /usr/src/redis install \\\r\n        && rm -rf /var/lib/apt/lists/* \\\r\n        && rm redis.tar.gz \\\r\n        && rm -r /usr/src/redis \\\r\n        && apt-get purge -y --auto-remove $buildDeps\r\n首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 && 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。\r\n\r\n并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 ### 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。\r\n\r\n此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\r\n\r\n很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。\r\n\r\n###构建镜像\r\n好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。\r\n\r\n在 Dockerfile 文件所在目录执行：\r\n\r\n    $ docker build -t nginx:v3 .\r\n    Sending build context to Docker daemon 2.048 kB\r\n    Step 1 : FROM nginx\r\n     ---> e43d811ce2f4\r\n    Step 2 : RUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\r\n     ---> Running in 9cdc27646c7b\r\n     ---> 44aa4490ce2c\r\n    Removing intermediate container 9cdc27646c7b\r\n    Successfully built 44aa4490ce2c\r\n从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。\r\n\r\n这里我们使用了 docker build 命令进行镜像构建。其格式为：\r\n\r\n`docker build [选项] <上下文路径/URL/->`\r\n在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。\r\n\r\n###镜像构建上下文（Context）\r\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？\r\n\r\n首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。\r\n\r\n当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？\r\n\r\n这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\r\n\r\n如果在 Dockerfile 中这么写：\r\n\r\n`COPY ./package.json /app/`\r\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\r\n\r\n因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\r\n\r\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\r\n\r\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\r\n\r\n    $ docker build -t nginx:v3 .\r\n    Sending build context to Docker daemon 2.048 kB\r\n    ...\r\n理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。\r\n\r\n一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\r\n\r\n那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。\r\n\r\n这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。\r\n\r\n当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。\r\n\r\n###其它 docker build 的用法\r\n###直接用 Git repo 进行构建\r\n或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：\r\n\r\n    $ docker build https://github.com/twang2218/gitlab-ce-zh.git###:8.14\r\n    docker build https://github.com/twang2218/gitlab-ce-zh.git\\###:8.14\r\n    Sending build context to Docker daemon 2.048 kB\r\n    Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0\r\n    8.14.0-ce.0: Pulling from gitlab/gitlab-ce\r\n    aed15891ba52: Already exists\r\n    773ae8583d14: Already exists\r\n    ...\r\n这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /8.14/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。\r\n\r\n###用给定的 tar 压缩包构建\r\n`$ docker build http://server/context.tar.gz`\r\n如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。\r\n\r\n###从标准输入中读取 Dockerfile 进行构建\r\n`docker build - < Dockerfile`\r\n或\r\n\r\n`cat Dockerfile | docker build -`\r\n如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。\r\n\r\n`###从标准输入中读取上下文压缩包进行构建\r\n$ docker build - < context.tar.gz`\r\n如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。', '<h3 id=\"h3-dockerfile-\"><a name=\"Dockerfile 定制镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dockerfile 定制镜像</h3><p>从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>\r\n<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>\r\n<p>还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。</p>\r\n<p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>\r\n<pre><code>$ mkdir mynginx\r\n$ cd mynginx\r\n$ touch Dockerfile\r\n</code></pre><p>其内容为：</p>\r\n<pre><code>FROM nginx\r\nRUN echo \'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;\' &gt; /usr/share/nginx/html/index.html\r\n</code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p>\r\n<h3 id=\"h3-from-\"><a name=\"FROM 指定基础镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p>\r\n<p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>\r\n<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>\r\n<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>\r\n<p><code>FROM scratch</code><br>…<br>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\r\n<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>\r\n<h3 id=\"h3-run-\"><a name=\"RUN 执行命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>\r\n<p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。<br>    RUN echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html<br>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。<br>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：\r\n<pre><code>FROM debian:jessie\r\n\r\nRUN apt-get update\r\nRUN apt-get install -y gcc libc6-dev make\r\nRUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\r\nRUN mkdir -p /usr/src/redis\r\nRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1\r\nRUN make -C /usr/src/redis\r\nRUN make -C /usr/src/redis install\r\n</code></pre><p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p>\r\n<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>\r\n<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>\r\n<p>上面的 Dockerfile 正确的写法应该是这样：</p>\r\n<pre><code>FROM debian:jessie\r\n\r\nRUN buildDeps=\'gcc libc6-dev make\' \\\r\n    &amp;&amp; apt-get update \\\r\n    &amp;&amp; apt-get install -y $buildDeps \\\r\n    &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\" \\\r\n    &amp;&amp; mkdir -p /usr/src/redis \\\r\n    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\\r\n    &amp;&amp; make -C /usr/src/redis \\\r\n    &amp;&amp; make -C /usr/src/redis install \\\r\n    &amp;&amp; rm -rf /var/lib/apt/lists/* \\\r\n    &amp;&amp; rm redis.tar.gz \\\r\n    &amp;&amp; rm -r /usr/src/redis \\\r\n    &amp;&amp; apt-get purge -y --auto-remove $buildDeps\r\n</code></pre><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>\r\n<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 ### 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>\r\n<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\r\n<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>\r\n<h3 id=\"h3-u6784u5EFAu955Cu50CF\"><a name=\"构建镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>\r\n<p>在 Dockerfile 文件所在目录执行：</p>\r\n<pre><code>$ docker build -t nginx:v3 .\r\nSending build context to Docker daemon 2.048 kB\r\nStep 1 : FROM nginx\r\n ---&gt; e43d811ce2f4\r\nStep 2 : RUN echo \'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;\' &gt; /usr/share/nginx/html/index.html\r\n ---&gt; Running in 9cdc27646c7b\r\n ---&gt; 44aa4490ce2c\r\nRemoving intermediate container 9cdc27646c7b\r\nSuccessfully built 44aa4490ce2c\r\n</code></pre><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。</p>\r\n<p>这里我们使用了 docker build 命令进行镜像构建。其格式为：</p>\r\n<p><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code><br>在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。\r\n<h3 id=\"h3--context-\"><a name=\"镜像构建上下文（Context）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>镜像构建上下文（Context）</h3><p>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p>\r\n<p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>\r\n<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>\r\n<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>\r\n<p>如果在 Dockerfile 中这么写：</p>\r\n<p><code>COPY ./package.json /app/</code><br>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\r\n<p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>\r\n<p>现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>\r\n<p>如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>\r\n<pre><code>$ docker build -t nginx:v3 .\r\nSending build context to Docker daemon 2.048 kB\r\n...\r\n</code></pre><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。</p>\r\n<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>\r\n<p>那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>\r\n<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p>\r\n<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>\r\n<h3 id=\"h3--docker-build-\"><a name=\"其它 docker build 的用法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其它 docker build 的用法</h3><h3 id=\"h3--git-repo-\"><a name=\"直接用 Git repo 进行构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>直接用 Git repo 进行构建</h3><p>或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>\r\n<pre><code>$ docker build https://github.com/twang2218/gitlab-ce-zh.git###:8.14\r\ndocker build https://github.com/twang2218/gitlab-ce-zh.git\\###:8.14\r\nSending build context to Docker daemon 2.048 kB\r\nStep 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0\r\n8.14.0-ce.0: Pulling from gitlab/gitlab-ce\r\naed15891ba52: Already exists\r\n773ae8583d14: Already exists\r\n...\r\n</code></pre><p>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /8.14/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>\r\n<h3 id=\"h3--tar-\"><a name=\"用给定的 tar 压缩包构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>用给定的 tar 压缩包构建</h3><p><code>$ docker build http://server/context.tar.gz</code><br>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。\r\n<h3 id=\"h3--dockerfile-\"><a name=\"从标准输入中读取 Dockerfile 进行构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从标准输入中读取 Dockerfile 进行构建</h3><p><code>docker build - &lt; Dockerfile</code><br>或\r\n<p><code>cat Dockerfile | docker build -</code><br>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。\r\n<p><code>###从标准输入中读取上下文压缩包进行构建\r\n$ docker build - &lt; context.tar.gz</code><br>如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。\r\n', null, null, null, '2020-10-19 21:15:56', '2020-10-19 21:15:56', '1');
INSERT INTO `articles` VALUES ('61', '1', 'Dockerfile 指令', '', '> 我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。\r\n\r\n###COPY\r\n格式：\r\n\r\n`COPY <源路径>... <目标路径>`\r\n`COPY [\"<源路径1>\",... \"<目标路径>\"]`\r\n和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。\r\n\r\nCOPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置。比如：\r\n\r\n`COPY package.json /usr/src/app/`\r\n<源路径> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\r\n\r\n    COPY hom* /mydir/\r\n    COPY hom?.txt /mydir/\r\n<目标路径> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。\r\n\r\n此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。\r\n\r\n###ADD\r\nADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。\r\n\r\n比如 <源路径> 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <目标路径> 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。\r\n\r\n如果 <源路径> 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 <目标路径> 去。\r\n\r\n在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：\r\n    \r\n    FROM scratch\r\n    ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\r\n    ...\r\n但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。\r\n\r\n在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。\r\n\r\n另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\r\n\r\n因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。\r\n\r\n###CMD\r\nCMD 指令的格式和 RUN 相似，也是两种格式：\r\n\r\n    shell 格式：CMD <命令>\r\n    exec 格式：CMD [\"可执行文件\", \"参数1\", \"参数2\"...]\r\n参数列表格式：CMD [\"参数1\", \"参数2\"...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。\r\n之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。\r\n\r\n在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。\r\n\r\n在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 \"，而不要使用单引号。\r\n\r\n如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：\r\n\r\n`CMD echo $HOME`\r\n在实际执行中，会将其变更为：\r\n\r\n`CMD [ \"sh\", \"-c\", \"echo $HOME\" ]`\r\n这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。\r\n\r\n提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。\r\n\r\nDocker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。\r\n\r\n一些初学者将 CMD 写为：\r\n\r\n`CMD service nginx start`\r\n然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。\r\n\r\n对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。\r\n\r\n而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ \"sh\", \"-c\", \"service nginx start\"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。\r\n\r\n正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：\r\n\r\n`CMD [\"nginx\", \"-g\", \"daemon off;\"]`\r\n###ENTRYPOINT\r\nENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。\r\n\r\nENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。\r\n\r\n当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：\r\n\r\n`<ENTRYPOINT> \"<CMD>\"`\r\n那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 `<ENTRYPOINT> \"<CMD>\" `有什么好处么？让我们来看几个场景。\r\n\r\n###场景一：让镜像变成像命令一样使用\r\n假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：\r\n\r\n    FROM ubuntu:16.04\r\n    RUN apt-get update \\\r\n        && apt-get install -y curl \\\r\n        && rm -rf /var/lib/apt/lists/*\r\n    CMD [ \"curl\", \"-s\", \"http://ip.cn\" ]\r\n假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：\r\n\r\n`$ docker run myip`\r\n当前 IP：61.148.226.66 来自：北京市 联通\r\n嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？\r\n\r\n    $ docker run myip -i\r\n    docker: Error response from daemon: invalid header field value \"oci runtime error: container_linux.go:247: starting container process caused \\\"exec: \\\\\\\"-i\\\\\\\": executable file not found in $PATH\\\"\\n\".\r\n我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。\r\n\r\n那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：\r\n\r\n`$ docker run myip curl -s http://ip.cn -i`\r\n这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：\r\n\r\n    FROM ubuntu:16.04\r\n    RUN apt-get update \\\r\n        && apt-get install -y curl \\\r\n        && rm -rf /var/lib/apt/lists/*\r\n    ENTRYPOINT [ \"curl\", \"-s\", \"http://ip.cn\" ]\r\n这次我们再来尝试直接使用 docker run myip -i：\r\n\r\n`$ docker run myip`\r\n当前 IP：61.148.226.66 来自：北京市 联通\r\n\r\n    $ docker run myip -i\r\n    HTTP/1.1 200 OK\r\n    Server: nginx/1.8.0\r\n    Date: Tue, 22 Nov 2016 05:12:40 GMT\r\n    Content-Type: text/html; charset=UTF-8\r\n    Vary: Accept-Encoding\r\n    X-Powered-By: PHP/5.6.24-1~dotdeb+7.1\r\n    X-Cache: MISS from cache-2\r\n    X-Cache-Lookup: MISS from cache-2:80\r\n    X-Cache: MISS from proxy-2_6\r\n    Transfer-Encoding: chunked\r\n    Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006\r\n    Connection: keep-alive\r\n\r\n当前 IP：61.148.226.66 来自：北京市 联通\r\n可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。\r\n\r\n###场景二：应用运行前的准备工作\r\n启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。\r\n\r\n比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。\r\n\r\n此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。\r\n\r\n这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 <CMD>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：\r\n\r\n    FROM alpine:3.4\r\n    ...\r\n    RUN addgroup -S redis && adduser -S -G redis redis\r\n    ...\r\n    ENTRYPOINT [\"docker-entrypoint.sh\"]\r\n    \r\n    EXPOSE 6379\r\n    CMD [ \"redis-server\" ]\r\n可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。\r\n\r\n    #!/bin/sh\r\n    ...\r\n    # allow the container to be started with `--user`\r\n    if [ \"$1\" = \'redis-server\' -a \"$(id -u)\" = \'0\' ]; then\r\n    	chown -R redis .\r\n    	exec su-exec redis \"$0\" \"$@\"\r\n    fi\r\n    \r\n    exec \"$@\"\r\n该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：\r\n\r\n    $ docker run -it redis id\r\n    uid=0(root) gid=0(root) groups=0(root)\r\n###ENV\r\n格式有两种：\r\n\r\n    ENV <key> <value>\r\n    ENV <key1>=<value1> <key2>=<value2>...\r\n这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。\r\n\r\n    ENV VERSION=1.0 DEBUG=on \\\r\n        NAME=\"Happy Feet\"\r\n这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。\r\n\r\n定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：\r\n\r\n    ENV NODE_VERSION 7.2.0\r\n    \r\n    RUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\\r\n      && curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" \\\r\n      && gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \\\r\n      && grep \" node-v$NODE_VERSION-linux-x64.tar.xz\\$\" SHASUMS256.txt | sha256sum -c - \\\r\n      && tar -xJf \"node-v$NODE_VERSION-linux-x64.tar.xz\" -C /usr/local --strip-components=1 \\\r\n      && rm \"node-v$NODE_VERSION-linux-x64.tar.xz\" SHASUMS256.txt.asc SHASUMS256.txt \\\r\n      && ln -s /usr/local/bin/node /usr/local/bin/nodejs\r\n在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。\r\n\r\n下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。\r\n\r\n可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。\r\n\r\n###VOLUME\r\n格式为：\r\n\r\n    VOLUME [\"<路径1>\", \"<路径2>\"...]\r\n    VOLUME <路径>\r\n之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。\r\n`VOLUME /data`\r\n这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\r\n\r\n`docker run -d -v mydata:/data xxxx`\r\n在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。\r\n\r\n###EXPOSE\r\n格式为 `EXPOSE <端口1> [<端口2>...]`。\r\n\r\nEXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\r\n\r\n此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 --icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 --links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 --icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。\r\n\r\n要将 EXPOSE 和在运行时使用 -p <宿主端口>:<容器端口> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。\r\n\r\n###WORKDIR\r\n格式为 `WORKDIR <工作目录路径>`。\r\n\r\n使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。\r\n\r\n之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：\r\n\r\n    RUN cd /app\r\n    RUN echo \"hello\" > world.txt\r\n如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。\r\n\r\n之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。\r\n\r\n因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。', '<blockquote>\r\n<p>我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</p>\r\n</blockquote>\r\n<h3 id=\"h3-copy\"><a name=\"COPY\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>COPY</h3><p>格式：</p>\r\n<p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code><br><code>COPY [\"&lt;源路径1&gt;\",... \"&lt;目标路径&gt;\"]</code><br>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。\r\n<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</p>\r\n<p><code>COPY package.json /usr/src/app/</code><br><源路径> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\r\n<pre><code>COPY hom* /mydir/\r\nCOPY hom?.txt /mydir/\r\n</code></pre><p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>\r\n<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>\r\n<h3 id=\"h3-add\"><a name=\"ADD\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ADD</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p>\r\n<p>比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>\r\n<p>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</p>\r\n<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：</p>\r\n<pre><code>FROM scratch\r\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\r\n...\r\n</code></pre><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p>\r\n<p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。</p>\r\n<p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>\r\n<p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>\r\n<h3 id=\"h3-cmd\"><a name=\"CMD\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CMD</h3><p>CMD 指令的格式和 RUN 相似，也是两种格式：</p>\r\n<pre><code>shell 格式：CMD &lt;命令&gt;\r\nexec 格式：CMD [\"可执行文件\", \"参数1\", \"参数2\"...]\r\n</code></pre><p>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。<br>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。\r\n<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。</p>\r\n<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。</p>\r\n<p>如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</p>\r\n<p><code>CMD echo $HOME</code><br>在实际执行中，会将其变更为：\r\n<p><code>CMD [ \"sh\", \"-c\", \"echo $HOME\" ]</code><br>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。\r\n<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>\r\n<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>\r\n<p>一些初学者将 CMD 写为：</p>\r\n<p><code>CMD service nginx start</code><br>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。\r\n<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>\r\n<p>而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx start”]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>\r\n<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>\r\n<p><code>CMD [\"nginx\", \"-g\", \"daemon off;\"]</code></p>\r\n<h3 id=\"h3-entrypoint\"><a name=\"ENTRYPOINT\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ENTRYPOINT</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>\r\n<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 —entrypoint 来指定。</p>\r\n<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p>\r\n<p><code>&lt;ENTRYPOINT&gt; \"&lt;CMD&gt;\"</code><br>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <code>&lt;ENTRYPOINT&gt; \"&lt;CMD&gt;\"</code>有什么好处么？让我们来看几个场景。</p>\r\n<h3 id=\"h3--\"><a name=\"场景一：让镜像变成像命令一样使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>场景一：让镜像变成像命令一样使用</h3><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p>\r\n<pre><code>FROM ubuntu:16.04\r\nRUN apt-get update \\\r\n    &amp;&amp; apt-get install -y curl \\\r\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\r\nCMD [ \"curl\", \"-s\", \"http://ip.cn\" ]\r\n</code></pre><p>假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>\r\n<p><code>$ docker run myip</code><br>当前 IP：61.148.226.66 来自：北京市 联通<br>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？\r\n<pre><code>$ docker run myip -i\r\ndocker: Error response from daemon: invalid header field value \"oci runtime error: container_linux.go:247: starting container process caused \\\"exec: \\\\\\\"-i\\\\\\\": executable file not found in $PATH\\\"\\n\".\r\n</code></pre><p>我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a href=\"http://ip.cn\">http://ip.cn</a> 后面。而 -i 根本不是命令，所以自然找不到。</p>\r\n<p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>\r\n<p><code>$ docker run myip curl -s http://ip.cn -i</code><br>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：\r\n<pre><code>FROM ubuntu:16.04\r\nRUN apt-get update \\\r\n    &amp;&amp; apt-get install -y curl \\\r\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\r\nENTRYPOINT [ \"curl\", \"-s\", \"http://ip.cn\" ]\r\n</code></pre><p>这次我们再来尝试直接使用 docker run myip -i：</p>\r\n<p><code>$ docker run myip</code><br>当前 IP：61.148.226.66 来自：北京市 联通\r\n<pre><code>$ docker run myip -i\r\nHTTP/1.1 200 OK\r\nServer: nginx/1.8.0\r\nDate: Tue, 22 Nov 2016 05:12:40 GMT\r\nContent-Type: text/html; charset=UTF-8\r\nVary: Accept-Encoding\r\nX-Powered-By: PHP/5.6.24-1~dotdeb+7.1\r\nX-Cache: MISS from cache-2\r\nX-Cache-Lookup: MISS from cache-2:80\r\nX-Cache: MISS from proxy-2_6\r\nTransfer-Encoding: chunked\r\nVia: 1.1 cache-2:80, 1.1 proxy-2_6:8006\r\nConnection: keep-alive\r\n</code></pre><p>当前 IP：61.148.226.66 来自：北京市 联通<br>可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。\r\n<h3 id=\"h3--\"><a name=\"场景二：应用运行前的准备工作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>场景二：应用运行前的准备工作</h3><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>\r\n<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>\r\n<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>\r\n<p>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 <cmd>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：<p></p></cmd>\r\n<pre><code>FROM alpine:3.4\r\n...\r\nRUN addgroup -S redis &amp;&amp; adduser -S -G redis redis\r\n...\r\nENTRYPOINT [\"docker-entrypoint.sh\"]\r\n\r\nEXPOSE 6379\r\nCMD [ \"redis-server\" ]\r\n</code></pre><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。</p>\r\n<pre><code>#!/bin/sh\r\n...\r\n# allow the container to be started with `--user`\r\nif [ \"$1\" = \'redis-server\' -a \"$(id -u)\" = \'0\' ]; then\r\n    chown -R redis .\r\n    exec su-exec redis \"$0\" \"$@\"\r\nfi\r\n\r\nexec \"$@\"\r\n</code></pre><p>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p>\r\n<pre><code>$ docker run -it redis id\r\nuid=0(root) gid=0(root) groups=0(root)\r\n</code></pre><h3 id=\"h3-env\"><a name=\"ENV\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ENV</h3><p>格式有两种：</p>\r\n<pre><code>ENV &lt;key&gt; &lt;value&gt;\r\nENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...\r\n</code></pre><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>\r\n<pre><code>ENV VERSION=1.0 DEBUG=on \\\r\n    NAME=\"Happy Feet\"\r\n</code></pre><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>\r\n<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>\r\n<pre><code>ENV NODE_VERSION 7.2.0\r\n\r\nRUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\\r\n  &amp;&amp; curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" \\\r\n  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \\\r\n  &amp;&amp; grep \" node-v$NODE_VERSION-linux-x64.tar.xz\\$\" SHASUMS256.txt | sha256sum -c - \\\r\n  &amp;&amp; tar -xJf \"node-v$NODE_VERSION-linux-x64.tar.xz\" -C /usr/local --strip-components=1 \\\r\n  &amp;&amp; rm \"node-v$NODE_VERSION-linux-x64.tar.xz\" SHASUMS256.txt.asc SHASUMS256.txt \\\r\n  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs\r\n</code></pre><p>在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。</p>\r\n<p>下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。</p>\r\n<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>\r\n<h3 id=\"h3-volume\"><a name=\"VOLUME\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>VOLUME</h3><p>格式为：</p>\r\n<pre><code>VOLUME [\"&lt;路径1&gt;\", \"&lt;路径2&gt;\"...]\r\nVOLUME &lt;路径&gt;\r\n</code></pre><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。<br><code>VOLUME /data</code><br>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\r\n<p><code>docker run -d -v mydata:/data xxxx</code><br>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。\r\n<h3 id=\"h3-expose\"><a name=\"EXPOSE\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>EXPOSE</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>\r\n<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>\r\n<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 —icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 —links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 —icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</p>\r\n<p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>\r\n<h3 id=\"h3-workdir\"><a name=\"WORKDIR\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>WORKDIR</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>\r\n<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>\r\n<p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>\r\n<pre><code>RUN cd /app\r\nRUN echo \"hello\" &gt; world.txt\r\n</code></pre><p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p>\r\n<p>之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>\r\n<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>\r\n', null, null, null, '2020-10-19 21:21:04', '2020-10-19 21:21:04', '1');
INSERT INTO `articles` VALUES ('62', '1', 'Docker 构建 MySQL', '', '### 查找 Docker Hub 上的 MySQL 镜像查找 Docker Hub 上的 MySQL 镜像\r\n\r\n\r\n    root@UbuntuBase:/usr/local/docker/mysql# docker search mysql\r\n    NAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\r\n    mysql                                                  MySQL is a widely used, open-source relati...   5177                [OK]                \r\n    mariadb                                                MariaDB is a community-developed fork of M...   1602                [OK]                \r\n    mysql/mysql-server                                     Optimized MySQL Server Docker images. Crea...   361                                     [OK]\r\n    percona                                                Percona Server is a fork of the MySQL rela...   298                 [OK]                \r\n    hypriot/rpi-mysql                                      RPi-compatible Docker Image with Mysql          72                                      \r\n    zabbix/zabbix-server-mysql                             Zabbix Server with MySQL database support       62                                      [OK]\r\n    centurylink/mysql                                      Image containing mysql. Optimized to be li...   53                                      [OK]\r\n    sameersbn/mysql                                                                                        48                                      [OK]\r\n    zabbix/zabbix-web-nginx-mysql                          Zabbix frontend based on Nginx web-server ...   36                                      [OK]\r\n    tutum/mysql                                            Base docker image to run a MySQL database ...   27                                      \r\n    1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5   ubuntu-16-nginx-php-phpmyadmin-mysql-5          17                                      [OK]\r\n    schickling/mysql-backup-s3                             Backup MySQL to S3 (supports periodic back...   16                                      [OK]\r\n    centos/mysql-57-centos7                                MySQL 5.7 SQL database server                   15                                      \r\n    linuxserver/mysql                                      A Mysql container, brought to you by Linux...   12                                      \r\n    centos/mysql-56-centos7                                MySQL 5.6 SQL database server                   6                                       \r\n    openshift/mysql-55-centos7                             DEPRECATED: A Centos7 based MySQL v5.5 ima...   6                                       \r\n    frodenas/mysql                                         A Docker Image for MySQL                        3                                       [OK]\r\n    dsteinkopf/backup-all-mysql                            backup all DBs in a mysql server                3                                       [OK]\r\n    circleci/mysql                                         MySQL is a widely used, open-source relati...   2                                       \r\n    cloudposse/mysql                                       Improved `mysql` service with support for ...   0                                       [OK]\r\n    astronomerio/mysql-sink                                MySQL sink                                      0                                       [OK]\r\n    ansibleplaybookbundle/rhscl-mysql-apb                  An APB which deploys RHSCL MySQL                0                                       [OK]\r\n    cloudfoundry/cf-mysql-ci                               Image used in CI of cf-mysql-release            0                                       \r\n    astronomerio/mysql-source                              MySQL source                                    0                                       [OK]\r\n    jenkler/mysql                                          Docker Mysql package                            0                                       \r\n这里我们拉取官方的镜像\r\n\r\n`docker pull mysql`\r\n等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 mysql 的镜像\r\n\r\n###运行容器：\r\n\r\n\r\n    docker run -p 3306:3306 --name mysql \\\r\n    -v /usr/local/docker/mysql/conf:/etc/mysql \\\r\n    -v /usr/local/docker/mysql/logs:/var/log/mysql \\\r\n    -v /usr/local/docker/mysql/data:/var/lib/mysql \\\r\n    -e MYSQL_ROOT_PASSWORD=123456 \\\r\n    -d mysql\r\n命令参数：\r\n\r\n`-p 3306:3306`：将容器的3306端口映射到主机的3306端口\r\n`-v /usr/local/docker/mysql/conf:/etc/mysql`：将主机当前目录下的 conf 挂载到容器的 /etc/mysql\r\n`-v /usr/local/docker/mysql/logs:/var/log/mysql`：将主机当前目录下的 logs 目录挂载到容器的 /var/log/mysql\r\n`-v /usr/local/docker/mysql/data:/var/lib/mysql`：将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql\r\n`-e MYSQL\\_ROOT\\_PASSWORD=123456`：初始化root用户的密码\r\n查看容器启动情况\r\n\r\n\r\n\r\n    root@UbuntuBase:/usr/local/docker/mysql# docker ps\r\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\r\n    bc49c9de4cdf        mysql:latest        \"docker-entrypoint...\"   4 minutes ago       Up 4 minutes        0.0.0.0:3306->3306/tcp   mysql\r\n使用客户端工具连接 MySQL\r\n\r\n', '<h3 id=\"h3--docker-hub-mysql-docker-hub-mysql-\"><a name=\"查找 Docker Hub 上的 MySQL 镜像查找 Docker Hub 上的 MySQL 镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查找 Docker Hub 上的 MySQL 镜像查找 Docker Hub 上的 MySQL 镜像</h3><pre><code>root@UbuntuBase:/usr/local/docker/mysql# docker search mysql\r\nNAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\r\nmysql                                                  MySQL is a widely used, open-source relati...   5177                [OK]                \r\nmariadb                                                MariaDB is a community-developed fork of M...   1602                [OK]                \r\nmysql/mysql-server                                     Optimized MySQL Server Docker images. Crea...   361                                     [OK]\r\npercona                                                Percona Server is a fork of the MySQL rela...   298                 [OK]                \r\nhypriot/rpi-mysql                                      RPi-compatible Docker Image with Mysql          72                                      \r\nzabbix/zabbix-server-mysql                             Zabbix Server with MySQL database support       62                                      [OK]\r\ncenturylink/mysql                                      Image containing mysql. Optimized to be li...   53                                      [OK]\r\nsameersbn/mysql                                                                                        48                                      [OK]\r\nzabbix/zabbix-web-nginx-mysql                          Zabbix frontend based on Nginx web-server ...   36                                      [OK]\r\ntutum/mysql                                            Base docker image to run a MySQL database ...   27                                      \r\n1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5   ubuntu-16-nginx-php-phpmyadmin-mysql-5          17                                      [OK]\r\nschickling/mysql-backup-s3                             Backup MySQL to S3 (supports periodic back...   16                                      [OK]\r\ncentos/mysql-57-centos7                                MySQL 5.7 SQL database server                   15                                      \r\nlinuxserver/mysql                                      A Mysql container, brought to you by Linux...   12                                      \r\ncentos/mysql-56-centos7                                MySQL 5.6 SQL database server                   6                                       \r\nopenshift/mysql-55-centos7                             DEPRECATED: A Centos7 based MySQL v5.5 ima...   6                                       \r\nfrodenas/mysql                                         A Docker Image for MySQL                        3                                       [OK]\r\ndsteinkopf/backup-all-mysql                            backup all DBs in a mysql server                3                                       [OK]\r\ncircleci/mysql                                         MySQL is a widely used, open-source relati...   2                                       \r\ncloudposse/mysql                                       Improved `mysql` service with support for ...   0                                       [OK]\r\nastronomerio/mysql-sink                                MySQL sink                                      0                                       [OK]\r\nansibleplaybookbundle/rhscl-mysql-apb                  An APB which deploys RHSCL MySQL                0                                       [OK]\r\ncloudfoundry/cf-mysql-ci                               Image used in CI of cf-mysql-release            0                                       \r\nastronomerio/mysql-source                              MySQL source                                    0                                       [OK]\r\njenkler/mysql                                          Docker Mysql package                            0                                       \r\n</code></pre><p>这里我们拉取官方的镜像</p>\r\n<p><code>docker pull mysql</code><br>等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 mysql 的镜像\r\n<h3 id=\"h3--\"><a name=\"运行容器：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行容器：</h3><pre><code>docker run -p 3306:3306 --name mysql \\\r\n-v /usr/local/docker/mysql/conf:/etc/mysql \\\r\n-v /usr/local/docker/mysql/logs:/var/log/mysql \\\r\n-v /usr/local/docker/mysql/data:/var/lib/mysql \\\r\n-e MYSQL_ROOT_PASSWORD=123456 \\\r\n-d mysql\r\n</code></pre><p>命令参数：</p>\r\n<p><code>-p 3306:3306</code>：将容器的3306端口映射到主机的3306端口<br><code>-v /usr/local/docker/mysql/conf:/etc/mysql</code>：将主机当前目录下的 conf 挂载到容器的 /etc/mysql<br><code>-v /usr/local/docker/mysql/logs:/var/log/mysql</code>：将主机当前目录下的 logs 目录挂载到容器的 /var/log/mysql<br><code>-v /usr/local/docker/mysql/data:/var/lib/mysql</code>：将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql<br><code>-e MYSQL\\_ROOT\\_PASSWORD=123456</code>：初始化root用户的密码<br>查看容器启动情况\r\n<pre><code>root@UbuntuBase:/usr/local/docker/mysql# docker ps\r\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\r\nbc49c9de4cdf        mysql:latest        \"docker-entrypoint...\"   4 minutes ago       Up 4 minutes        0.0.0.0:3306-&gt;3306/tcp   mysql\r\n</code></pre><p>使用客户端工具连接 MySQL</p>\r\n', null, null, null, '2020-10-19 21:24:02', '2020-10-19 21:24:02', '1');
INSERT INTO `articles` VALUES ('63', '1', '什么是 Docker Compose', '', '> Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。\r\n\r\n###概述\r\nCompose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。\r\n\r\n其代码目前在 https://github.com/docker/compose 上开源。\r\n\r\nCompose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。\r\n\r\n通过第一部分中的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\r\n\r\nCompose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\r\n\r\nCompose 中有两个重要的概念：\r\n\r\n服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。\r\n项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。\r\nCompose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\r\n\r\nCompose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。', '<blockquote>\r\n<p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>\r\n</blockquote>\r\n<h3 id=\"h3-u6982u8FF0\"><a name=\"概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>概述</h3><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。</p>\r\n<p>其代码目前在 <a href=\"https://github.com/docker/compose\">https://github.com/docker/compose</a> 上开源。</p>\r\n<p>Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\r\n<p>通过第一部分中的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\r\n<p>Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\r\n<p>Compose 中有两个重要的概念：</p>\r\n<p>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。<br>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。<br>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。\r\n<p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p>\r\n', null, null, null, '2020-10-19 21:25:29', '2020-10-19 21:25:29', '1');
INSERT INTO `articles` VALUES ('64', '1', 'Docker Compose 使用', '', '### 术语\r\n首先介绍几个术语。\r\n\r\n服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。\r\n项目 (project)：由一组关联的应用容器组成的一个完整业务单元。\r\n可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。\r\n\r\n###场景\r\n最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。\r\n\r\n下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。\r\n\r\n###web 应用\r\n新建文件夹，在该目录中编写 app.py 文件\r\n    from flask import Flask\r\n    from redis import Redis\r\n    \r\n    app = Flask(__name__)\r\n    redis = Redis(host=\'redis\', port=6379)\r\n    \r\n    @app.route(\'/\')\r\n    def hello():\r\n        count = redis.incr(\'hits\')\r\n        return \'Hello World! 该页面已被访问 {} 次。\\n\'.format(count)\r\n    \r\n    if __name__ == \"__main__\":\r\n        app.run(host=\"0.0.0.0\", debug=True)\r\n###Dockerfile\r\n编写 Dockerfile 文件，内容为\r\n\r\n    FROM python:3.6-alpine\r\n    ADD . /code\r\n    WORKDIR /code\r\n    RUN pip install redis flask\r\n    CMD [\"python\", \"app.py\"]\r\n###docker-compose.yml\r\n编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。\r\n\r\n    version: \'3\'\r\n    services:\r\n    \r\n      web:\r\n        build: .\r\n        ports:\r\n         - \"5000:5000\"\r\n         \r\n      redis:\r\n        image: \"redis:alpine\"\r\n###运行 compose 项目\r\n`$ docker-compose up`\r\n此时访问本地 5000 端口，每次刷新页面，计数就会加 1。', '<h3 id=\"h3-u672Fu8BED\"><a name=\"术语\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>术语</h3><p>首先介绍几个术语。</p>\r\n<p>服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。<br>项目 (project)：由一组关联的应用容器组成的一个完整业务单元。<br>可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。\r\n<h3 id=\"h3-u573Au666F\"><a name=\"场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>场景</h3><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\r\n<p>下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。</p>\r\n<h3 id=\"h3-web-\"><a name=\"web 应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>web 应用</h3><p>新建文件夹，在该目录中编写 app.py 文件<br>    from flask import Flask<br>    from redis import Redis\r\n<pre><code>app = Flask(__name__)\r\nredis = Redis(host=\'redis\', port=6379)\r\n\r\n@app.route(\'/\')\r\ndef hello():\r\n    count = redis.incr(\'hits\')\r\n    return \'Hello World! 该页面已被访问 {} 次。\\n\'.format(count)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(host=\"0.0.0.0\", debug=True)\r\n</code></pre><h3 id=\"h3-dockerfile\"><a name=\"Dockerfile\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dockerfile</h3><p>编写 Dockerfile 文件，内容为</p>\r\n<pre><code>FROM python:3.6-alpine\r\nADD . /code\r\nWORKDIR /code\r\nRUN pip install redis flask\r\nCMD [\"python\", \"app.py\"]\r\n</code></pre><h3 id=\"h3-docker-compose-yml\"><a name=\"docker-compose.yml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>docker-compose.yml</h3><p>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</p>\r\n<pre><code>version: \'3\'\r\nservices:\r\n\r\n  web:\r\n    build: .\r\n    ports:\r\n     - \"5000:5000\"\r\n\r\n  redis:\r\n    image: \"redis:alpine\"\r\n</code></pre><h3 id=\"h3--compose-\"><a name=\"运行 compose 项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行 compose 项目</h3><p><code>$ docker-compose up</code><br>此时访问本地 5000 端口，每次刷新页面，计数就会加 1。\r\n', null, null, null, '2020-10-19 21:26:54', '2020-10-19 21:26:54', '1');
INSERT INTO `articles` VALUES ('65', '1', 'Docker Compose 命令说明', '', '### 命令对象与格式\r\n对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。\r\n\r\n执行 `docker-compose [COMMAND] --help `或者 d`ocker-compose help [COMMAND]` 可以查看具体某个命令的使用格式。\r\n\r\ndocker-compose 命令的基本的使用格式是\r\n\r\n`docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]`\r\n###命令选项\r\n`-f, --file FILE `指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。\r\n`-p, --project-name NAME `指定项目名称，默认将使用所在目录名称作为项目名。\r\n`--x-networking `使用 Docker 的可拔插网络后端特性\r\n`--x-network-driver DRIVER `指定网络后端的驱动，默认为 bridge\r\n`--verbose` 输出更多调试信息。\r\n`-v, --version `打印版本并退出。\r\n###build\r\n格式为 `docker-compose build [options] [SERVICE...]`。\r\n\r\n构建（重新构建）项目中的服务容器。\r\n\r\n服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。\r\n\r\n可以随时在项目目录下运行 docker-compose build 来重新构建服务。\r\n\r\n选项包括：\r\n\r\n`--force-rm` 删除构建过程中的临时容器。\r\n`--no-cache` 构建镜像过程中不使用 cache（这将加长构建过程）。\r\n`--pull `始终尝试通过 pull 来获取更新版本的镜像。\r\n###config\r\n验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。\r\n\r\n###down\r\n此命令将会停止 up 命令所启动的容器，并移除网络\r\n\r\n###exec\r\n进入指定的容器。\r\n\r\n###help\r\n获得一个命令的帮助。\r\n\r\n###images\r\n列出 Compose 文件中包含的镜像。\r\n\r\n###kill\r\n格式为 `docker-compose kill [options] [SERVICE...]`。\r\n\r\n通过发送 SIGKILL 信号来强制停止服务容器。\r\n\r\n支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。\r\n\r\n`$ docker-compose kill -s SIGINT`\r\n###logs\r\n格式为 `docker-compose logs [options] [SERVICE...]`。\r\n\r\n查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。\r\n\r\n该命令在调试问题的时候十分有用。\r\n\r\n###pause\r\n格式为 `docker-compose pause [SERVICE...]`。\r\n\r\n暂停一个服务容器。\r\n\r\n###port\r\n格式为 d`ocker-compose port [options] SERVICE PRIVATE_PORT`。\r\n\r\n打印某个容器端口所映射的公共端口。\r\n\r\n选项：\r\n\r\n`--protocol=proto `指定端口协议，tcp（默认值）或者 udp。\r\n`--index=index` 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。\r\n###ps\r\n格式为 `docker-compose ps [options] [SERVICE...]`。\r\n\r\n列出项目中目前的所有容器。\r\n\r\n选项：\r\n\r\n`-q `只打印容器的 ID 信息。\r\n###pull\r\n格式为 `docker-compose pull [options] [SERVICE...]`。\r\n\r\n拉取服务依赖的镜像。\r\n\r\n选项：\r\n\r\n`--ignore-pull-failures` 忽略拉取镜像过程中的错误。\r\n###push\r\n推送服务依赖的镜像到 Docker 镜像仓库。\r\n\r\n###restart\r\n格式为 `docker-compose restart [options] [SERVICE...]`。\r\n\r\n重启项目中的服务。\r\n\r\n选项：\r\n\r\n`-t, --timeout TIMEOUT `指定重启前停止容器的超时（默认为 10 秒）。\r\n###rm\r\n格式为 `docker-compose rm [options] [SERVICE...]`。\r\n\r\n删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。\r\n\r\n选项：\r\n\r\n`-f, --force `强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\r\n`-v `删除容器所挂载的数据卷。\r\n###run\r\n格式为 `docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]`。\r\n\r\n在指定服务上执行一个命令。\r\n\r\n例如：\r\n\r\n`$ docker-compose run ubuntu ping docker.com`\r\n将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。\r\n\r\n默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。\r\n\r\n该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。\r\n\r\n两个不同点：\r\n\r\n给定命令将会覆盖原有的自动运行命令；\r\n不会自动创建端口，以避免冲突。\r\n如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如\r\n\r\n`$ docker-compose run --no-deps web python manage.py shell`\r\n将不会启动 web 容器所关联的其它容器。\r\n\r\n选项：\r\n\r\n`-d` 后台运行容器。\r\n`--name NAME `为容器指定一个名字。\r\n`--entrypoint CMD` 覆盖默认的容器启动指令。\r\n`-e KEY=VAL `设置环境变量值，可多次使用选项来设置多个环境变量。\r\n`-u, --user=\"\"` 指定运行容器的用户名或者 uid。\r\n`--no-deps` 不自动启动关联的服务容器。\r\n`--rm `运行命令后自动删除容器，d 模式下将忽略。\r\n`-p, --publish=[] `映射容器端口到本地主机。\r\n`--service-ports `配置服务端口并映射到本地主机。\r\n`-T `不分配伪 tty，意味着依赖 tty 的指令将无法运行。\r\n###scale\r\n格式为 `docker-compose scale [options] [SERVICE=NUM...]`。\r\n\r\n设置指定服务运行的容器个数。\r\n\r\n通过 service=num 的参数来设置数量。例如：\r\n\r\n`$ docker-compose scale web=3 db=2`\r\n将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。\r\n\r\n一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。\r\n\r\n选项：\r\n\r\n`-t, --timeout TIMEOUT `停止容器时候的超时（默认为 10 秒）。\r\n###start\r\n格式为 `docker-compose start [SERVICE...]`。\r\n\r\n启动已经存在的服务容器。\r\n\r\n###stop\r\n格式为 `docker-compose stop [options] [SERVICE...]`。\r\n\r\n停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。\r\n\r\n选项：\r\n\r\n`-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\r\n###top\r\n查看各个服务容器内运行的进程。\r\n\r\n###unpause\r\n格式为 `docker-compose unpause [SERVICE...]`。\r\n\r\n恢复处于暂停状态中的服务。\r\n\r\n###up\r\n格式为 `docker-compose up [options] [SERVICE...]`。\r\n\r\n该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。\r\n\r\n链接的服务都将会被自动启动，除非已经处于运行状态。\r\n\r\n可以说，大部分时候都可以直接通过该命令来启动一个项目。\r\n\r\n默认情况，`docker-compose up` 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。\r\n\r\n当通过 `Ctrl-C `停止命令时，所有容器将会停止。\r\n\r\n如果使用 `docker-compose up -d`，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。\r\n\r\n默认情况，如果服务容器已经存在，`docker-compose up` 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 `docker-compose up --no-recreate`。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 `docker-compose up --no-deps -d <SERVICE_NAME> `来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。\r\n\r\n选项：\r\n\r\n`-d `在后台运行服务容器。\r\n`--no-color `不使用颜色来区分不同的服务的控制台输出。\r\n`--no-deps `不启动服务所链接的容器。\r\n`--force-recreate` 强制重新创建容器，不能与 `--no-recreate` 同时使用。\r\n`--no-recreate `如果容器已经存在了，则不重新创建，不能与 `--force-recreate` 同时使用。\r\n`--no-build `不自动构建缺失的服务镜像。\r\n`-t, --timeout TIMEOUT` 停止容器时候的超时（默认为 10 秒）。\r\n###version\r\n格式为 `docker-compose version`。\r\n\r\n打印版本信息。', '<h3 id=\"h3-u547Du4EE4u5BF9u8C61u4E0Eu683Cu5F0F\"><a name=\"命令对象与格式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\r\n<p>执行 <code>docker-compose [COMMAND] --help</code>或者 d<code>ocker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\r\n<p>docker-compose 命令的基本的使用格式是</p>\r\n<p><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></p>\r\n<h3 id=\"h3-u547Du4EE4u9009u9879\"><a name=\"命令选项\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命令选项</h3><p><code>-f, --file FILE</code>指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。<br><code>-p, --project-name NAME</code>指定项目名称，默认将使用所在目录名称作为项目名。<br><code>--x-networking</code>使用 Docker 的可拔插网络后端特性<br><code>--x-network-driver DRIVER</code>指定网络后端的驱动，默认为 bridge<br><code>--verbose</code> 输出更多调试信息。<br><code>-v, --version</code>打印版本并退出。</p>\r\n<h3 id=\"h3-build\"><a name=\"build\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>build</h3><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>\r\n<p>构建（重新构建）项目中的服务容器。</p>\r\n<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>\r\n<p>可以随时在项目目录下运行 docker-compose build 来重新构建服务。</p>\r\n<p>选项包括：</p>\r\n<p><code>--force-rm</code> 删除构建过程中的临时容器。<br><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。<br><code>--pull</code>始终尝试通过 pull 来获取更新版本的镜像。</p>\r\n<h3 id=\"h3-config\"><a name=\"config\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>config</h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>\r\n<h3 id=\"h3-down\"><a name=\"down\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>down</h3><p>此命令将会停止 up 命令所启动的容器，并移除网络</p>\r\n<h3 id=\"h3-exec\"><a name=\"exec\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>exec</h3><p>进入指定的容器。</p>\r\n<h3 id=\"h3-help\"><a name=\"help\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>help</h3><p>获得一个命令的帮助。</p>\r\n<h3 id=\"h3-images\"><a name=\"images\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>images</h3><p>列出 Compose 文件中包含的镜像。</p>\r\n<h3 id=\"h3-kill\"><a name=\"kill\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>kill</h3><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>\r\n<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>\r\n<p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>\r\n<p><code>$ docker-compose kill -s SIGINT</code></p>\r\n<h3 id=\"h3-logs\"><a name=\"logs\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>logs</h3><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>\r\n<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 —no-color 来关闭颜色。</p>\r\n<p>该命令在调试问题的时候十分有用。</p>\r\n<h3 id=\"h3-pause\"><a name=\"pause\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>pause</h3><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>\r\n<p>暂停一个服务容器。</p>\r\n<h3 id=\"h3-port\"><a name=\"port\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>port</h3><p>格式为 d<code>ocker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>\r\n<p>打印某个容器端口所映射的公共端口。</p>\r\n<p>选项：</p>\r\n<p><code>--protocol=proto</code>指定端口协议，tcp（默认值）或者 udp。<br><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p>\r\n<h3 id=\"h3-ps\"><a name=\"ps\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ps</h3><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\r\n<p>列出项目中目前的所有容器。</p>\r\n<p>选项：</p>\r\n<p><code>-q</code>只打印容器的 ID 信息。</p>\r\n<h3 id=\"h3-pull\"><a name=\"pull\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>pull</h3><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>\r\n<p>拉取服务依赖的镜像。</p>\r\n<p>选项：</p>\r\n<p><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</p>\r\n<h3 id=\"h3-push\"><a name=\"push\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>push</h3><p>推送服务依赖的镜像到 Docker 镜像仓库。</p>\r\n<h3 id=\"h3-restart\"><a name=\"restart\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>restart</h3><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\r\n<p>重启项目中的服务。</p>\r\n<p>选项：</p>\r\n<p><code>-t, --timeout TIMEOUT</code>指定重启前停止容器的超时（默认为 10 秒）。</p>\r\n<h3 id=\"h3-rm\"><a name=\"rm\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>rm</h3><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\r\n<p>删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</p>\r\n<p>选项：</p>\r\n<p><code>-f, --force</code>强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。<br><code>-v</code>删除容器所挂载的数据卷。</p>\r\n<h3 id=\"h3-run\"><a name=\"run\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>run</h3><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>\r\n<p>在指定服务上执行一个命令。</p>\r\n<p>例如：</p>\r\n<p><code>$ docker-compose run ubuntu ping docker.com</code><br>将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。\r\n<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>\r\n<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>\r\n<p>两个不同点：</p>\r\n<p>给定命令将会覆盖原有的自动运行命令；<br>不会自动创建端口，以避免冲突。<br>如果不希望自动启动关联的容器，可以使用 —no-deps 选项，例如\r\n<p><code>$ docker-compose run --no-deps web python manage.py shell</code><br>将不会启动 web 容器所关联的其它容器。\r\n<p>选项：</p>\r\n<p><code>-d</code> 后台运行容器。<br><code>--name NAME</code>为容器指定一个名字。<br><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。<br><code>-e KEY=VAL</code>设置环境变量值，可多次使用选项来设置多个环境变量。<br><code>-u, --user=\"\"</code> 指定运行容器的用户名或者 uid。<br><code>--no-deps</code> 不自动启动关联的服务容器。<br><code>--rm</code>运行命令后自动删除容器，d 模式下将忽略。<br><code>-p, --publish=[]</code>映射容器端口到本地主机。<br><code>--service-ports</code>配置服务端口并映射到本地主机。<br><code>-T</code>不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p>\r\n<h3 id=\"h3-scale\"><a name=\"scale\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>scale</h3><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>\r\n<p>设置指定服务运行的容器个数。</p>\r\n<p>通过 service=num 的参数来设置数量。例如：</p>\r\n<p><code>$ docker-compose scale web=3 db=2</code><br>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。\r\n<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>\r\n<p>选项：</p>\r\n<p><code>-t, --timeout TIMEOUT</code>停止容器时候的超时（默认为 10 秒）。</p>\r\n<h3 id=\"h3-start\"><a name=\"start\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>start</h3><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\r\n<p>启动已经存在的服务容器。</p>\r\n<h3 id=\"h3-stop\"><a name=\"stop\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>stop</h3><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\r\n<p>停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p>\r\n<p>选项：</p>\r\n<p><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</p>\r\n<h3 id=\"h3-top\"><a name=\"top\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>top</h3><p>查看各个服务容器内运行的进程。</p>\r\n<h3 id=\"h3-unpause\"><a name=\"unpause\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>unpause</h3><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\r\n<p>恢复处于暂停状态中的服务。</p>\r\n<h3 id=\"h3-up\"><a name=\"up\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>up</h3><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\r\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\r\n<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\r\n<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\r\n<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\r\n<p>当通过 <code>Ctrl-C</code>停止命令时，所有容器将会停止。</p>\r\n<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\r\n<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code>来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>\r\n<p>选项：</p>\r\n<p><code>-d</code>在后台运行服务容器。<br><code>--no-color</code>不使用颜色来区分不同的服务的控制台输出。<br><code>--no-deps</code>不启动服务所链接的容器。<br><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。<br><code>--no-recreate</code>如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。<br><code>--no-build</code>不自动构建缺失的服务镜像。<br><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</p>\r\n<h3 id=\"h3-version\"><a name=\"version\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>version</h3><p>格式为 <code>docker-compose version</code>。</p>\r\n<p>打印版本信息。</p>\r\n', null, null, null, '2020-10-19 21:33:37', '2020-10-19 21:33:37', '1');
INSERT INTO `articles` VALUES ('66', '1', 'Docker Compose 实战 MySQL', '', '### MySQL5\r\n\r\n\r\n    version: \'3.1\'\r\n    services:\r\n      mysql:\r\n        restart: always\r\n        image: mysql:5.7.22\r\n        container_name: mysql\r\n        ports:\r\n          - 3306:3306\r\n        environment:\r\n          TZ: Asia/Shanghai\r\n          MYSQL_ROOT_PASSWORD: 123456\r\n        command:\r\n          --character-set-server=utf8mb4\r\n          --collation-server=utf8mb4_general_ci\r\n          --explicit_defaults_for_timestamp=true\r\n          --lower_case_table_names=1\r\n          --max_allowed_packet=128M\r\n          --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\r\n        volumes:\r\n          - mysql-data:/var/lib/mysql\r\n    \r\n    volumes:\r\n      mysql-data:\r\n###MySQL8\r\n\r\n\r\n    version: \'3.1\'\r\n    services:\r\n      db:\r\n        image: mysql\r\n        restart: always\r\n        environment:\r\n          MYSQL_ROOT_PASSWORD: 123456\r\n        command:\r\n          --default-authentication-plugin=mysql_native_password\r\n          --character-set-server=utf8mb4\r\n          --collation-server=utf8mb4_general_ci\r\n          --explicit_defaults_for_timestamp=true\r\n          --lower_case_table_names=1\r\n        ports:\r\n          - 3306:3306\r\n        volumes:\r\n          - ./data:/var/lib/mysql\r\n    \r\n      adminer:\r\n        image: adminer\r\n        restart: always\r\n        ports:\r\n          - 8080:8080', '<h3 id=\"h3-mysql5\"><a name=\"MySQL5\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MySQL5</h3><pre><code>version: \'3.1\'\r\nservices:\r\n  mysql:\r\n    restart: always\r\n    image: mysql:5.7.22\r\n    container_name: mysql\r\n    ports:\r\n      - 3306:3306\r\n    environment:\r\n      TZ: Asia/Shanghai\r\n      MYSQL_ROOT_PASSWORD: 123456\r\n    command:\r\n      --character-set-server=utf8mb4\r\n      --collation-server=utf8mb4_general_ci\r\n      --explicit_defaults_for_timestamp=true\r\n      --lower_case_table_names=1\r\n      --max_allowed_packet=128M\r\n      --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\r\n    volumes:\r\n      - mysql-data:/var/lib/mysql\r\n\r\nvolumes:\r\n  mysql-data:\r\n</code></pre><h3 id=\"h3-mysql8\"><a name=\"MySQL8\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MySQL8</h3><pre><code>version: \'3.1\'\r\nservices:\r\n  db:\r\n    image: mysql\r\n    restart: always\r\n    environment:\r\n      MYSQL_ROOT_PASSWORD: 123456\r\n    command:\r\n      --default-authentication-plugin=mysql_native_password\r\n      --character-set-server=utf8mb4\r\n      --collation-server=utf8mb4_general_ci\r\n      --explicit_defaults_for_timestamp=true\r\n      --lower_case_table_names=1\r\n    ports:\r\n      - 3306:3306\r\n    volumes:\r\n      - ./data:/var/lib/mysql\r\n\r\n  adminer:\r\n    image: adminer\r\n    restart: always\r\n    ports:\r\n      - 8080:8080\r\n</code></pre>', null, null, null, '2020-10-19 21:34:46', '2020-10-19 21:34:46', '1');
INSERT INTO `articles` VALUES ('67', '1', 'Docker Compose 常用命令 ', '', '### 前台运行\r\n`docker-compose up`\r\n###后台运行\r\n`docker-compose up -d`\r\n###启动\r\n`docker-compose start`\r\n###停止\r\n`docker-compose stop`\r\n###停止并移除容器\r\n`docker-compose down`', '<h3 id=\"h3-u524Du53F0u8FD0u884C\"><a name=\"前台运行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前台运行</h3><p><code>docker-compose up</code></p>\r\n<h3 id=\"h3-u540Eu53F0u8FD0u884C\"><a name=\"后台运行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>后台运行</h3><p><code>docker-compose up -d</code></p>\r\n<h3 id=\"h3-u542Fu52A8\"><a name=\"启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动</h3><p><code>docker-compose start</code></p>\r\n<h3 id=\"h3-u505Cu6B62\"><a name=\"停止\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止</h3><p><code>docker-compose stop</code></p>\r\n<h3 id=\"h3-u505Cu6B62u5E76u79FBu9664u5BB9u5668\"><a name=\"停止并移除容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止并移除容器</h3><p><code>docker-compose down</code></p>\r\n', null, null, null, '2020-10-19 21:35:54', '2020-10-19 21:35:54', '1');
INSERT INTO `articles` VALUES ('68', '1', 'Docker-compose部署Springboot+Mysql', '', '> Jar包镜像的制作\r\n下面的项目会有一点点问题，就是docker-compose文件对不上，请参照下面的进行修改。此外，application.yml也必须进行相应的更改，需要更改的是数据库的username。\r\n\r\n### 创建并编辑Dockerfile文件\r\n`touch Dockerfile && vim Dockerfile`\r\n内容：\r\n    FROM java:8\r\n      \r\n    VOLUME /vol/development\r\n     \r\n    RUN mkdir -p /vol/development\r\n     \r\n    WORKDIR /vol/development\r\n     \r\n    COPY test.jar /vol/development/app.jar\r\n     \r\n    CMD [\"java\", \"-Xmx200m\", \"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/vol/development/app.jar\"]\r\n### docker-compose.yml的创建\r\n创建docker-compose.yml文件： `touch docker-compose.yml`\r\n\r\n    version : \'3\'\r\n    services:\r\n      mysql:\r\n        restart: always\r\n        image: mysql:5.7.22\r\n        container_name: mysql\r\n        ports:\r\n          - 3306:3306\r\n        environment:\r\n          TZ: Asia/Shanghai\r\n          MYSQL_DATABASE: myblog\r\n          MYSQL_ROOT_PASSWORD: sunyue\r\n        command:\r\n          --character-set-server=utf8mb4\r\n          --collation-server=utf8mb4_general_ci\r\n          --explicit_defaults_for_timestamp=true\r\n          --lower_case_table_names=1\r\n          --max_allowed_packet=128M\r\n          --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\r\n        volumes:\r\n          - /var/lib/mysql\r\n    \r\n      springappserver:\r\n        container_name: springappserver\r\n        build:\r\n          context: .\r\n          dockerfile: Dockerfile\r\n        ports:\r\n          - \"8080:8080\"\r\n        volumes:\r\n          - /vol/development\r\n        depends_on:\r\n          - mysql\r\n        links:\r\n          - mysql\r\n### 运行\r\n`docker-compose up`启动', '<blockquote>\r\n<p>Jar包镜像的制作<br>下面的项目会有一点点问题，就是docker-compose文件对不上，请参照下面的进行修改。此外，application.yml也必须进行相应的更改，需要更改的是数据库的username。\r\n</blockquote>\r\n<h3 id=\"h3--dockerfile-\"><a name=\"创建并编辑Dockerfile文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建并编辑Dockerfile文件</h3><p><code>touch Dockerfile &amp;&amp; vim Dockerfile</code><br>内容：<br>    FROM java:8\r\n<pre><code>VOLUME /vol/development\r\n\r\nRUN mkdir -p /vol/development\r\n\r\nWORKDIR /vol/development\r\n\r\nCOPY test.jar /vol/development/app.jar\r\n\r\nCMD [\"java\", \"-Xmx200m\", \"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/vol/development/app.jar\"]\r\n</code></pre><h3 id=\"h3-docker-compose-yml-\"><a name=\"docker-compose.yml的创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>docker-compose.yml的创建</h3><p>创建docker-compose.yml文件： <code>touch docker-compose.yml</code></p>\r\n<pre><code>version : \'3\'\r\nservices:\r\n  mysql:\r\n    restart: always\r\n    image: mysql:5.7.22\r\n    container_name: mysql\r\n    ports:\r\n      - 3306:3306\r\n    environment:\r\n      TZ: Asia/Shanghai\r\n      MYSQL_DATABASE: myblog\r\n      MYSQL_ROOT_PASSWORD: sunyue\r\n    command:\r\n      --character-set-server=utf8mb4\r\n      --collation-server=utf8mb4_general_ci\r\n      --explicit_defaults_for_timestamp=true\r\n      --lower_case_table_names=1\r\n      --max_allowed_packet=128M\r\n      --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\r\n    volumes:\r\n      - /var/lib/mysql\r\n\r\n  springappserver:\r\n    container_name: springappserver\r\n    build:\r\n      context: .\r\n      dockerfile: Dockerfile\r\n    ports:\r\n      - \"8080:8080\"\r\n    volumes:\r\n      - /vol/development\r\n    depends_on:\r\n      - mysql\r\n    links:\r\n      - mysql\r\n</code></pre><h3 id=\"h3-u8FD0u884C\"><a name=\"运行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行</h3><p><code>docker-compose up</code>启动</p>\r\n', null, null, null, '2020-10-19 21:42:44', '2020-10-19 21:58:24', '1');
INSERT INTO `articles` VALUES ('69', '1', 'Spring boot 上传图片、删除图片、压缩图片', '', '### 1.创建一个springboot项目\r\nmaven如下：\r\n\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n        <modelVersion>4.0.0</modelVersion>\r\n    \r\n        <groupId>com.sunyue</groupId>\r\n        <artifactId>my_blog</artifactId>\r\n        <version>0.0.1-SNAPSHOT</version>\r\n        <packaging>jar</packaging>\r\n    \r\n        <name>my_blog</name>\r\n        <description></description>\r\n    \r\n        <parent>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-parent</artifactId>\r\n            <version>2.0.2.RELEASE</version>\r\n            <relativePath></relativePath> <!-- lookup parent from repository -->\r\n        </parent>\r\n    \r\n        <properties>\r\n            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n            <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\r\n            <java.version>1.8</java.version>\r\n        </properties>\r\n    \r\n        <dependencies>\r\n            <!--文件压缩-->\r\n            <dependency>\r\n                <groupId>net.coobird</groupId>\r\n                <artifactId>thumbnailator</artifactId>\r\n                <version>0.4.8</version>\r\n            </dependency>\r\n            <!--markdown-->\r\n            <dependency>\r\n                <groupId>com.vladsch.flexmark</groupId>\r\n                <artifactId>flexmark-all</artifactId>\r\n                <version>0.50.42</version>\r\n            </dependency>\r\n    \r\n            <dependency>\r\n                <groupId>commons-io</groupId>\r\n                <artifactId>commons-io</artifactId>\r\n                <version>2.5</version>\r\n            </dependency>\r\n    \r\n    \r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-web</artifactId>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-tomcat</artifactId>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n            </dependency>\r\n            <!--热部署插件-->\r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-devtools</artifactId>\r\n                <optional>true</optional>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-actuator</artifactId>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-test</artifactId>\r\n                <scope>test</scope>\r\n            </dependency>\r\n    \r\n            <dependency>\r\n                <groupId>com.alibaba</groupId>\r\n                <artifactId>druid-spring-boot-starter</artifactId>\r\n                <version>1.1.10</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>tk.mybatis</groupId>\r\n                <artifactId>mapper-spring-boot-starter</artifactId>\r\n                <version>2.0.2</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>com.github.pagehelper</groupId>\r\n                <artifactId>pagehelper-spring-boot-starter</artifactId>\r\n                <version>1.2.5</version>\r\n            </dependency>\r\n    \r\n            <dependency>\r\n                <groupId>net.sourceforge.nekohtml</groupId>\r\n                <artifactId>nekohtml</artifactId>\r\n                <version>1.9.22</version>\r\n            </dependency>\r\n            <dependency>\r\n                <groupId>mysql</groupId>\r\n                <artifactId>mysql-connector-java</artifactId>\r\n                <scope>runtime</scope>\r\n            </dependency>\r\n            <!-- https://mvnrepository.com/artifact/com.alibaba/fastjson -->\r\n            <dependency>\r\n                <groupId>com.alibaba</groupId>\r\n                <artifactId>fastjson</artifactId>\r\n                <version>1.2.62</version>\r\n            </dependency>\r\n    \r\n            <!--upload-->\r\n    \r\n        </dependencies>\r\n    \r\n        <build>\r\n            <plugins>\r\n                <plugin>\r\n                    <groupId>org.springframework.boot</groupId>\r\n                    <artifactId>spring-boot-maven-plugin</artifactId>\r\n                    <configuration>\r\n                        <mainClass>com.sunyue.myblog.MyblogApplication</mainClass>\r\n                    </configuration>\r\n                </plugin>\r\n    \r\n                <plugin>\r\n                    <groupId>org.mybatis.generator</groupId>\r\n                    <artifactId>mybatis-generator-maven-plugin</artifactId>\r\n                    <version>1.3.5</version>\r\n                    <configuration>\r\n                        <configurationFile>${basedir}/src/main/resources/generator/generatorConfig.xml</configurationFile>\r\n                        <overwrite>true</overwrite>\r\n                        <verbose>true</verbose>\r\n                    </configuration>\r\n                    <dependencies>\r\n                        <dependency>\r\n                            <groupId>mysql</groupId>\r\n                            <artifactId>mysql-connector-java</artifactId>\r\n                            <version>${mysql.version}</version>\r\n                        </dependency>\r\n                        <dependency>\r\n                            <groupId>tk.mybatis</groupId>\r\n                            <artifactId>mapper</artifactId>\r\n                            <version>3.4.4</version>\r\n                        </dependency>\r\n                    </dependencies>\r\n                </plugin>\r\n            </plugins>\r\n        </build>\r\n    \r\n    </project>\r\n\r\n\r\n### 2.创建一个控制层FileController\r\n```java\r\npackage com.sunyue.myblog.controller;\r\n\r\nimport com.sunyue.myblog.commons.EmptyUtil;\r\nimport net.coobird.thumbnailator.Thumbnails;\r\nimport org.apache.catalina.servlet4preview.http.HttpServletRequest;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.*;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 文件上传\r\n */\r\n@CrossOrigin\r\n@Controller\r\npublic class FileController {\r\n    /*Windows文件保存路径*/\r\n    private static String UPLOADED_FOLDER = \"src/main/resources/static/upload/\";\r\n    /*Linux文件保存路径*/\r\n    private static String UPLOADED_FOLDER = \"upload/\";\r\n\r\n    @GetMapping(value = \"/file\")\r\n    public String file() {\r\n        return \"fileup\";\r\n    }\r\n\r\n    /*删除文件*/\r\n    private Map<String, Object> deleteFileUtil(String params) {\r\n        /*进来的是一个../images/5770871d-3e20-4f62-804e-f17f0ac0d562.jpg虚拟地址，对应实际地址需要截取处理*/\r\n        params = params.substring(params.lastIndexOf(\"/\") + 1);\r\n        Map<String, Object> map = new HashMap<String, Object>();\r\n        String url = UPLOADED_FOLDER + params;\r\n        File file = new File(url);\r\n        /*获取文件完整路径包括文件名*/\r\n        String path = file.getAbsolutePath();\r\n        File filedel = new File(path);\r\n        if (!filedel.exists()) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"路径不正确！\");\r\n        } else {\r\n            map.put(\"success\", 1);\r\n            map.put(\"message\", \"删除成功！\");\r\n            filedel.delete();\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /*上传文件*/\r\n    private Map<String, Object> uploadFileUtil(MultipartFile file) {\r\n        /*返回文件上传状态码*/\r\n        Map<String, Object> map = new HashMap<String, Object>();\r\n        if (file.isEmpty()) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"文件不存在\");\r\n            return map;\r\n        }\r\n        String fileName = file.getOriginalFilename();  // 文件名\r\n        String suffixName = fileName.substring(fileName.lastIndexOf(\".\"));  // 后缀名\r\n        File fileDir = new File(UPLOADED_FOLDER);\r\n        fileName = UUID.randomUUID() + suffixName; // 新文件名\r\n        String path = fileDir.getAbsolutePath();\r\n        if (!fileDir.exists()) {\r\n            fileDir.mkdir();//新建文件夹\r\n        }\r\n        try {\r\n            try {\r\n                /*先尝试压缩并保存图片*/\r\n                Thumbnails.of(file.getInputStream()).scale(0.5f)\r\n                        .outputQuality(0.15f)\r\n                        .outputFormat(\"jpeg\")\r\n                        .toFile(path+\"/\"+fileName);\r\n            } catch (IOException e) {\r\n\r\n            }\r\n            /*直接保存*/\r\n            //file.transferTo(new File(path, fileName));\r\n            map.put(\"success\", 1);\r\n            map.put(\"message\", \"上传成功！\");\r\n            /*为了能访问，返回文件映射虚拟地址*/\r\n            map.put(\"url\", \"../images/\" + fileName);\r\n            /*这样也可以*/\r\n            //map.put(\"url\", \"/images/\" + fileName);\r\n        } catch (Exception e) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"上传失败！\");\r\n            e.printStackTrace();\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /*上传文件按钮，返回json*/\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/fileUpload\", method = RequestMethod.POST)\r\n    public Map<String, Object> FileUpload(@RequestParam(\"file\") MultipartFile file) {\r\n        return uploadFileUtil(file);\r\n    }\r\n\r\n    /*更新图片，顺便将原来的图片删除*/\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/fileUpdate\", method = RequestMethod.POST)\r\n    public Map<String, Object> FileUpload1(@RequestParam(\"file\") MultipartFile file, @RequestParam String params) {\r\n        Map map = new HashMap<String, Object>();\r\n        /*如上截取文件路径*/\r\n        params = params.substring(params.lastIndexOf(\"/\") + 1);\r\n        if (EmptyUtil.isEmpty(params)) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"路径为空！\");\r\n        } else {\r\n            /*先删除*/\r\n            map = deleteFileUtil(params);\r\n        }\r\n        /*再保存*/\r\n        map = uploadFileUtil(file);\r\n        return map;\r\n    }\r\n\r\n    /*文件删除/取消按钮*/\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/fileDelete\", method = RequestMethod.POST)\r\n    public Object FileDelete(HttpServletRequest request) {\r\n        String params = request.getParameter(\"params\");\r\n        Map map = new HashMap<String, Object>();\r\n        if (EmptyUtil.isEmpty(params)) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"路径为空！\");\r\n        }\r\n        /*删除文件*/\r\n        map = deleteFileUtil(params);\r\n        return map;\r\n    }\r\n\r\n\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/markdown\", method = RequestMethod.POST)\r\n    public Map<String, Object> demo(@RequestParam(value = \"editormd-image-file\", required = false) MultipartFile file, HttpServletRequest request) {\r\n        return uploadFileUtil(file);\r\n\r\n    }\r\n}\r\n\r\n```\r\n### 3.创建MyWebAppConfigurer 这里是配置资源映射路径\r\n```java\r\npackage com.sunyue.myblog;\r\n\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.config.annotation.*;\r\n\r\n/**\r\n * 资源映射路径\r\n */\r\n@Configuration\r\npublic class MyWebAppConfigurer implements WebMvcConfigurer {\r\n\r\n    // 获取配置文件中图片的路径\r\n    @Value(\"${cbs.imagesPath}\")\r\n    private String mImagesPath;\r\n\r\n\r\n    // 访问图片方法\r\n    @Override\r\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n    //windows上的写法\r\n        if (mImagesPath.equals(\"\") || mImagesPath.equals(\"${cbs.imagesPath}\")) {\r\n            String imagesPath = MyWebAppConfigurer.class.getClassLoader().getResource(\"\").getPath();\r\n            if (imagesPath.indexOf(\".jar\") > 0) {\r\n                imagesPath = imagesPath.substring(0, imagesPath.indexOf(\".jar\"));\r\n            } else if (imagesPath.indexOf(\"classes\") > 0) {\r\n                imagesPath = \"file:\" + imagesPath.substring(0, imagesPath.indexOf(\"classes\"));\r\n            }\r\n            imagesPath = imagesPath.substring(0, imagesPath.lastIndexOf(\"/\")) + \"/images/\";\r\n            mImagesPath = imagesPath;\r\n        }\r\n        LoggerFactory.getLogger(MyWebAppConfigurer.class).info(\"imagesPath=\" + mImagesPath);\r\n        registry.addResourceHandler(\"/images/**\").addResourceLocations(mImagesPath);\r\n        WebMvcConfigurer.super.addResourceHandlers(registry);\r\n    }\r\n    //服务器上的写法\r\n        LoggerFactory.getLogger(MyWebAppConfigurer.class).info(\"imagesPath=\" + mImagesPath);\r\n        //registry.addResourceHandler(\"/images/**\").addResourceLocations(mImagesPath);\r\n        registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:\" + mImagesPath);\r\n        WebMvcConfigurer.super.addResourceHandlers(registry);\r\n}\r\n```\r\n\r\n### 4.前端模板文件\r\n```html\r\n                                    <div class=\"am-form-group\">\r\n                                        <label for=\"userPhoto\" class=\"am-u-sm-12 am-form-label  am-text-left\">用户头像\r\n                                            <span class=\"tpl-form-line-small-title\">Images</span></label>\r\n                                        <div class=\"am-u-sm-12 am-margin-top-xs\">\r\n                                            <input type=\"file\" id=\"file\" name=\"file\" style=\"color: #ff5b67\">\r\n                                            <input style=\"margin: 10px 0\" type=\"button\" id=\"upload\" value=\"上传\"   class=\"am-btn-secondary\">\r\n                                            <input style=\"margin: 10px 2px\" type=\"button\" id=\"cancel\" value=\"取消\" class=\"am-btn-danger\">\r\n                                            <div class=\"am-form-group am-form-file\">\r\n                                                <input type=\"text\" id=\"userPhoto\" name=\"userPhoto\"\r\n                                                       th:value=\"${user.userPhoto}\"\r\n                                                       class=\"tpl-form-input am-margin-top-xs\" placeholder=\"图片地址\"\r\n                                                       readonly=\"readonly\">\r\n                                            </div>\r\n                                        </div>\r\n                                    </div>\r\n\r\n\r\n```\r\n### 5.js：\r\n```javascript\r\n<script type=\"text/javascript\">\r\n    $(function () {\r\n        /*上传文件*/\r\n        $(\"#upload\").click(function () {\r\n            var form = new FormData();\r\n            form.append(\"file\", document.getElementById(\"file\").files[0]);\r\n            $.ajax({\r\n                url: \"/fileUpload\",        //后台url\r\n                data: form,\r\n                cache: false,\r\n                async: false,\r\n                type: \"POST\",                   //类型，POST或者GET\r\n                dataType: \"json\",              //数据返回类型，可以是xml、json等\r\n                processData: false,\r\n                contentType: false,\r\n                enctype: \'multipart/form-data\',\r\n                success: function (data) {      //成功，回调函数\r\n                    if (data.success == 1) {\r\n                        $(\"#url img\").attr(\"src\", data.url);\r\n                        $(\"#userPhoto\").val(data.url);\r\n                        $(\"#url1\").html(data.url);\r\n                        alert(\"图片上传成功！\")\r\n\r\n                    } else {\r\n                        alert(\"上传失败\");\r\n                    }\r\n\r\n                },\r\n                error: function (er) {\r\n                    alert(er);//失败，回调函数\r\n                }\r\n            });\r\n        });\r\n        /*取消上传文件*/\r\n        $(\"#cancel\").click(function () {\r\n            var params = $(\"#userPhoto\").val();\r\n            $.ajax({\r\n                url: \"/fileDelete/?params=\" + params,\r\n                type: \"POST\",\r\n                contentType: \"application/json\",//一定要加的属性\r\n                dataType: \"json\",\r\n                success: function (data) {\r\n                    //data是服务器返回的数据\r\n                    if (data.success == 1) {\r\n                        $(\"#userPhoto\").val(\"\");\r\n                    }\r\n                    alert(data.message);\r\n                },\r\n                error: function (e) {\r\n                    alert(e);//异常信息\r\n                }\r\n            });\r\n        });\r\n    });\r\n\r\n</script>\r\n```\r\n\r\n### 6.配置文件application.properties：\r\n\r\n\r\n\r\n    #是否启用文件上传功能\r\n    spring.servlet.multipart.enabled=true\r\n    #指定文件写入磁盘后的阈值，默认为0\r\n    spring.servlet.multipart.file-size-threshold=0\r\n    #指定上传文件大小， 默认1M\r\n    spring.servlet.multipart.max-file-size=50Mb\r\n    #指定multipart / form-data请求允许的最大大小， 默认10M\r\n    spring.servlet.multipart.max-request-size=100Mb\r\n    #是否在文件或参数访问时懒惰地解析多部分请求\r\n    spring.servlet.multipart.resolve-lazily=false\r\n    \r\n    #项目相对目录:classpath:\r\n    #本地绝对目录:file: 表示window的路径是以下\r\n    cbs.imagesPath=file:F:/test/myblog/src/main/resources/static/upload/\r\n    #服务器上绝对目录:file: 表示Linux的路径是以下\r\n    cbs.imagesPath=/home/ubuntu/sunyue/web/upload/\r\n    \r\n    #以下相对路径暂未成功\r\n    #cbs.imagesPath=classpath:myblog/src/main/resources/static/upload/\r\n\r\n\r\n\r\n\r\n', '<h3 id=\"h3-1-springboot-\"><a name=\"1.创建一个springboot项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.创建一个springboot项目</h3><p>maven如下：</p>\r\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\r\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\r\n\r\n    &lt;groupId&gt;com.sunyue&lt;/groupId&gt;\r\n    &lt;artifactId&gt;my_blog&lt;/artifactId&gt;\r\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\r\n    &lt;packaging&gt;jar&lt;/packaging&gt;\r\n\r\n    &lt;name&gt;my_blog&lt;/name&gt;\r\n    &lt;description&gt;&lt;/description&gt;\r\n\r\n    &lt;parent&gt;\r\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\r\n        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;\r\n        &lt;relativePath&gt;&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt;\r\n    &lt;/parent&gt;\r\n\r\n    &lt;properties&gt;\r\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\r\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\r\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\r\n    &lt;/properties&gt;\r\n\r\n    &lt;dependencies&gt;\r\n        &lt;!--文件压缩--&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;net.coobird&lt;/groupId&gt;\r\n            &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt;\r\n            &lt;version&gt;0.4.8&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;!--markdown--&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.vladsch.flexmark&lt;/groupId&gt;\r\n            &lt;artifactId&gt;flexmark-all&lt;/artifactId&gt;\r\n            &lt;version&gt;0.50.42&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;commons-io&lt;/groupId&gt;\r\n            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\r\n            &lt;version&gt;2.5&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;!--热部署插件--&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\r\n            &lt;optional&gt;true&lt;/optional&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\r\n            &lt;scope&gt;test&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\r\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;1.1.10&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;2.0.2&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\r\n            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;1.2.5&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;\r\n            &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;\r\n            &lt;version&gt;1.9.22&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\r\n            &lt;scope&gt;runtime&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\r\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\r\n            &lt;version&gt;1.2.62&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;!--upload--&gt;\r\n\r\n    &lt;/dependencies&gt;\r\n\r\n    &lt;build&gt;\r\n        &lt;plugins&gt;\r\n            &lt;plugin&gt;\r\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\r\n                &lt;configuration&gt;\r\n                    &lt;mainClass&gt;com.sunyue.myblog.MyblogApplication&lt;/mainClass&gt;\r\n                &lt;/configuration&gt;\r\n            &lt;/plugin&gt;\r\n\r\n            &lt;plugin&gt;\r\n                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\r\n                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;\r\n                &lt;version&gt;1.3.5&lt;/version&gt;\r\n                &lt;configuration&gt;\r\n                    &lt;configurationFile&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt;\r\n                    &lt;overwrite&gt;true&lt;/overwrite&gt;\r\n                    &lt;verbose&gt;true&lt;/verbose&gt;\r\n                &lt;/configuration&gt;\r\n                &lt;dependencies&gt;\r\n                    &lt;dependency&gt;\r\n                        &lt;groupId&gt;mysql&lt;/groupId&gt;\r\n                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\r\n                        &lt;version&gt;${mysql.version}&lt;/version&gt;\r\n                    &lt;/dependency&gt;\r\n                    &lt;dependency&gt;\r\n                        &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;\r\n                        &lt;artifactId&gt;mapper&lt;/artifactId&gt;\r\n                        &lt;version&gt;3.4.4&lt;/version&gt;\r\n                    &lt;/dependency&gt;\r\n                &lt;/dependencies&gt;\r\n            &lt;/plugin&gt;\r\n        &lt;/plugins&gt;\r\n    &lt;/build&gt;\r\n\r\n&lt;/project&gt;\r\n</code></pre><h3 id=\"h3-2-filecontroller\"><a name=\"2.创建一个控制层FileController\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.创建一个控制层FileController</h3><pre><code class=\"lang-java\">package com.sunyue.myblog.controller;\r\n\r\nimport com.sunyue.myblog.commons.EmptyUtil;\r\nimport net.coobird.thumbnailator.Thumbnails;\r\nimport org.apache.catalina.servlet4preview.http.HttpServletRequest;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.*;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 文件上传\r\n */\r\n@CrossOrigin\r\n@Controller\r\npublic class FileController {\r\n    /*Windows文件保存路径*/\r\n    private static String UPLOADED_FOLDER = \"src/main/resources/static/upload/\";\r\n    /*Linux文件保存路径*/\r\n    private static String UPLOADED_FOLDER = \"upload/\";\r\n\r\n    @GetMapping(value = \"/file\")\r\n    public String file() {\r\n        return \"fileup\";\r\n    }\r\n\r\n    /*删除文件*/\r\n    private Map&lt;String, Object&gt; deleteFileUtil(String params) {\r\n        /*进来的是一个../images/5770871d-3e20-4f62-804e-f17f0ac0d562.jpg虚拟地址，对应实际地址需要截取处理*/\r\n        params = params.substring(params.lastIndexOf(\"/\") + 1);\r\n        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\r\n        String url = UPLOADED_FOLDER + params;\r\n        File file = new File(url);\r\n        /*获取文件完整路径包括文件名*/\r\n        String path = file.getAbsolutePath();\r\n        File filedel = new File(path);\r\n        if (!filedel.exists()) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"路径不正确！\");\r\n        } else {\r\n            map.put(\"success\", 1);\r\n            map.put(\"message\", \"删除成功！\");\r\n            filedel.delete();\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /*上传文件*/\r\n    private Map&lt;String, Object&gt; uploadFileUtil(MultipartFile file) {\r\n        /*返回文件上传状态码*/\r\n        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\r\n        if (file.isEmpty()) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"文件不存在\");\r\n            return map;\r\n        }\r\n        String fileName = file.getOriginalFilename();  // 文件名\r\n        String suffixName = fileName.substring(fileName.lastIndexOf(\".\"));  // 后缀名\r\n        File fileDir = new File(UPLOADED_FOLDER);\r\n        fileName = UUID.randomUUID() + suffixName; // 新文件名\r\n        String path = fileDir.getAbsolutePath();\r\n        if (!fileDir.exists()) {\r\n            fileDir.mkdir();//新建文件夹\r\n        }\r\n        try {\r\n            try {\r\n                /*先尝试压缩并保存图片*/\r\n                Thumbnails.of(file.getInputStream()).scale(0.5f)\r\n                        .outputQuality(0.15f)\r\n                        .outputFormat(\"jpeg\")\r\n                        .toFile(path+\"/\"+fileName);\r\n            } catch (IOException e) {\r\n\r\n            }\r\n            /*直接保存*/\r\n            //file.transferTo(new File(path, fileName));\r\n            map.put(\"success\", 1);\r\n            map.put(\"message\", \"上传成功！\");\r\n            /*为了能访问，返回文件映射虚拟地址*/\r\n            map.put(\"url\", \"../images/\" + fileName);\r\n            /*这样也可以*/\r\n            //map.put(\"url\", \"/images/\" + fileName);\r\n        } catch (Exception e) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"上传失败！\");\r\n            e.printStackTrace();\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /*上传文件按钮，返回json*/\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/fileUpload\", method = RequestMethod.POST)\r\n    public Map&lt;String, Object&gt; FileUpload(@RequestParam(\"file\") MultipartFile file) {\r\n        return uploadFileUtil(file);\r\n    }\r\n\r\n    /*更新图片，顺便将原来的图片删除*/\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/fileUpdate\", method = RequestMethod.POST)\r\n    public Map&lt;String, Object&gt; FileUpload1(@RequestParam(\"file\") MultipartFile file, @RequestParam String params) {\r\n        Map map = new HashMap&lt;String, Object&gt;();\r\n        /*如上截取文件路径*/\r\n        params = params.substring(params.lastIndexOf(\"/\") + 1);\r\n        if (EmptyUtil.isEmpty(params)) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"路径为空！\");\r\n        } else {\r\n            /*先删除*/\r\n            map = deleteFileUtil(params);\r\n        }\r\n        /*再保存*/\r\n        map = uploadFileUtil(file);\r\n        return map;\r\n    }\r\n\r\n    /*文件删除/取消按钮*/\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/fileDelete\", method = RequestMethod.POST)\r\n    public Object FileDelete(HttpServletRequest request) {\r\n        String params = request.getParameter(\"params\");\r\n        Map map = new HashMap&lt;String, Object&gt;();\r\n        if (EmptyUtil.isEmpty(params)) {\r\n            map.put(\"success\", 0);\r\n            map.put(\"message\", \"路径为空！\");\r\n        }\r\n        /*删除文件*/\r\n        map = deleteFileUtil(params);\r\n        return map;\r\n    }\r\n\r\n\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/markdown\", method = RequestMethod.POST)\r\n    public Map&lt;String, Object&gt; demo(@RequestParam(value = \"editormd-image-file\", required = false) MultipartFile file, HttpServletRequest request) {\r\n        return uploadFileUtil(file);\r\n\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"h3-3-mywebappconfigurer-\"><a name=\"3.创建MyWebAppConfigurer 这里是配置资源映射路径\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.创建MyWebAppConfigurer 这里是配置资源映射路径</h3><pre><code class=\"lang-java\">package com.sunyue.myblog;\r\n\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.config.annotation.*;\r\n\r\n/**\r\n * 资源映射路径\r\n */\r\n@Configuration\r\npublic class MyWebAppConfigurer implements WebMvcConfigurer {\r\n\r\n    // 获取配置文件中图片的路径\r\n    @Value(\"${cbs.imagesPath}\")\r\n    private String mImagesPath;\r\n\r\n\r\n    // 访问图片方法\r\n    @Override\r\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n    //windows上的写法\r\n        if (mImagesPath.equals(\"\") || mImagesPath.equals(\"${cbs.imagesPath}\")) {\r\n            String imagesPath = MyWebAppConfigurer.class.getClassLoader().getResource(\"\").getPath();\r\n            if (imagesPath.indexOf(\".jar\") &gt; 0) {\r\n                imagesPath = imagesPath.substring(0, imagesPath.indexOf(\".jar\"));\r\n            } else if (imagesPath.indexOf(\"classes\") &gt; 0) {\r\n                imagesPath = \"file:\" + imagesPath.substring(0, imagesPath.indexOf(\"classes\"));\r\n            }\r\n            imagesPath = imagesPath.substring(0, imagesPath.lastIndexOf(\"/\")) + \"/images/\";\r\n            mImagesPath = imagesPath;\r\n        }\r\n        LoggerFactory.getLogger(MyWebAppConfigurer.class).info(\"imagesPath=\" + mImagesPath);\r\n        registry.addResourceHandler(\"/images/**\").addResourceLocations(mImagesPath);\r\n        WebMvcConfigurer.super.addResourceHandlers(registry);\r\n    }\r\n    //服务器上的写法\r\n        LoggerFactory.getLogger(MyWebAppConfigurer.class).info(\"imagesPath=\" + mImagesPath);\r\n        //registry.addResourceHandler(\"/images/**\").addResourceLocations(mImagesPath);\r\n        registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:\" + mImagesPath);\r\n        WebMvcConfigurer.super.addResourceHandlers(registry);\r\n}\r\n</code></pre>\r\n<h3 id=\"h3-4-\"><a name=\"4.前端模板文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.前端模板文件</h3><pre><code class=\"lang-html\">                                    &lt;div class=\"am-form-group\"&gt;\r\n                                        &lt;label for=\"userPhoto\" class=\"am-u-sm-12 am-form-label  am-text-left\"&gt;用户头像\r\n                                            &lt;span class=\"tpl-form-line-small-title\"&gt;Images&lt;/span&gt;&lt;/label&gt;\r\n                                        &lt;div class=\"am-u-sm-12 am-margin-top-xs\"&gt;\r\n                                            &lt;input type=\"file\" id=\"file\" name=\"file\" style=\"color: #ff5b67\"&gt;\r\n                                            &lt;input style=\"margin: 10px 0\" type=\"button\" id=\"upload\" value=\"上传\"   class=\"am-btn-secondary\"&gt;\r\n                                            &lt;input style=\"margin: 10px 2px\" type=\"button\" id=\"cancel\" value=\"取消\" class=\"am-btn-danger\"&gt;\r\n                                            &lt;div class=\"am-form-group am-form-file\"&gt;\r\n                                                &lt;input type=\"text\" id=\"userPhoto\" name=\"userPhoto\"\r\n                                                       th:value=\"${user.userPhoto}\"\r\n                                                       class=\"tpl-form-input am-margin-top-xs\" placeholder=\"图片地址\"\r\n                                                       readonly=\"readonly\"&gt;\r\n                                            &lt;/div&gt;\r\n                                        &lt;/div&gt;\r\n                                    &lt;/div&gt;\r\n</code></pre>\r\n<h3 id=\"h3-5-js-\"><a name=\"5.js：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.js：</h3><pre><code class=\"lang-javascript\">&lt;script type=\"text/javascript\"&gt;\r\n    $(function () {\r\n        /*上传文件*/\r\n        $(\"#upload\").click(function () {\r\n            var form = new FormData();\r\n            form.append(\"file\", document.getElementById(\"file\").files[0]);\r\n            $.ajax({\r\n                url: \"/fileUpload\",        //后台url\r\n                data: form,\r\n                cache: false,\r\n                async: false,\r\n                type: \"POST\",                   //类型，POST或者GET\r\n                dataType: \"json\",              //数据返回类型，可以是xml、json等\r\n                processData: false,\r\n                contentType: false,\r\n                enctype: \'multipart/form-data\',\r\n                success: function (data) {      //成功，回调函数\r\n                    if (data.success == 1) {\r\n                        $(\"#url img\").attr(\"src\", data.url);\r\n                        $(\"#userPhoto\").val(data.url);\r\n                        $(\"#url1\").html(data.url);\r\n                        alert(\"图片上传成功！\")\r\n\r\n                    } else {\r\n                        alert(\"上传失败\");\r\n                    }\r\n\r\n                },\r\n                error: function (er) {\r\n                    alert(er);//失败，回调函数\r\n                }\r\n            });\r\n        });\r\n        /*取消上传文件*/\r\n        $(\"#cancel\").click(function () {\r\n            var params = $(\"#userPhoto\").val();\r\n            $.ajax({\r\n                url: \"/fileDelete/?params=\" + params,\r\n                type: \"POST\",\r\n                contentType: \"application/json\",//一定要加的属性\r\n                dataType: \"json\",\r\n                success: function (data) {\r\n                    //data是服务器返回的数据\r\n                    if (data.success == 1) {\r\n                        $(\"#userPhoto\").val(\"\");\r\n                    }\r\n                    alert(data.message);\r\n                },\r\n                error: function (e) {\r\n                    alert(e);//异常信息\r\n                }\r\n            });\r\n        });\r\n    });\r\n\r\n&lt;/script&gt;\r\n</code></pre>\r\n<h3 id=\"h3-6-application-properties-\"><a name=\"6.配置文件application.properties：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.配置文件application.properties：</h3><pre><code>#是否启用文件上传功能\r\nspring.servlet.multipart.enabled=true\r\n#指定文件写入磁盘后的阈值，默认为0\r\nspring.servlet.multipart.file-size-threshold=0\r\n#指定上传文件大小， 默认1M\r\nspring.servlet.multipart.max-file-size=50Mb\r\n#指定multipart / form-data请求允许的最大大小， 默认10M\r\nspring.servlet.multipart.max-request-size=100Mb\r\n#是否在文件或参数访问时懒惰地解析多部分请求\r\nspring.servlet.multipart.resolve-lazily=false\r\n\r\n#项目相对目录:classpath:\r\n#本地绝对目录:file: 表示window的路径是以下\r\ncbs.imagesPath=file:F:/test/myblog/src/main/resources/static/upload/\r\n#服务器上绝对目录:file: 表示Linux的路径是以下\r\ncbs.imagesPath=/home/ubuntu/sunyue/web/upload/\r\n\r\n#以下相对路径暂未成功\r\n#cbs.imagesPath=classpath:myblog/src/main/resources/static/upload/\r\n</code></pre>', null, null, null, '2020-10-21 22:34:32', '2020-10-21 22:40:22', '1');
INSERT INTO `articles` VALUES ('70', '1', 'Java压缩图片', 'https://www.cnblogs.com/zhao-shan/p/9803640.html', '### 前言\r\n作为靠谱的java服务端程序员，图片这个事情一直是个头疼的事情。\r\n\r\n现在很多网站上，都有上传图片这个功能，而图片对于现在的很多手机来说，拍摄出来的都是高清图片，分辨率也是相当的高，当然占用的存储空间也就大了。问题也就产生了，你每个用户都上传个3M的图片怎么办？\r\n\r\n但是显然现在硬盘的存放空间是不值钱的，1T、2T随便来，存放是能用钱解决的问题。\r\n\r\n但是网速太值钱了，用户如果天天加载你的网页加载个半天，就是因为图片太大导致的那就不是钱能解决的问题了。\r\n\r\n因为用户的网络环境你是不可控制的。所以你只能考虑压缩图片的质量从而保证网站打开的速度。\r\n\r\n### 压缩的要求\r\n图片压缩，在我的想法里面有下面几个要求。\r\n\r\n1、压缩程度可控制，想压缩成多小就多小。\r\n\r\n2、压缩之后图片尽可能的不失真。\r\n\r\n3、压缩速度要快。\r\n\r\n4、代码简单，依赖较少。\r\n\r\n\r\n### 实现\r\n然后带着这些要求去寻找，找到了Thumbnailator，一个google使用的开源的工具类。\r\n\r\n这个工具类满足了上面所说的所有的要求。\r\n\r\n同时对于图片的处理还有了别的方法，如旋转，裁切，加水印等等。\r\n\r\n在github上面的地址是：https://github.com/coobird/thumbnailator\r\n\r\nmaven的地址\r\n\r\n    <dependency>\r\n       <groupId>net.coobird</groupId>\r\n       <artifactId>thumbnailator</artifactId>\r\n       <version>0.4.8</version>\r\n    </dependency>\r\n使用起来特别的简单：一行代码就搞定了\r\n\r\n    Thumbnails.of(\"原图文件的路径\") \r\n            .scale(1f) \r\n            .outputQuality(0.5f) \r\n            .toFile(\"压缩后文件的路径\");//是完整的路径包括文件名\r\n\r\n其中的scale是可以指定图片的大小，值在0到1之间，1f就是原图大小，0.5就是原图的一半大小，这里的大小是指图片的长宽。\r\n\r\n而outputQuality是图片的质量，值也是在0到1，越接近于1质量越好，越接近于0质量越差。\r\n\r\n对于压缩图片来说上面就已经足够了。\r\n\r\n### 优点\r\n1、简单容易使用。\r\n2、压缩图片效果很好。\r\n3、图片质量不错。\r\n### 其他功能\r\n最后附上其他功能使用的简单例子\r\n\r\n```java\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\nimport javax.imageio.ImageIO;\r\n\r\nimport net.coobird.thumbnailator.Thumbnails;\r\nimport net.coobird.thumbnailator.geometry.Positions;\r\n\r\npublic class ThumbnailatorTest {\r\n\r\n    /**\r\n     * \r\n     * @param args\r\n     * @throws IOException\r\n     */\r\n    public static void main(String[] args) throws IOException {\r\n        ThumbnailatorTest thumbnailatorTest = new ThumbnailatorTest();\r\n        thumbnailatorTest.test1();\r\n        thumbnailatorTest.test2();\r\n        thumbnailatorTest.test3();\r\n        thumbnailatorTest.test4();\r\n        thumbnailatorTest.test5();\r\n        thumbnailatorTest.test6();\r\n        thumbnailatorTest.test7();\r\n        thumbnailatorTest.test8();\r\n        thumbnailatorTest.test9();\r\n    }\r\n\r\n    /**\r\n     * 指定大小进行缩放\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test1() throws IOException {\r\n        /*\r\n         * size(width,height) 若图片横比200小，高比300小，不变\r\n         * 若图片横比200小，高比300大，高缩小到300，图片比例不变 若图片横比200大，高比300小，横缩小到200，图片比例不变\r\n         * 若图片横比200大，高比300大，图片按比例缩小，横为200或高为300\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(200, 300).toFile(\"C:/image_200x300.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").size(2560, 2048).toFile(\"C:/image_2560x2048.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 按照比例进行缩放\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test2() throws IOException {\r\n        /**\r\n         * scale(比例)\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").scale(0.25f).toFile(\"C:/image_25%.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").scale(1.10f).toFile(\"C:/image_110%.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 不按照比例，指定大小进行缩放\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test3() throws IOException {\r\n        /**\r\n         * keepAspectRatio(false) 默认是按照比例缩放的\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(120, 120).keepAspectRatio(false).toFile(\"C:/image_120x120.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 旋转\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test4() throws IOException {\r\n        /**\r\n         * rotate(角度),正数：顺时针 负数：逆时针\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).rotate(90).toFile(\"C:/image+90.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).rotate(-90).toFile(\"C:/iamge-90.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 水印\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test5() throws IOException {\r\n        /**\r\n         * watermark(位置，水印图，透明度)\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(\"images/watermark.png\")), 0.5f)\r\n                .outputQuality(0.8f).toFile(\"C:/image_watermark_bottom_right.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).watermark(Positions.CENTER, ImageIO.read(new File(\"images/watermark.png\")), 0.5f)\r\n                .outputQuality(0.8f).toFile(\"C:/image_watermark_center.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 裁剪\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test6() throws IOException {\r\n        /**\r\n         * 图片中心400*400的区域\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").sourceRegion(Positions.CENTER, 400, 400).size(200, 200).keepAspectRatio(false)\r\n                .toFile(\"C:/image_region_center.jpg\");\r\n        /**\r\n         * 图片右下400*400的区域\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").sourceRegion(Positions.BOTTOM_RIGHT, 400, 400).size(200, 200).keepAspectRatio(false)\r\n                .toFile(\"C:/image_region_bootom_right.jpg\");\r\n        /**\r\n         * 指定坐标\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").sourceRegion(600, 500, 400, 400).size(200, 200).keepAspectRatio(false).toFile(\"C:/image_region_coord.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 转化图像格式\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test7() throws IOException {\r\n        /**\r\n         * outputFormat(图像格式)\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).outputFormat(\"png\").toFile(\"C:/image_1280x1024.png\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).outputFormat(\"gif\").toFile(\"C:/image_1280x1024.gif\");\r\n    }\r\n\r\n    /**\r\n     * 输出到OutputStream\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test8() throws IOException {\r\n        /**\r\n         * toOutputStream(流对象)\r\n         */\r\n        OutputStream os = new FileOutputStream(\"C:/image_1280x1024_OutputStream.png\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).toOutputStream(os);\r\n    }\r\n\r\n    /**\r\n     * 输出到BufferedImage\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test9() throws IOException {\r\n        /**\r\n         * asBufferedImage() 返回BufferedImage\r\n         */\r\n        BufferedImage thumbnail = Thumbnails.of(\"images/test.jpg\").size(1280, 1024).asBufferedImage();\r\n        ImageIO.write(thumbnail, \"jpg\", new File(\"C:/image_1280x1024_BufferedImage.jpg\"));\r\n    }\r\n}\r\n```\r\n\r\n其他的具体方法细节可以自己去查看官方的API或者网络上的其他资源。\r\n\r\n\r\n参考博客：\r\n\r\nhttp://blog.csdn.net/wangpeng047/article/details/17610451\r\n\r\nhttp://blog.csdn.net/qiaqia609/article/details/53171149\r\n\r\nhttp://www.cnblogs.com/miskis/p/5500822.html', '<h3 id=\"h3-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h3><p>作为靠谱的java服务端程序员，图片这个事情一直是个头疼的事情。</p>\r\n<p>现在很多网站上，都有上传图片这个功能，而图片对于现在的很多手机来说，拍摄出来的都是高清图片，分辨率也是相当的高，当然占用的存储空间也就大了。问题也就产生了，你每个用户都上传个3M的图片怎么办？</p>\r\n<p>但是显然现在硬盘的存放空间是不值钱的，1T、2T随便来，存放是能用钱解决的问题。</p>\r\n<p>但是网速太值钱了，用户如果天天加载你的网页加载个半天，就是因为图片太大导致的那就不是钱能解决的问题了。</p>\r\n<p>因为用户的网络环境你是不可控制的。所以你只能考虑压缩图片的质量从而保证网站打开的速度。</p>\r\n<h3 id=\"h3-u538Bu7F29u7684u8981u6C42\"><a name=\"压缩的要求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>压缩的要求</h3><p>图片压缩，在我的想法里面有下面几个要求。</p>\r\n<p>1、压缩程度可控制，想压缩成多小就多小。</p>\r\n<p>2、压缩之后图片尽可能的不失真。</p>\r\n<p>3、压缩速度要快。</p>\r\n<p>4、代码简单，依赖较少。</p>\r\n<h3 id=\"h3-u5B9Eu73B0\"><a name=\"实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实现</h3><p>然后带着这些要求去寻找，找到了Thumbnailator，一个google使用的开源的工具类。</p>\r\n<p>这个工具类满足了上面所说的所有的要求。</p>\r\n<p>同时对于图片的处理还有了别的方法，如旋转，裁切，加水印等等。</p>\r\n<p>在github上面的地址是：<a href=\"https://github.com/coobird/thumbnailator\">https://github.com/coobird/thumbnailator</a></p>\r\n<p>maven的地址</p>\r\n<pre><code>&lt;dependency&gt;\r\n   &lt;groupId&gt;net.coobird&lt;/groupId&gt;\r\n   &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt;\r\n   &lt;version&gt;0.4.8&lt;/version&gt;\r\n&lt;/dependency&gt;\r\n</code></pre><p>使用起来特别的简单：一行代码就搞定了</p>\r\n<pre><code>Thumbnails.of(\"原图文件的路径\") \r\n        .scale(1f) \r\n        .outputQuality(0.5f) \r\n        .toFile(\"压缩后文件的路径\");//是完整的路径包括文件名\r\n</code></pre><p>其中的scale是可以指定图片的大小，值在0到1之间，1f就是原图大小，0.5就是原图的一半大小，这里的大小是指图片的长宽。</p>\r\n<p>而outputQuality是图片的质量，值也是在0到1，越接近于1质量越好，越接近于0质量越差。</p>\r\n<p>对于压缩图片来说上面就已经足够了。</p>\r\n<h3 id=\"h3-u4F18u70B9\"><a name=\"优点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>优点</h3><p>1、简单容易使用。<br>2、压缩图片效果很好。<br>3、图片质量不错。\r\n<h3 id=\"h3-u5176u4ED6u529Fu80FD\"><a name=\"其他功能\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其他功能</h3><p>最后附上其他功能使用的简单例子</p>\r\n<pre><code class=\"lang-java\">import java.awt.image.BufferedImage;\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\nimport javax.imageio.ImageIO;\r\n\r\nimport net.coobird.thumbnailator.Thumbnails;\r\nimport net.coobird.thumbnailator.geometry.Positions;\r\n\r\npublic class ThumbnailatorTest {\r\n\r\n    /**\r\n     * \r\n     * @param args\r\n     * @throws IOException\r\n     */\r\n    public static void main(String[] args) throws IOException {\r\n        ThumbnailatorTest thumbnailatorTest = new ThumbnailatorTest();\r\n        thumbnailatorTest.test1();\r\n        thumbnailatorTest.test2();\r\n        thumbnailatorTest.test3();\r\n        thumbnailatorTest.test4();\r\n        thumbnailatorTest.test5();\r\n        thumbnailatorTest.test6();\r\n        thumbnailatorTest.test7();\r\n        thumbnailatorTest.test8();\r\n        thumbnailatorTest.test9();\r\n    }\r\n\r\n    /**\r\n     * 指定大小进行缩放\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test1() throws IOException {\r\n        /*\r\n         * size(width,height) 若图片横比200小，高比300小，不变\r\n         * 若图片横比200小，高比300大，高缩小到300，图片比例不变 若图片横比200大，高比300小，横缩小到200，图片比例不变\r\n         * 若图片横比200大，高比300大，图片按比例缩小，横为200或高为300\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(200, 300).toFile(\"C:/image_200x300.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").size(2560, 2048).toFile(\"C:/image_2560x2048.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 按照比例进行缩放\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test2() throws IOException {\r\n        /**\r\n         * scale(比例)\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").scale(0.25f).toFile(\"C:/image_25%.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").scale(1.10f).toFile(\"C:/image_110%.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 不按照比例，指定大小进行缩放\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test3() throws IOException {\r\n        /**\r\n         * keepAspectRatio(false) 默认是按照比例缩放的\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(120, 120).keepAspectRatio(false).toFile(\"C:/image_120x120.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 旋转\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test4() throws IOException {\r\n        /**\r\n         * rotate(角度),正数：顺时针 负数：逆时针\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).rotate(90).toFile(\"C:/image+90.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).rotate(-90).toFile(\"C:/iamge-90.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 水印\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test5() throws IOException {\r\n        /**\r\n         * watermark(位置，水印图，透明度)\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(\"images/watermark.png\")), 0.5f)\r\n                .outputQuality(0.8f).toFile(\"C:/image_watermark_bottom_right.jpg\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).watermark(Positions.CENTER, ImageIO.read(new File(\"images/watermark.png\")), 0.5f)\r\n                .outputQuality(0.8f).toFile(\"C:/image_watermark_center.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 裁剪\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test6() throws IOException {\r\n        /**\r\n         * 图片中心400*400的区域\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").sourceRegion(Positions.CENTER, 400, 400).size(200, 200).keepAspectRatio(false)\r\n                .toFile(\"C:/image_region_center.jpg\");\r\n        /**\r\n         * 图片右下400*400的区域\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").sourceRegion(Positions.BOTTOM_RIGHT, 400, 400).size(200, 200).keepAspectRatio(false)\r\n                .toFile(\"C:/image_region_bootom_right.jpg\");\r\n        /**\r\n         * 指定坐标\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").sourceRegion(600, 500, 400, 400).size(200, 200).keepAspectRatio(false).toFile(\"C:/image_region_coord.jpg\");\r\n    }\r\n\r\n    /**\r\n     * 转化图像格式\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test7() throws IOException {\r\n        /**\r\n         * outputFormat(图像格式)\r\n         */\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).outputFormat(\"png\").toFile(\"C:/image_1280x1024.png\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).outputFormat(\"gif\").toFile(\"C:/image_1280x1024.gif\");\r\n    }\r\n\r\n    /**\r\n     * 输出到OutputStream\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test8() throws IOException {\r\n        /**\r\n         * toOutputStream(流对象)\r\n         */\r\n        OutputStream os = new FileOutputStream(\"C:/image_1280x1024_OutputStream.png\");\r\n        Thumbnails.of(\"images/test.jpg\").size(1280, 1024).toOutputStream(os);\r\n    }\r\n\r\n    /**\r\n     * 输出到BufferedImage\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void test9() throws IOException {\r\n        /**\r\n         * asBufferedImage() 返回BufferedImage\r\n         */\r\n        BufferedImage thumbnail = Thumbnails.of(\"images/test.jpg\").size(1280, 1024).asBufferedImage();\r\n        ImageIO.write(thumbnail, \"jpg\", new File(\"C:/image_1280x1024_BufferedImage.jpg\"));\r\n    }\r\n}\r\n</code></pre>\r\n<p>其他的具体方法细节可以自己去查看官方的API或者网络上的其他资源。</p>\r\n<p>参考博客：</p>\r\n<p><a href=\"http://blog.csdn.net/wangpeng047/article/details/17610451\">http://blog.csdn.net/wangpeng047/article/details/17610451</a></p>\r\n<p><a href=\"http://blog.csdn.net/qiaqia609/article/details/53171149\">http://blog.csdn.net/qiaqia609/article/details/53171149</a></p>\r\n<p><a href=\"http://www.cnblogs.com/miskis/p/5500822.html\">http://www.cnblogs.com/miskis/p/5500822.html</a></p>\r\n', null, null, null, '2020-10-21 22:45:35', '2020-10-21 22:45:35', '1');
INSERT INTO `articles` VALUES ('71', '1', 'Spring boot实现分页功能', '', '> 本次Spring boot实现分页的方法为使用工具PageInfo类，废话不多说直接上代码\r\n\r\n\r\n### 控制层Controller设计\r\n\r\n```java\r\n@RequestMapping(value = \"/userList\", method = RequestMethod.GET)\r\n    private String userList(Model model, @RequestParam(defaultValue = \"1\") int pageNum,\r\n                            @RequestParam(required = false) String userName,\r\n                            @RequestParam(required = false) Integer flag) {\r\n        Users users = new Users();\r\n        //两个筛选条件，从前台传递过来\r\n        if (!EmptyUtil.isEmpty(userName)) {\r\n            users.setUserName(userName);\r\n        }\r\n        if (!EmptyUtil.isEmpty(flag)) {\r\n            if (flag != 2) {\r\n                users.setUserStatus(flag);\r\n            }\r\n        }\r\n        //pageNum:当前页码，pageSize:每页显示条数,条件为对象\r\n        //PageInfo不能用于连表查询，只能在select的第一个语句作为判断分页的条件\r\n        PageInfo<Users> page = userService.page(pageNum, 5, users);\r\n        //保证不是空指针，index是用于页码设置的\r\n        //为了不让前台页码全部显示，所以将所有页码设计为一个大数组再根据前台传递的页码分为合适的小数组\r\n        if (page.getList() != null) {\r\n            List<Integer> index = PageUtil.getIndex(pageNum, page.getPages(), 2);\r\n            model.addAttribute(\"index\", index);\r\n        }\r\n        model.addAttribute(\"page\", page);\r\n        model.addAttribute(\"flag\", users.getUserStatus());\r\n        model.addAttribute(\"userName\", users.getUserName());\r\n        return \"admin/user/user_list\";\r\n    }\r\n```\r\n### 其中用到的切分数组的工具类如下\r\n```java\r\npublic class PageUtil {\r\n    //pagePages：有多少条数据，pageNum：当前页码数，footerSize：页脚需要多少个\r\n    public static List<Integer> getIndex(int pageNum, int pagePages, int footerSize) {\r\n        ArrayList<Integer> arrayList = new ArrayList<>();\r\n        for (int i = 1; i <= pagePages; i++) {\r\n            arrayList.add(i);\r\n        }\r\n        //通过工具将大数组切为等比小数组，splitNum为上面的除数\r\n        List<List<Integer>> index = PageUtil.getSplitList(footerSize, arrayList);\r\n        //确定选择是哪个小数组\r\n        int num = (pageNum - 1) / footerSize;\r\n        return index.get(num);\r\n    }\r\n\r\n    public static <T> List<List<T>> getSplitList(int splitNum, List<T> list) {\r\n        List<List<T>> splitList = new LinkedList<>();\r\n        // groupFlag >= 1\r\n        int groupFlag = list.size() % splitNum == 0 ? (list.size() / splitNum) : (list.size() / splitNum + 1);\r\n        for (int j = 1; j <= groupFlag; j++) {\r\n            if ((j * splitNum) <= list.size()) {\r\n                splitList.add(list.subList(j * splitNum - splitNum, j * splitNum));\r\n            } else if ((j * splitNum) > list.size()) {\r\n                splitList.add(list.subList(j * splitNum - splitNum, list.size()));\r\n            }\r\n        }\r\n        return splitList;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 业务逻辑层ServiceImpl设计\r\n\r\n```java\r\npublic PageInfo<Users> page(int pageNum, int pageSize, Users users) {\r\n        PageHelper.startPage(pageNum, pageSize);\r\n        // 设置分页查询条件，这里使用的tk.mybatis工具类，其他自行设计\r\n        Example example = new Example(Users.class);\r\n        Example.Criteria criteria = example.createCriteria();\r\n        if (!EmptyUtil.isEmpty(users.getUserName())) {\r\n            criteria.andLike(\"userName\", \"%\" + users.getUserName() + \"%\");\r\n        }\r\n        if (!EmptyUtil.isEmpty(users.getUserStatus())) {\r\n            criteria.andEqualTo(\"userStatus\", users.getUserStatus());\r\n        }\r\n        List<Users> admins1 = usersMapper.selectByExample(example);\r\n        if (EmptyUtil.isEmpty(admins1)) {\r\n            return new PageInfo<>();\r\n        }\r\n        return new PageInfo<>(admins1);\r\n    }\r\n```\r\n\r\n### 前台代码设计\r\n```html\r\n                       <div class=\"widget-body  am-fr\">\r\n                            <div class=\"am-u-sm-12 am-u-md-6 am-u-lg-6\">\r\n                                <div class=\"am-form-group\">\r\n                                    <div class=\"am-btn-toolbar\">\r\n                                        <div class=\"am-btn-group am-btn-group-xs\">\r\n                                            <a th:href=\"@{\'/admin/userAdd\'}\"\r\n                                               class=\"am-btn am-btn-default am-btn-success\"><span\r\n                                                    class=\"am-icon-plus\"></span> 新增\r\n                                            </a>\r\n                                        </div>\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                            <div class=\"am-u-sm-12 am-u-md-6 am-u-lg-3\">\r\n                                <div class=\"am-form-group tpl-table-list-select\">\r\n                                    <label>\r\n                                        <select name=\"flag\" data-am-selected=\"{btnSize: \'sm\'}\" onchange=\"select()\">\r\n                                            <option value=\"2\" th:selected=\"${flag==null}\">\r\n                                                所有用户\r\n                                            </option>\r\n                                            <option value=\"1\" th:selected=\"${flag==1}\">\r\n                                                已启用用户\r\n                                            </option>\r\n                                            <option value=\"0\" th:selected=\"${flag==0}\">\r\n                                                禁用用户\r\n                                            </option>\r\n                                        </select>\r\n                                    </label>\r\n                                </div>\r\n                            </div>\r\n                            <div class=\"am-u-sm-12 am-u-md-12 am-u-lg-3\">\r\n                                <div class=\"am-input-group am-input-group-sm tpl-form-border-form cl-p\">\r\n                                    <input th:value=\"${userName}\" id=\"userName\" name=\"userName\" type=\"text\"\r\n                                           class=\"am-form-field\"\r\n                                           placeholder=\"用户姓名\">\r\n                                    <span class=\"am-input-group-btn\">\r\n                                       <a onclick=\"select()\"\r\n                                          class=\"am-btn  am-btn-default am-btn-success tpl-table-list-field am-icon-search\"></a>\r\n                                    </span>\r\n                                </div>\r\n                            </div>\r\n                            <div  th:if=\"${page.getList()==null}\" class=\"am-u-sm-12\">\r\n                                表中无数据\r\n                            </div>\r\n                            <div th:style=\"\'display:\' + @{(${page.getList()==null} ? \'none\')} + \'\'\" class=\"am-u-sm-12\">\r\n                                <div class=\"am-scrollable-horizontal \">\r\n                                    <table width=\"100%\"  class=\"am-table am-table-compact am-text-nowrap tpl-table-black \">\r\n                                        <thead>\r\n                                        <tr>\r\n                                            <th>用户ID</th>\r\n                                            <th>用户姓名</th>\r\n                                            <th>用户账号</th>\r\n                                            <th>用户创建时间</th>\r\n                                            <th>用户头像</th>\r\n                                            <th>用户状态</th>\r\n                                            <th>操作</th>\r\n                                        </tr>\r\n                                        </thead>\r\n                                        <tbody>\r\n                                        <tr th:each=\"user : ${page.getList()}\" class=\"gradeX\">\r\n                                            <td th:text=\"${user.userId}\"></td>\r\n                                            <td th:text=\"${user.userName}\"></td>\r\n                                            <td th:text=\"${user.userEmail}\"></td>\r\n                                            <td th:text=\"${#dates.format(user.userCreateTime,\'yyyy-MM-dd HH:mm:ss\')}\"></td>\r\n                                            <td>\r\n                                                <img th:src=\"${user.userPhoto}\" width=\"50\" height=\"50\"  alt=\"140*140\" class=\"am-img-thumbnail am-circle\">\r\n                                            </td>\r\n                                            <td th:text=\"${user.userStatus==1}?\'启用\':\'禁用\'\"></td>\r\n                                            <td>\r\n                                                <div class=\"tpl-table-black-operation\">\r\n                                                    <a th:href=\"@{\'/admin/userUpdate?userId=\'+${user.userId}}\">\r\n                                                        <i class=\"am-icon-pencil\"></i> 编辑\r\n                                                    </a>\r\n                                                    <a th:href=\"@{\'/admin/userDelete?userId=\'+${user.userId}}\"\r\n                                                       class=\"tpl-table-black-operation-del\" onclick=\"return del()\">\r\n                                                        <i class=\"am-icon-trash\"></i> 删除\r\n                                                    </a>\r\n                                                </div>\r\n                                            </td>\r\n                                        </tr>\r\n                                        </tbody>\r\n                                    </table>\r\n                                </div>\r\n                            </div>\r\n\r\n                            <div th:style=\"\'display:\' + @{(${page.getList()==null} ? \'none\')} + \'\'\" class=\"am-u-lg-12 am-cf\">\r\n                                <div class=\"am-fr\">\r\n                                    <ul class=\"am-pagination tpl-pagination\">\r\n                                        <li th:if=\"${page.pageNum!=1}\">\r\n                                            <a onclick=\"page1()\">首页</a>\r\n                                        </li>\r\n                                        <li th:if=\"${page.hasPreviousPage==true}\">\r\n                                            <a onclick=\"page2()\">«</a>\r\n                                        </li>\r\n                                        <li th:each=\"i : ${index}\" th:class=\"${page.pageNum==i}? \'am-active\'\">\r\n                                            <a th:text=\"${i}\" onclick=\"page3(this)\"></a>\r\n                                        </li>\r\n                                        <li th:if=\"${page.hasNextPage==true}\">\r\n                                            <a onclick=\"page4()\">»</a>\r\n                                        </li>\r\n                                        <li th:if=\"${page.pageNum!=page.pages}\">\r\n                                            <a onclick=\"page5()\">末页</a>\r\n                                        </li>\r\n                                    </ul>\r\n                                </div>\r\n                                <!--<div class=\"am-fr\">\r\n                                    <ul class=\"am-pagination tpl-pagination\">\r\n                                        <li th:if=\"${page.pageNum!=1}\">\r\n                                            <a th:href=\"@{\'/admin/adminList?pageNum=\'+1}\">首页</a>\r\n                                        </li>\r\n                                        <li th:if=\"${page.hasPreviousPage==true}\">\r\n                                            <a th:href=\"@{\'/admin/adminList?pageNum=\'+${page.pageNum-1}}\">«</a>\r\n                                        </li>\r\n                                        <li th:each=\"i : ${index}\" th:class=\"${page.pageNum==i}? \'am-active\'\">\r\n                                            <a th:text=\"${i}\" th:href=\"@{\'/admin/adminList?pageNum=\'+${i}}\"></a>\r\n                                        </li>\r\n                                        <li th:if=\"${page.hasNextPage==true}\">\r\n                                            <a th:href=\"@{\'/admin/adminList?pageNum=\'+${page.pageNum+1}}\">»</a>\r\n                                        </li>\r\n                                        <li th:if=\"${page.pageNum!=page.pages}\">\r\n                                            <a th:href=\"@{\'/admin/adminList?pageNum=\'+${page.pages}}\">末页</a>\r\n                                        </li>\r\n                                    </ul>\r\n                                </div>-->\r\n                            </div>\r\n                        </div>\r\n```\r\n\r\n\r\n### js文件设计（根据不同的条件设计，比较混乱没有整合，自行理解）\r\n\r\n```javascript\r\n<script language=\"javascript\" type=\"text/javascript\">\r\n    function del() {\r\n        return confirm(\"确定要删除吗？\")?true:false;\r\n    }\r\n    function select() {\r\n        //获取被选中的option标签\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n\r\n        if (flag === \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList\";\r\n        }\r\n\r\n        if (flag !== \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?userName=\" + userName + \"&flag=\" + flag;\r\n        }\r\n\r\n    }\r\n\r\n    function page1() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1 + \"&flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1 + \"&userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1 + \"&flag=\" + flag + \"&userName=\" + userName;\r\n        }\r\n\r\n    }\r\n\r\n    function page2() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]];\r\n        }\r\n\r\n        if (flag !== \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]] + \"&flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]] + \"&userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]] + \"&flag=\" + flag + \"&userName=\" + userName;\r\n        }\r\n    }\r\n\r\n    function page3(e) {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        var pageNum = $(e).text();\r\n        if (flag === \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum + \"&flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum + \"&userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum + \"&flag=\" + flag + \"&userName=\" + userName;\r\n        }\r\n\r\n    }\r\n\r\n    function page4() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum+1}]];\r\n        }\r\n\r\n        if (flag !== \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum+1}]] + \"&flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/adminList?pageNum=\" + [[${page.pageNum+1}]] + \"&userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum+1}]] + \"&flag=\" + flag + \"&userName=\" + userName;\r\n        }\r\n    }\r\n\r\n    function page5() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pages}]];\r\n        }\r\n\r\n        if (flag !== \'2\' && userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pages}]] + \"&flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/adminList?pageNum=\" + [[${page.pages}]] + \"&userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' && userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pages}]] + \"&flag=\" + flag + \"&userName=\" + userName;\r\n        }\r\n    }\r\n\r\n</script>\r\n```\r\n\r\n\r\n', '<blockquote>\r\n<p>本次Spring boot实现分页的方法为使用工具PageInfo类，废话不多说直接上代码</p>\r\n</blockquote>\r\n<h3 id=\"h3--controller-\"><a name=\"控制层Controller设计\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>控制层Controller设计</h3><pre><code class=\"lang-java\">@RequestMapping(value = \"/userList\", method = RequestMethod.GET)\r\n    private String userList(Model model, @RequestParam(defaultValue = \"1\") int pageNum,\r\n                            @RequestParam(required = false) String userName,\r\n                            @RequestParam(required = false) Integer flag) {\r\n        Users users = new Users();\r\n        //两个筛选条件，从前台传递过来\r\n        if (!EmptyUtil.isEmpty(userName)) {\r\n            users.setUserName(userName);\r\n        }\r\n        if (!EmptyUtil.isEmpty(flag)) {\r\n            if (flag != 2) {\r\n                users.setUserStatus(flag);\r\n            }\r\n        }\r\n        //pageNum:当前页码，pageSize:每页显示条数,条件为对象\r\n        //PageInfo不能用于连表查询，只能在select的第一个语句作为判断分页的条件\r\n        PageInfo&lt;Users&gt; page = userService.page(pageNum, 5, users);\r\n        //保证不是空指针，index是用于页码设置的\r\n        //为了不让前台页码全部显示，所以将所有页码设计为一个大数组再根据前台传递的页码分为合适的小数组\r\n        if (page.getList() != null) {\r\n            List&lt;Integer&gt; index = PageUtil.getIndex(pageNum, page.getPages(), 2);\r\n            model.addAttribute(\"index\", index);\r\n        }\r\n        model.addAttribute(\"page\", page);\r\n        model.addAttribute(\"flag\", users.getUserStatus());\r\n        model.addAttribute(\"userName\", users.getUserName());\r\n        return \"admin/user/user_list\";\r\n    }\r\n</code></pre>\r\n<h3 id=\"h3-u5176u4E2Du7528u5230u7684u5207u5206u6570u7EC4u7684u5DE5u5177u7C7Bu5982u4E0B\"><a name=\"其中用到的切分数组的工具类如下\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其中用到的切分数组的工具类如下</h3><pre><code class=\"lang-java\">public class PageUtil {\r\n    //pagePages：有多少条数据，pageNum：当前页码数，footerSize：页脚需要多少个\r\n    public static List&lt;Integer&gt; getIndex(int pageNum, int pagePages, int footerSize) {\r\n        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();\r\n        for (int i = 1; i &lt;= pagePages; i++) {\r\n            arrayList.add(i);\r\n        }\r\n        //通过工具将大数组切为等比小数组，splitNum为上面的除数\r\n        List&lt;List&lt;Integer&gt;&gt; index = PageUtil.getSplitList(footerSize, arrayList);\r\n        //确定选择是哪个小数组\r\n        int num = (pageNum - 1) / footerSize;\r\n        return index.get(num);\r\n    }\r\n\r\n    public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; getSplitList(int splitNum, List&lt;T&gt; list) {\r\n        List&lt;List&lt;T&gt;&gt; splitList = new LinkedList&lt;&gt;();\r\n        // groupFlag &gt;= 1\r\n        int groupFlag = list.size() % splitNum == 0 ? (list.size() / splitNum) : (list.size() / splitNum + 1);\r\n        for (int j = 1; j &lt;= groupFlag; j++) {\r\n            if ((j * splitNum) &lt;= list.size()) {\r\n                splitList.add(list.subList(j * splitNum - splitNum, j * splitNum));\r\n            } else if ((j * splitNum) &gt; list.size()) {\r\n                splitList.add(list.subList(j * splitNum - splitNum, list.size()));\r\n            }\r\n        }\r\n        return splitList;\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"h3--serviceimpl-\"><a name=\"业务逻辑层ServiceImpl设计\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>业务逻辑层ServiceImpl设计</h3><pre><code class=\"lang-java\">public PageInfo&lt;Users&gt; page(int pageNum, int pageSize, Users users) {\r\n        PageHelper.startPage(pageNum, pageSize);\r\n        // 设置分页查询条件，这里使用的tk.mybatis工具类，其他自行设计\r\n        Example example = new Example(Users.class);\r\n        Example.Criteria criteria = example.createCriteria();\r\n        if (!EmptyUtil.isEmpty(users.getUserName())) {\r\n            criteria.andLike(\"userName\", \"%\" + users.getUserName() + \"%\");\r\n        }\r\n        if (!EmptyUtil.isEmpty(users.getUserStatus())) {\r\n            criteria.andEqualTo(\"userStatus\", users.getUserStatus());\r\n        }\r\n        List&lt;Users&gt; admins1 = usersMapper.selectByExample(example);\r\n        if (EmptyUtil.isEmpty(admins1)) {\r\n            return new PageInfo&lt;&gt;();\r\n        }\r\n        return new PageInfo&lt;&gt;(admins1);\r\n    }\r\n</code></pre>\r\n<h3 id=\"h3-u524Du53F0u4EE3u7801u8BBEu8BA1\"><a name=\"前台代码设计\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前台代码设计</h3><pre><code class=\"lang-html\">                       &lt;div class=\"widget-body  am-fr\"&gt;\r\n                            &lt;div class=\"am-u-sm-12 am-u-md-6 am-u-lg-6\"&gt;\r\n                                &lt;div class=\"am-form-group\"&gt;\r\n                                    &lt;div class=\"am-btn-toolbar\"&gt;\r\n                                        &lt;div class=\"am-btn-group am-btn-group-xs\"&gt;\r\n                                            &lt;a th:href=\"@{\'/admin/userAdd\'}\"\r\n                                               class=\"am-btn am-btn-default am-btn-success\"&gt;&lt;span\r\n                                                    class=\"am-icon-plus\"&gt;&lt;/span&gt; 新增\r\n                                            &lt;/a&gt;\r\n                                        &lt;/div&gt;\r\n                                    &lt;/div&gt;\r\n                                &lt;/div&gt;\r\n                            &lt;/div&gt;\r\n                            &lt;div class=\"am-u-sm-12 am-u-md-6 am-u-lg-3\"&gt;\r\n                                &lt;div class=\"am-form-group tpl-table-list-select\"&gt;\r\n                                    &lt;label&gt;\r\n                                        &lt;select name=\"flag\" data-am-selected=\"{btnSize: \'sm\'}\" onchange=\"select()\"&gt;\r\n                                            &lt;option value=\"2\" th:selected=\"${flag==null}\"&gt;\r\n                                                所有用户\r\n                                            &lt;/option&gt;\r\n                                            &lt;option value=\"1\" th:selected=\"${flag==1}\"&gt;\r\n                                                已启用用户\r\n                                            &lt;/option&gt;\r\n                                            &lt;option value=\"0\" th:selected=\"${flag==0}\"&gt;\r\n                                                禁用用户\r\n                                            &lt;/option&gt;\r\n                                        &lt;/select&gt;\r\n                                    &lt;/label&gt;\r\n                                &lt;/div&gt;\r\n                            &lt;/div&gt;\r\n                            &lt;div class=\"am-u-sm-12 am-u-md-12 am-u-lg-3\"&gt;\r\n                                &lt;div class=\"am-input-group am-input-group-sm tpl-form-border-form cl-p\"&gt;\r\n                                    &lt;input th:value=\"${userName}\" id=\"userName\" name=\"userName\" type=\"text\"\r\n                                           class=\"am-form-field\"\r\n                                           placeholder=\"用户姓名\"&gt;\r\n                                    &lt;span class=\"am-input-group-btn\"&gt;\r\n                                       &lt;a onclick=\"select()\"\r\n                                          class=\"am-btn  am-btn-default am-btn-success tpl-table-list-field am-icon-search\"&gt;&lt;/a&gt;\r\n                                    &lt;/span&gt;\r\n                                &lt;/div&gt;\r\n                            &lt;/div&gt;\r\n                            &lt;div  th:if=\"${page.getList()==null}\" class=\"am-u-sm-12\"&gt;\r\n                                表中无数据\r\n                            &lt;/div&gt;\r\n                            &lt;div th:style=\"\'display:\' + @{(${page.getList()==null} ? \'none\')} + \'\'\" class=\"am-u-sm-12\"&gt;\r\n                                &lt;div class=\"am-scrollable-horizontal \"&gt;\r\n                                    &lt;table width=\"100%\"  class=\"am-table am-table-compact am-text-nowrap tpl-table-black \"&gt;\r\n                                        &lt;thead&gt;\r\n                                        &lt;tr&gt;\r\n                                            &lt;th&gt;用户ID&lt;/th&gt;\r\n                                            &lt;th&gt;用户姓名&lt;/th&gt;\r\n                                            &lt;th&gt;用户账号&lt;/th&gt;\r\n                                            &lt;th&gt;用户创建时间&lt;/th&gt;\r\n                                            &lt;th&gt;用户头像&lt;/th&gt;\r\n                                            &lt;th&gt;用户状态&lt;/th&gt;\r\n                                            &lt;th&gt;操作&lt;/th&gt;\r\n                                        &lt;/tr&gt;\r\n                                        &lt;/thead&gt;\r\n                                        &lt;tbody&gt;\r\n                                        &lt;tr th:each=\"user : ${page.getList()}\" class=\"gradeX\"&gt;\r\n                                            &lt;td th:text=\"${user.userId}\"&gt;&lt;/td&gt;\r\n                                            &lt;td th:text=\"${user.userName}\"&gt;&lt;/td&gt;\r\n                                            &lt;td th:text=\"${user.userEmail}\"&gt;&lt;/td&gt;\r\n                                            &lt;td th:text=\"${#dates.format(user.userCreateTime,\'yyyy-MM-dd HH:mm:ss\')}\"&gt;&lt;/td&gt;\r\n                                            &lt;td&gt;\r\n                                                &lt;img th:src=\"${user.userPhoto}\" width=\"50\" height=\"50\"  alt=\"140*140\" class=\"am-img-thumbnail am-circle\"&gt;\r\n                                            &lt;/td&gt;\r\n                                            &lt;td th:text=\"${user.userStatus==1}?\'启用\':\'禁用\'\"&gt;&lt;/td&gt;\r\n                                            &lt;td&gt;\r\n                                                &lt;div class=\"tpl-table-black-operation\"&gt;\r\n                                                    &lt;a th:href=\"@{\'/admin/userUpdate?userId=\'+${user.userId}}\"&gt;\r\n                                                        &lt;i class=\"am-icon-pencil\"&gt;&lt;/i&gt; 编辑\r\n                                                    &lt;/a&gt;\r\n                                                    &lt;a th:href=\"@{\'/admin/userDelete?userId=\'+${user.userId}}\"\r\n                                                       class=\"tpl-table-black-operation-del\" onclick=\"return del()\"&gt;\r\n                                                        &lt;i class=\"am-icon-trash\"&gt;&lt;/i&gt; 删除\r\n                                                    &lt;/a&gt;\r\n                                                &lt;/div&gt;\r\n                                            &lt;/td&gt;\r\n                                        &lt;/tr&gt;\r\n                                        &lt;/tbody&gt;\r\n                                    &lt;/table&gt;\r\n                                &lt;/div&gt;\r\n                            &lt;/div&gt;\r\n\r\n                            &lt;div th:style=\"\'display:\' + @{(${page.getList()==null} ? \'none\')} + \'\'\" class=\"am-u-lg-12 am-cf\"&gt;\r\n                                &lt;div class=\"am-fr\"&gt;\r\n                                    &lt;ul class=\"am-pagination tpl-pagination\"&gt;\r\n                                        &lt;li th:if=\"${page.pageNum!=1}\"&gt;\r\n                                            &lt;a onclick=\"page1()\"&gt;首页&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:if=\"${page.hasPreviousPage==true}\"&gt;\r\n                                            &lt;a onclick=\"page2()\"&gt;«&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:each=\"i : ${index}\" th:class=\"${page.pageNum==i}? \'am-active\'\"&gt;\r\n                                            &lt;a th:text=\"${i}\" onclick=\"page3(this)\"&gt;&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:if=\"${page.hasNextPage==true}\"&gt;\r\n                                            &lt;a onclick=\"page4()\"&gt;»&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:if=\"${page.pageNum!=page.pages}\"&gt;\r\n                                            &lt;a onclick=\"page5()\"&gt;末页&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                    &lt;/ul&gt;\r\n                                &lt;/div&gt;\r\n                                &lt;!--&lt;div class=\"am-fr\"&gt;\r\n                                    &lt;ul class=\"am-pagination tpl-pagination\"&gt;\r\n                                        &lt;li th:if=\"${page.pageNum!=1}\"&gt;\r\n                                            &lt;a th:href=\"@{\'/admin/adminList?pageNum=\'+1}\"&gt;首页&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:if=\"${page.hasPreviousPage==true}\"&gt;\r\n                                            &lt;a th:href=\"@{\'/admin/adminList?pageNum=\'+${page.pageNum-1}}\"&gt;«&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:each=\"i : ${index}\" th:class=\"${page.pageNum==i}? \'am-active\'\"&gt;\r\n                                            &lt;a th:text=\"${i}\" th:href=\"@{\'/admin/adminList?pageNum=\'+${i}}\"&gt;&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:if=\"${page.hasNextPage==true}\"&gt;\r\n                                            &lt;a th:href=\"@{\'/admin/adminList?pageNum=\'+${page.pageNum+1}}\"&gt;»&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                        &lt;li th:if=\"${page.pageNum!=page.pages}\"&gt;\r\n                                            &lt;a th:href=\"@{\'/admin/adminList?pageNum=\'+${page.pages}}\"&gt;末页&lt;/a&gt;\r\n                                        &lt;/li&gt;\r\n                                    &lt;/ul&gt;\r\n                                &lt;/div&gt;--&gt;\r\n                            &lt;/div&gt;\r\n                        &lt;/div&gt;\r\n</code></pre>\r\n<h3 id=\"h3-js-\"><a name=\"js文件设计（根据不同的条件设计，比较混乱没有整合，自行理解）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>js文件设计（根据不同的条件设计，比较混乱没有整合，自行理解）</h3><pre><code class=\"lang-javascript\">&lt;script language=\"javascript\" type=\"text/javascript\"&gt;\r\n    function del() {\r\n        return confirm(\"确定要删除吗？\")?true:false;\r\n    }\r\n    function select() {\r\n        //获取被选中的option标签\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n\r\n        if (flag === \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList\";\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?userName=\" + userName + \"&amp;flag=\" + flag;\r\n        }\r\n\r\n    }\r\n\r\n    function page1() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1 + \"&amp;flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1 + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + 1 + \"&amp;flag=\" + flag + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n    }\r\n\r\n    function page2() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]];\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]] + \"&amp;flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]] + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum-1}]] + \"&amp;flag=\" + flag + \"&amp;userName=\" + userName;\r\n        }\r\n    }\r\n\r\n    function page3(e) {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        var pageNum = $(e).text();\r\n        if (flag === \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum + \"&amp;flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + pageNum + \"&amp;flag=\" + flag + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n    }\r\n\r\n    function page4() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum+1}]];\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum+1}]] + \"&amp;flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/adminList?pageNum=\" + [[${page.pageNum+1}]] + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pageNum+1}]] + \"&amp;flag=\" + flag + \"&amp;userName=\" + userName;\r\n        }\r\n    }\r\n\r\n    function page5() {\r\n        var flag = $(\'select  option:selected\').val();\r\n        var userName = $(\'#userName\').val();\r\n        if (flag === \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pages}]];\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName === \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pages}]] + \"&amp;flag=\" + flag;\r\n        }\r\n        if (flag === \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/adminList?pageNum=\" + [[${page.pages}]] + \"&amp;userName=\" + userName;\r\n        }\r\n\r\n        if (flag !== \'2\' &amp;&amp; userName !== \'\') {\r\n            window.location.href = \"/admin/userList?pageNum=\" + [[${page.pages}]] + \"&amp;flag=\" + flag + \"&amp;userName=\" + userName;\r\n        }\r\n    }\r\n\r\n&lt;/script&gt;\r\n</code></pre>\r\n', null, null, null, '2020-10-22 22:48:05', '2020-10-22 22:48:05', '1');
INSERT INTO `articles` VALUES ('72', '1', 'markdown格式editor富文本，用于写博客用（带图片上传）', '', '> 当我们想要一个可以写博客的编辑器的话，editor编辑器是一个不错的选择，本博客网站正是使用此编辑器编写博客\r\n\r\n### 首先引入必要的js和css文件\r\n\r\n\r\n    <link rel=\"stylesheet\" th:href=\"@{/editor/css/editormd.css}\">\r\n    <link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\"/>\r\n\r\n```javascript\r\n<script th:src=\"@{/editor/jquery.min.js}\"></script>\r\n<script th:src=\"@{/editor/editormd.min.js}\"></script>\r\n```\r\n\r\n### html前端代码\r\n```html\r\n               <div class=\"editormd\" id=\"test-editormd\" style=\"margin-top: 10px\">\r\n                       <textarea class=\"editormd-markdown-textarea\"\r\n                          name=\"test-editormd-markdown-doc\" id=\"content\"\r\n                          th:text=\"${article.articleContentMd}\"></textarea>\r\n                       <!-- 第二个隐藏文本域，用来构造生成的HTML代码，方便表单POST提交，这里的name可以任意取，后台接受时以这个name键为准 -->\r\n                       <textarea class=\"editormd-html-textarea\" name=\"editormd-html-textarea\" id=\"htmlContent\"></textarea>\r\n              </div>\r\n\r\n\r\n```\r\n### 在底部开启editor\r\n   ```javascript\r\n $(function () {\r\n        editormd(\"test-editormd\", {\r\n            width: \"100%\",\r\n            height: 840,\r\n            syncScrolling: \"single\",\r\n            emoji: true,\r\n            //你的lib目录的路径\r\n            tocm: true, // Using [TOCM]\r\n            htmlDecode: \"style,script,iframe|on*\",//这个属性开启可以支持字体颜色大小更改，开启 HTML 标签解析，为了安全性，默认不开启\r\n            taskList: true,\r\n            tex: true, // 开启科学公式TeX语言支持，默认关闭\r\n            flowChart: true, // 开启流程图支持，默认关闭\r\n            imageUpload: true,\r\n            imageFormats: [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],\r\n            imageUploadURL: \"/markdown\",\r\n            path: \"/editor/lib/\",\r\n            //这个配置在simple.html中并没有，但是为了能够提交表单，使用这个配置可以让构造出来的HTML代码直接在第二个隐藏的textarea域中，方便post提交表单。\r\n            saveHTMLToTextarea: true\r\n        });\r\n        /*下一步和上一步操作*/\r\n        $(\"#next,#last\").click(\r\n            function () {\r\n                $(\"#first\").toggle();\r\n                $(\"#second\").toggle();\r\n            }\r\n        );\r\n```\r\n\r\n\r\n### 后台接收代码Controller层：\r\n\r\n```java\r\n@RequestMapping(value = \"/articleAdd\", method = RequestMethod.POST)\r\n    private String articleAdd(RedirectAttributes redirectAttributes, Model model, Articles articles, HttpServletRequest request, @RequestParam(required = false) String status) {\r\n\r\n        /*判断是否启用博文*/\r\n        if (status == null || status.length() == 0) {\r\n            articles.setArticleStatus(0);\r\n        } else {\r\n            articles.setArticleStatus(1);\r\n        }\r\n        /*暂时设置用户为1*/\r\n        articles.setUserId(1L);\r\n        /*博文内容机器mark格式单独获取*/\r\n        articles.setArticleContent(request.getParameter(\"editormd-html-textarea\"));\r\n        articles.setArticleContentMd(request.getParameter(\"test-editormd-markdown-doc\"));\r\n        /*设置时间*/\r\n        articles.setArticleUpdateTime(new Date());\r\n        articles.setArticleCreateTime(new Date());\r\n        /*分类列表*/\r\n        String[] sortCheckboxes = request.getParameterValues(\"sortCheckbox\");\r\n        /*标签列表*/\r\n        String[] labelCheckboxes = request.getParameterValues(\"labelCheckbox\");\r\n        /*单独判断分类标签，不然会报空指针异常*/\r\n        if (sortCheckboxes == null||labelCheckboxes==null) {\r\n            //model.addAttribute(\"sortCheckboxes\",sortCheckboxes);\r\n            //model.addAttribute(\"labelCheckboxes\",labelCheckboxes);\r\n            model.addAttribute(\"article\", articles);\r\n            model.addAttribute(\"sortsList\", sortService.list());\r\n            model.addAttribute(\"labelsList\", labelService.list());\r\n            model.addAttribute(\"messages\",\"至少选择一个分类或分类\");\r\n            return \"admin/article/article_add\";\r\n        }\r\n```\r\n### 图片写入\r\n```java\r\n    @ResponseBody\r\n    @RequestMapping(value = \"/markdown\", method = RequestMethod.POST)\r\n    public Map<String, Object> demo(@RequestParam(value = \"editormd-image-file\", required = false) MultipartFile file, HttpServletRequest request) {\r\n       //前面提及过图片的上传\r\n        return uploadFileUtil(file);\r\n\r\n    }\r\n```\r\n\r\n### 再次回显到前台代码\r\n在文本域中写一下代码：\r\n`th:text=\"${article.articleContentMd}\"`\r\n\r\n\r\n', '<blockquote>\r\n<p>当我们想要一个可以写博客的编辑器的话，editor编辑器是一个不错的选择，本博客网站正是使用此编辑器编写博客</p>\r\n</blockquote>\r\n<h3 id=\"h3--js-css-\"><a name=\"首先引入必要的js和css文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>首先引入必要的js和css文件</h3><pre><code>&lt;link rel=\"stylesheet\" th:href=\"@{/editor/css/editormd.css}\"&gt;\r\n&lt;link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\"/&gt;\r\n</code></pre><pre><code class=\"lang-javascript\">&lt;script th:src=\"@{/editor/jquery.min.js}\"&gt;&lt;/script&gt;\r\n&lt;script th:src=\"@{/editor/editormd.min.js}\"&gt;&lt;/script&gt;\r\n</code></pre>\r\n<h3 id=\"h3-html-\"><a name=\"html前端代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>html前端代码</h3><pre><code class=\"lang-html\">               &lt;div class=\"editormd\" id=\"test-editormd\" style=\"margin-top: 10px\"&gt;\r\n                       &lt;textarea class=\"editormd-markdown-textarea\"\r\n                          name=\"test-editormd-markdown-doc\" id=\"content\"\r\n                          th:text=\"${article.articleContentMd}\"&gt;&lt;/textarea&gt;\r\n                       &lt;!-- 第二个隐藏文本域，用来构造生成的HTML代码，方便表单POST提交，这里的name可以任意取，后台接受时以这个name键为准 --&gt;\r\n                       &lt;textarea class=\"editormd-html-textarea\" name=\"editormd-html-textarea\" id=\"htmlContent\"&gt;&lt;/textarea&gt;\r\n              &lt;/div&gt;\r\n</code></pre>\r\n<h3 id=\"h3--editor\"><a name=\"在底部开启editor\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在底部开启editor</h3><pre><code class=\"lang-javascript\"> $(function () {\r\n        editormd(\"test-editormd\", {\r\n            width: \"100%\",\r\n            height: 840,\r\n            syncScrolling: \"single\",\r\n            emoji: true,\r\n            //你的lib目录的路径\r\n            tocm: true, // Using [TOCM]\r\n            htmlDecode: \"style,script,iframe|on*\",//这个属性开启可以支持字体颜色大小更改，开启 HTML 标签解析，为了安全性，默认不开启\r\n            taskList: true,\r\n            tex: true, // 开启科学公式TeX语言支持，默认关闭\r\n            flowChart: true, // 开启流程图支持，默认关闭\r\n            imageUpload: true,\r\n            imageFormats: [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],\r\n            imageUploadURL: \"/markdown\",\r\n            path: \"/editor/lib/\",\r\n            //这个配置在simple.html中并没有，但是为了能够提交表单，使用这个配置可以让构造出来的HTML代码直接在第二个隐藏的textarea域中，方便post提交表单。\r\n            saveHTMLToTextarea: true\r\n        });\r\n        /*下一步和上一步操作*/\r\n        $(\"#next,#last\").click(\r\n            function () {\r\n                $(\"#first\").toggle();\r\n                $(\"#second\").toggle();\r\n            }\r\n        );\r\n</code></pre>\r\n<h3 id=\"h3--controller-\"><a name=\"后台接收代码Controller层：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>后台接收代码Controller层：</h3><pre><code class=\"lang-java\">@RequestMapping(value = \"/articleAdd\", method = RequestMethod.POST)\r\n    private String articleAdd(RedirectAttributes redirectAttributes, Model model, Articles articles, HttpServletRequest request, @RequestParam(required = false) String status) {\r\n\r\n        /*判断是否启用博文*/\r\n        if (status == null || status.length() == 0) {\r\n            articles.setArticleStatus(0);\r\n        } else {\r\n            articles.setArticleStatus(1);\r\n        }\r\n        /*暂时设置用户为1*/\r\n        articles.setUserId(1L);\r\n        /*博文内容机器mark格式单独获取*/\r\n        articles.setArticleContent(request.getParameter(\"editormd-html-textarea\"));\r\n        articles.setArticleContentMd(request.getParameter(\"test-editormd-markdown-doc\"));\r\n        /*设置时间*/\r\n        articles.setArticleUpdateTime(new Date());\r\n        articles.setArticleCreateTime(new Date());\r\n        /*分类列表*/\r\n        String[] sortCheckboxes = request.getParameterValues(\"sortCheckbox\");\r\n        /*标签列表*/\r\n        String[] labelCheckboxes = request.getParameterValues(\"labelCheckbox\");\r\n        /*单独判断分类标签，不然会报空指针异常*/\r\n        if (sortCheckboxes == null||labelCheckboxes==null) {\r\n            //model.addAttribute(\"sortCheckboxes\",sortCheckboxes);\r\n            //model.addAttribute(\"labelCheckboxes\",labelCheckboxes);\r\n            model.addAttribute(\"article\", articles);\r\n            model.addAttribute(\"sortsList\", sortService.list());\r\n            model.addAttribute(\"labelsList\", labelService.list());\r\n            model.addAttribute(\"messages\",\"至少选择一个分类或分类\");\r\n            return \"admin/article/article_add\";\r\n        }\r\n</code></pre>\r\n<h3 id=\"h3-u56FEu7247u5199u5165\"><a name=\"图片写入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>图片写入</h3><pre><code class=\"lang-java\">    @ResponseBody\r\n    @RequestMapping(value = \"/markdown\", method = RequestMethod.POST)\r\n    public Map&lt;String, Object&gt; demo(@RequestParam(value = \"editormd-image-file\", required = false) MultipartFile file, HttpServletRequest request) {\r\n       //前面提及过图片的上传\r\n        return uploadFileUtil(file);\r\n\r\n    }\r\n</code></pre>\r\n<h3 id=\"h3-u518Du6B21u56DEu663Eu5230u524Du53F0u4EE3u7801\"><a name=\"再次回显到前台代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>再次回显到前台代码</h3><p>在文本域中写一下代码：<br><code>th:text=\"${article.articleContentMd}\"</code></p>\r\n', null, null, null, '2020-10-22 22:53:08', '2020-10-22 22:53:08', '1');
INSERT INTO `articles` VALUES ('73', '1', '博客网站数据库设计（MySQL）', '', '> 想要创建一个博客网站，首先的先设计数据库结构，本博客网站数据库设计表如下\r\n\r\n```sql\r\n/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : sunyue\r\nSource Server Version : 50724\r\nSource Host           : localhost:3306\r\nSource Database       : myblog\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50724\r\nFile Encoding         : 65001\r\n\r\nDate: 2020-10-22 22:55:38\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for admins\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `admins`;\r\nCREATE TABLE `admins` (\r\n  `admin_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'管理员ID\',\r\n  `admin_name` varchar(20) NOT NULL COMMENT \'管理员名\',\r\n  `admin_password` varchar(15) NOT NULL COMMENT \'管理员密码\',\r\n  `admin_photo` varchar(255) NOT NULL COMMENT \'管理员头像\',\r\n  `admin_email` varchar(30) NOT NULL COMMENT \'管理员邮箱\',\r\n  `admin_phone` varchar(11) NOT NULL COMMENT \'管理员手机号\',\r\n  `admin_create_time` datetime NOT NULL COMMENT \'注册时间\',\r\n  `admin_login_time` datetime NOT NULL COMMENT \'上次登录时间\',\r\n  `admin_status` int(1) NOT NULL COMMENT \'管理员状态\',\r\n  PRIMARY KEY (`admin_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for articles\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `articles`;\r\nCREATE TABLE `articles` (\r\n  `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'文章ID\',\r\n  `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\r\n  `article_title` text NOT NULL COMMENT \'文章标题\',\r\n  `article_resource` varchar(150) DEFAULT NULL COMMENT \'文章外链\',\r\n  `article_content_md` longtext COMMENT \'md格式\',\r\n  `article_content` longtext NOT NULL COMMENT \'文章内容\',\r\n  `article_views` bigint(20) DEFAULT NULL COMMENT \'文章浏览量\',\r\n  `article_likes` bigint(20) DEFAULT NULL COMMENT \'文章点赞数\',\r\n  `article_comments` bigint(20) DEFAULT NULL COMMENT \'文章评论数\',\r\n  `article_create_time` datetime NOT NULL COMMENT \'文章创建时间\',\r\n  `article_update_time` datetime NOT NULL COMMENT \'文章修改时间\',\r\n  `article_status` int(1) NOT NULL COMMENT \'文章状态\',\r\n  PRIMARY KEY (`article_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=69 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for article_label\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `article_label`;\r\nCREATE TABLE `article_label` (\r\n  `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\r\n  `label_id` bigint(20) NOT NULL COMMENT \'文章标签连接表ID\',\r\n  PRIMARY KEY (`article_id`,`label_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for article_sort\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `article_sort`;\r\nCREATE TABLE `article_sort` (\r\n  `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\r\n  `sort_id` bigint(20) NOT NULL COMMENT \'文章分类连接表ID\',\r\n  PRIMARY KEY (`article_id`,`sort_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for comments\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `comments`;\r\nCREATE TABLE `comments` (\r\n  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'评论ID\',\r\n  `parent_id` bigint(20) DEFAULT NULL COMMENT \'父评论ID\',\r\n  `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\r\n  `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\r\n  `comment_content` longtext NOT NULL COMMENT \'评论内容\',\r\n  `comment_likes` bigint(20) NOT NULL COMMENT \'评论点赞数\',\r\n  `comment_create_time` datetime NOT NULL COMMENT \'评论创建时间\',\r\n  `comment_status` int(1) NOT NULL COMMENT \'评论状态\',\r\n  PRIMARY KEY (`comment_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for labels\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `labels`;\r\nCREATE TABLE `labels` (\r\n  `label_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'标签ID\',\r\n  `label_name` varchar(50) NOT NULL COMMENT \'标签名\',\r\n  `label_alias` varchar(50) DEFAULT NULL COMMENT \'标签别名\',\r\n  `label_descripation` text COMMENT \'标签描述\',\r\n  `label_status` int(1) NOT NULL COMMENT \'标签状态\',\r\n  PRIMARY KEY (`label_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for messages\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `messages`;\r\nCREATE TABLE `messages` (\r\n  `message_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'留言ID\',\r\n  `parent_id` bigint(20) DEFAULT NULL,\r\n  `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\r\n  `message_content` longtext NOT NULL COMMENT \'留言内容\',\r\n  `message_create_time` datetime DEFAULT NULL COMMENT \'留言创建时间\',\r\n  `message_status` int(1) NOT NULL COMMENT \'留言状态\',\r\n  PRIMARY KEY (`message_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for sorts\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `sorts`;\r\nCREATE TABLE `sorts` (\r\n  `sort_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'分类ID\',\r\n  `parent_id` bigint(20) DEFAULT NULL COMMENT \'父分类ID\',\r\n  `sort_name` varchar(50) NOT NULL COMMENT \'分类名\',\r\n  `sort_alias` varchar(50) DEFAULT NULL COMMENT \'分类别名\',\r\n  `sort_descripation` text COMMENT \'分类描述\',\r\n  `sort_status` int(1) NOT NULL COMMENT \'分类状态\',\r\n  PRIMARY KEY (`sort_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for users\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `users`;\r\nCREATE TABLE `users` (\r\n  `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\r\n  `user_name` varchar(20) NOT NULL COMMENT \'用户名\',\r\n  `user_nickname` varchar(20) DEFAULT NULL COMMENT \'用户昵称\',\r\n  `user_password` varchar(15) NOT NULL COMMENT \'用户密码\',\r\n  `user_photo` varchar(255) DEFAULT NULL COMMENT \'用户头像\',\r\n  `user_sex` varchar(10) DEFAULT NULL COMMENT \'性别\',\r\n  `user_age` varchar(3) DEFAULT NULL COMMENT \'用户年龄\',\r\n  `user_email` varchar(30) NOT NULL COMMENT \'用户邮箱\',\r\n  `user_phone` varchar(11) NOT NULL COMMENT \'用户手机号\',\r\n  `user_create_time` datetime NOT NULL COMMENT \'注册时间\',\r\n  `user_login_time` datetime NOT NULL COMMENT \'上次登录时间\',\r\n  `user_status` int(1) NOT NULL COMMENT \'用户状态\',\r\n  PRIMARY KEY (`user_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;\r\n```\r\n', '<blockquote>\r\n<p>想要创建一个博客网站，首先的先设计数据库结构，本博客网站数据库设计表如下</p>\r\n</blockquote>\r\n<pre><code class=\"lang-sql\">/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : sunyue\r\nSource Server Version : 50724\r\nSource Host           : localhost:3306\r\nSource Database       : myblog\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50724\r\nFile Encoding         : 65001\r\n\r\nDate: 2020-10-22 22:55:38\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for admins\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `admins`;\r\nCREATE TABLE `admins` (\r\n  `admin_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'管理员ID\',\r\n  `admin_name` varchar(20) NOT NULL COMMENT \'管理员名\',\r\n  `admin_password` varchar(15) NOT NULL COMMENT \'管理员密码\',\r\n  `admin_photo` varchar(255) NOT NULL COMMENT \'管理员头像\',\r\n  `admin_email` varchar(30) NOT NULL COMMENT \'管理员邮箱\',\r\n  `admin_phone` varchar(11) NOT NULL COMMENT \'管理员手机号\',\r\n  `admin_create_time` datetime NOT NULL COMMENT \'注册时间\',\r\n  `admin_login_time` datetime NOT NULL COMMENT \'上次登录时间\',\r\n  `admin_status` int(1) NOT NULL COMMENT \'管理员状态\',\r\n  PRIMARY KEY (`admin_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for articles\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `articles`;\r\nCREATE TABLE `articles` (\r\n  `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'文章ID\',\r\n  `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\r\n  `article_title` text NOT NULL COMMENT \'文章标题\',\r\n  `article_resource` varchar(150) DEFAULT NULL COMMENT \'文章外链\',\r\n  `article_content_md` longtext COMMENT \'md格式\',\r\n  `article_content` longtext NOT NULL COMMENT \'文章内容\',\r\n  `article_views` bigint(20) DEFAULT NULL COMMENT \'文章浏览量\',\r\n  `article_likes` bigint(20) DEFAULT NULL COMMENT \'文章点赞数\',\r\n  `article_comments` bigint(20) DEFAULT NULL COMMENT \'文章评论数\',\r\n  `article_create_time` datetime NOT NULL COMMENT \'文章创建时间\',\r\n  `article_update_time` datetime NOT NULL COMMENT \'文章修改时间\',\r\n  `article_status` int(1) NOT NULL COMMENT \'文章状态\',\r\n  PRIMARY KEY (`article_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=69 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for article_label\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `article_label`;\r\nCREATE TABLE `article_label` (\r\n  `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\r\n  `label_id` bigint(20) NOT NULL COMMENT \'文章标签连接表ID\',\r\n  PRIMARY KEY (`article_id`,`label_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for article_sort\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `article_sort`;\r\nCREATE TABLE `article_sort` (\r\n  `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\r\n  `sort_id` bigint(20) NOT NULL COMMENT \'文章分类连接表ID\',\r\n  PRIMARY KEY (`article_id`,`sort_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for comments\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `comments`;\r\nCREATE TABLE `comments` (\r\n  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'评论ID\',\r\n  `parent_id` bigint(20) DEFAULT NULL COMMENT \'父评论ID\',\r\n  `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\r\n  `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\r\n  `comment_content` longtext NOT NULL COMMENT \'评论内容\',\r\n  `comment_likes` bigint(20) NOT NULL COMMENT \'评论点赞数\',\r\n  `comment_create_time` datetime NOT NULL COMMENT \'评论创建时间\',\r\n  `comment_status` int(1) NOT NULL COMMENT \'评论状态\',\r\n  PRIMARY KEY (`comment_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for labels\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `labels`;\r\nCREATE TABLE `labels` (\r\n  `label_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'标签ID\',\r\n  `label_name` varchar(50) NOT NULL COMMENT \'标签名\',\r\n  `label_alias` varchar(50) DEFAULT NULL COMMENT \'标签别名\',\r\n  `label_descripation` text COMMENT \'标签描述\',\r\n  `label_status` int(1) NOT NULL COMMENT \'标签状态\',\r\n  PRIMARY KEY (`label_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for messages\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `messages`;\r\nCREATE TABLE `messages` (\r\n  `message_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'留言ID\',\r\n  `parent_id` bigint(20) DEFAULT NULL,\r\n  `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\r\n  `message_content` longtext NOT NULL COMMENT \'留言内容\',\r\n  `message_create_time` datetime DEFAULT NULL COMMENT \'留言创建时间\',\r\n  `message_status` int(1) NOT NULL COMMENT \'留言状态\',\r\n  PRIMARY KEY (`message_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for sorts\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `sorts`;\r\nCREATE TABLE `sorts` (\r\n  `sort_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'分类ID\',\r\n  `parent_id` bigint(20) DEFAULT NULL COMMENT \'父分类ID\',\r\n  `sort_name` varchar(50) NOT NULL COMMENT \'分类名\',\r\n  `sort_alias` varchar(50) DEFAULT NULL COMMENT \'分类别名\',\r\n  `sort_descripation` text COMMENT \'分类描述\',\r\n  `sort_status` int(1) NOT NULL COMMENT \'分类状态\',\r\n  PRIMARY KEY (`sort_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Table structure for users\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `users`;\r\nCREATE TABLE `users` (\r\n  `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\r\n  `user_name` varchar(20) NOT NULL COMMENT \'用户名\',\r\n  `user_nickname` varchar(20) DEFAULT NULL COMMENT \'用户昵称\',\r\n  `user_password` varchar(15) NOT NULL COMMENT \'用户密码\',\r\n  `user_photo` varchar(255) DEFAULT NULL COMMENT \'用户头像\',\r\n  `user_sex` varchar(10) DEFAULT NULL COMMENT \'性别\',\r\n  `user_age` varchar(3) DEFAULT NULL COMMENT \'用户年龄\',\r\n  `user_email` varchar(30) NOT NULL COMMENT \'用户邮箱\',\r\n  `user_phone` varchar(11) NOT NULL COMMENT \'用户手机号\',\r\n  `user_create_time` datetime NOT NULL COMMENT \'注册时间\',\r\n  `user_login_time` datetime NOT NULL COMMENT \'上次登录时间\',\r\n  `user_status` int(1) NOT NULL COMMENT \'用户状态\',\r\n  PRIMARY KEY (`user_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;\r\n</code></pre>\r\n', null, null, null, '2020-10-22 22:58:34', '2020-10-22 22:58:34', '1');
INSERT INTO `articles` VALUES ('74', '1', '有关redis', '', '> 引言\r\n\r\n在Web应用发展的初期，那时关系型数据库受到了较为广泛的关注和应用，原因是因为那时候Web站点基本上访问和并发不高、交互也较少。而在后来，随着访问量的提升，使用关系型数据库的Web站点多多少少都开始在性能上出现了一些瓶颈，而瓶颈的源头一般是在磁盘的I/O上。而随着互联网技术的进一步发展，各种类型的应用层出不穷，这导致在当今云计算、大数据盛行的时代，对性能有了更多的需求，主要体现在以下四个方面：\r\n\r\n1.低延迟的读写速度：应用快速地反应能极大地提升用户的满意度\r\n2.支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量\r\n3.大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理\r\n3.庞大运营成本的考量：IT部门希望在硬件成本、软件成本和人力成本能够有大幅度地降低\r\n\r\n\r\n为了克服这一问题，NoSQL应运而生，它同时具备了高性能、可扩展性强、高可用等优点，受到广泛开发人员和仓库管理人员的青睐。\r\n\r\n### Redis是什么\r\nRedis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的\r\n\r\n#### 键值对存储数据库，其具备如下特性：\r\n1.基于内存运行，性能高效\r\n2.支持分布式，理论上可以无限扩展\r\n3.key-value存储系统\r\n4.开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存5亦可持久化的日志型、Key-Value数据库，并提供多种语言的API\r\n\r\n#### 相比于其他数据库类型，Redis具备的特点是：\r\n1.C/S通讯模型\r\n2.单进程单线程模型\r\n3.丰富的数据类型\r\n4.操作具有原子性\r\n5.持久化\r\n6.高并发读写\r\n7.支持lua脚本\r\n\r\n#### 哪些大厂在使用Redis？\r\n1.github\r\n2.twitter\r\n3.微博\r\n4.Stack Overflow\r\n5.阿里巴巴\r\n6.百度\r\n7.美团\r\n8.搜狐', '<blockquote>\r\n<p>引言</p>\r\n</blockquote>\r\n<p>在Web应用发展的初期，那时关系型数据库受到了较为广泛的关注和应用，原因是因为那时候Web站点基本上访问和并发不高、交互也较少。而在后来，随着访问量的提升，使用关系型数据库的Web站点多多少少都开始在性能上出现了一些瓶颈，而瓶颈的源头一般是在磁盘的I/O上。而随着互联网技术的进一步发展，各种类型的应用层出不穷，这导致在当今云计算、大数据盛行的时代，对性能有了更多的需求，主要体现在以下四个方面：</p>\r\n<p>1.低延迟的读写速度：应用快速地反应能极大地提升用户的满意度<br>2.支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量<br>3.大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理<br>3.庞大运营成本的考量：IT部门希望在硬件成本、软件成本和人力成本能够有大幅度地降低\r\n<p>为了克服这一问题，NoSQL应运而生，它同时具备了高性能、可扩展性强、高可用等优点，受到广泛开发人员和仓库管理人员的青睐。</p>\r\n<h3 id=\"h3-redis-\"><a name=\"Redis是什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis是什么</h3><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的</p>\r\n<h4 id=\"h4--\"><a name=\"键值对存储数据库，其具备如下特性：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>键值对存储数据库，其具备如下特性：</h4><p>1.基于内存运行，性能高效<br>2.支持分布式，理论上可以无限扩展<br>3.key-value存储系统<br>4.开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存5亦可持久化的日志型、Key-Value数据库，并提供多种语言的API\r\n<h4 id=\"h4--redis-\"><a name=\"相比于其他数据库类型，Redis具备的特点是：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>相比于其他数据库类型，Redis具备的特点是：</h4><p>1.C/S通讯模型<br>2.单进程单线程模型<br>3.丰富的数据类型<br>4.操作具有原子性<br>5.持久化<br>6.高并发读写<br>7.支持lua脚本\r\n<h4 id=\"h4--redis-\"><a name=\"哪些大厂在使用Redis？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>哪些大厂在使用Redis？</h4><p>1.github<br>2.twitter<br>3.微博<br>4.Stack Overflow<br>5.阿里巴巴<br>6.百度<br>7.美团<br>8.搜狐\r\n', null, null, null, '2020-11-03 20:56:16', '2020-11-03 20:58:22', '1');
INSERT INTO `articles` VALUES ('75', '1', 'redis常用数据类型---String字符串', '', '#### 语法：\r\n`SET key value [EX seconds] [PX milliseconds] [NX|XX]`\r\n#### 说明：\r\n将字符串值 **value** 关联到** key** 。\r\n如果 **key **已经持有其他值，** SET **就覆写旧值， 无视类型。\r\n当 **SET** 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的** TTL **将被清除。\r\n#### 可选参数：\r\n从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：\r\n`EX seconds` ： 将键的过期时间设置为 seconds 秒。 执行 `SET key value EX seconds `的效果等同于执行 `SETEX key seconds value` 。\r\n`PX milliseconds `： 将键的过期时间设置为 milliseconds 毫秒。 执行` SET key value PX milliseconds` 的效果等同于执行 `PSETEX key milliseconds value` 。\r\n`NX` ： 只在键不存在时， 才对键进行设置操作。 执行 `SET key value NX` 的效果等同于执行 `SETNX key value` 。\r\n`XX` ： 只在键已经存在时， 才对键进行设置操作。\r\n> 因为 SET 命令可以通过参数来实现 SETNX 、 SETEX 以及 PSETEX 命令的效果， 所以 Redis 将来的版本可能会移除并废弃 SETNX 、 SETEX 和 PSETEX 这三个命令。\r\n\r\n#### 返回值\r\n在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。\r\n从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK ； 如果命令使用了 NX 或者 XX 选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。\r\n#### 代码示例\r\n对不存在的键进行设置：\r\n```shell\r\nredis> SET key \"value\"\r\nOK\r\nredis> GET key\r\n\"value\"\r\n```\r\n对已存在的键进行设置：\r\n```shell\r\nredis> SET key \"new-value\"\r\nOK\r\nredis> GET key\r\n\"new-value\"\r\n```\r\n使用 EX 选项：\r\n```shell\r\nredis> SET key-with-expire-time \"hello\" EX 10086\r\nOK\r\nredis> GET key-with-expire-time\r\n\"hello\"\r\nredis> TTL key-with-expire-time\r\n(integer) 10069\r\n```\r\n使用 PX 选项：\r\n```shell\r\nredis> SET key-with-pexpire-time \"moto\" PX 123321\r\nOK\r\nredis> GET key-with-pexpire-time\r\n\"moto\"\r\nredis> PTTL key-with-pexpire-time\r\n(integer) 111939\r\n```\r\n使用 NX 选项：\r\n```shell\r\nredis> SET not-exists-key \"value\" NX\r\nOK      # 键不存在，设置成功\r\nredis> GET not-exists-key\r\n\"value\"\r\nredis> SET not-exists-key \"new-value\" NX\r\n(nil)   # 键已经存在，设置失败\r\nredis> GEt not-exists-key\r\n\"value\" # 维持原值不变\r\n```\r\n使用 XX 选项：\r\n```shell\r\nredis> EXISTS exists-key\r\n(integer) 0\r\nredis> SET exists-key \"value\" XX\r\n(nil)   # 因为键不存在，设置失败\r\nredis> SET exists-key \"value\"\r\nOK      # 先给键设置一个值\r\nredis> SET exists-key \"new-value\" XX\r\nOK      # 设置新值成功\r\nredis> GET exists-key\r\n\"new-value\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`SETNX key value`\r\n#### 说明：\r\n只在键 **key** 不存在的情况下， 将键 **key** 的值设置为 **value** 。\r\n若键 **key** 已经存在， 则 **SETNX** 命令不做任何动作。\r\n**SETNX** 是『`SET if Not eXists`』(如果不存在，则 **SET**)的简写\r\n#### 返回值\r\n命令在设置成功时返回 1 ， 设置失败时返回 0 \r\n#### 代码示例\r\n```shell\r\nredis> EXISTS job                # job 不存在\r\n(integer) 0\r\nredis> SETNX job \"programmer\"    # job 设置成功\r\n(integer) 1\r\nredis> SETNX job \"code-farmer\"   # 尝试覆盖 job ，失败\r\n(integer) 0\r\nredis> GET job                   # 没有被覆盖\r\n\"programmer\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`SETEX key seconds value`\r\n#### 说明：\r\n将键 **key** 的值设置为 **value** ， 并将键 **key** 的生存时间设置为 **seconds** 秒钟。\r\n如果键 **key** 已经存在， 那么 SETEX 命令将覆盖已有的值。\r\n**SETEX** 命令的效果和以下两个命令的效果类似：\r\n```shell\r\nSET key value\r\nEXPIRE key seconds  # 设置生存时间\r\n```\r\n**SETEX** 和这两个命令的不同之处在于 **SETEX** 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 **SETEX** 命令在储存缓存的时候非常实用。\r\n#### 返回值\r\n命令在设置成功时返回 OK 。 当 seconds 参数不合法时， 命令将返回一个错误。\r\n#### 代码示例\r\n在键 key 不存在的情况下执行 SETEX ：\r\n```shell\r\nredis> SETEX cache_user_id 60 10086\r\nOK\r\nredis> GET cache_user_id  # 值\r\n\"10086\"\r\nredis> TTL cache_user_id  # 剩余生存时间\r\n(integer) 49\r\n```\r\n键 key 已经存在， 使用 SETEX 覆盖旧值：\r\n```shell\r\nredis> SET cd \"timeless\"\r\nOK\r\nredis> SETEX cd 3000 \"goodbye my love\"\r\nOK\r\nredis> GET cd\r\n\"goodbye my love\"\r\nredis> TTL cd\r\n(integer) 2997\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`PSETEX key milliseconds value`\r\n#### 说明：\r\n这个命令和 **SETEX** 命令相似， 但它以毫秒为单位设置 **key** 的生存时间， 而不是像 **SETEX** 命令那样以秒为单位进行设置。\r\n#### 返回值\r\n命令在设置成功时返回 OK\r\n#### 代码示例\r\n```shell\r\nredis> PSETEX mykey 1000 \"Hello\"\r\nOK\r\nredis> PTTL mykey\r\n(integer) 999\r\nredis> GET mykey\r\n\"Hello\"\r\n```\r\n\r\n------------\r\n\r\n\r\n#### 语法：\r\n`GET key`\r\n#### 说明：\r\n返回与键 **key** 相关联的字符串值。\r\n#### 返回值\r\n如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值。\r\n如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。\r\n#### 代码示例\r\n对不存在的键 key 或是字符串类型的键 key 执行 GET 命令：\r\n```shell\r\nredis> GET db\r\n(nil)\r\nredis> SET db redis\r\nOK\r\nredis> GET db\r\n\"redis\"\r\n```\r\n对不是字符串类型的键 key 执行 GET 命令：\r\n```shell\r\nredis> DEL db\r\n(integer) 1\r\nredis> LPUSH db redis mongodb mysql\r\n(integer) 3\r\nredis> GET db\r\n(error) ERR Operation against a key holding the wrong kind of value\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`GETSET key value`\r\n#### 说明：\r\n将键 **key** 的值设为 **value** ， 并返回键 **key** 在被设置之前的旧值\r\n#### 返回值\r\n返回给定键 key 的旧值。\r\n如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 。\r\n当键 key 存在但不是字符串类型时， 命令返回一个错误。\r\n#### 代码示例\r\n```shell\r\nredis> GETSET db mongodb    # 没有旧值，返回 nil\r\n(nil)\r\nredis> GET db\r\n\"mongodb\"\r\nredis> GETSET db redis      # 返回旧值 mongodb\r\n\"mongodb\"\r\nredis> GET db\r\n\"redis\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`STRLEN key`\r\n#### 说明：\r\n返回键 **key** 储存的字符串值的长度\r\n#### 返回值\r\nSTRLEN 命令返回字符串值的长度。\r\n当键 key 不存在时， 命令返回 0 。\r\n当 key 储存的不是字符串值时， 返回一个错误。\r\n#### 代码示例\r\n获取字符串值的长度：\r\n```shell\r\nredis> SET mykey \"Hello world\"\r\nOK\r\nredis> STRLEN mykey\r\n(integer) 11\r\n```\r\n不存在的键的长度为 0 ：\r\n```shell\r\nredis> STRLEN nonexisting\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`APPEND key value`\r\n#### 说明：\r\n如果键 **key** 已经存在并且它的值是一个字符串， **APPEND** 命令将把 **value** 追加到键 key 现有值的末尾。\r\n如果 **key** 不存在， **APPEND** 就简单地将键 **key** 的值设为 **value** ， 就像执行 `SET key value` 一样。\r\n#### 返回值\r\n追加 value 之后， 键 key 的值的长度。\r\n#### 示例代码\r\n对不存在的 key 执行 APPEND ：\r\n```shell\r\nredis> EXISTS myphone               # 确保 myphone 不存在\r\n(integer) 0\r\nredis> APPEND myphone \"nokia\"       # 对不存在的 key 进行 APPEND ，等同于 SET myphone \"nokia\"\r\n(integer) 5                         # 字符长度\r\n```\r\n对已存在的字符串进行 APPEND ：\r\n```shell\r\nredis> APPEND myphone \" - 1110\"     # 长度从 5 个字符增加到 12 个字符\r\n(integer) 12\r\nredis> GET myphone\r\n\"nokia - 1110\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`SETRANGE key offset value`\r\n#### 说明：\r\n从偏移量 **offset** 开始， 用 **value** 参数覆写(overwrite)键 **key** 储存的字符串值。\r\n不存在的键 **key** 当作空白字符串处理。\r\n**SETRANGE** 命令会确保字符串足够长以便将 **value** 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 **offset** 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, \"\\x00\" )进行填充。\r\n因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。\r\n\r\n> Warning\r\n当生成一个很长的字符串时， Redis 需要分配内存空间， 该操作有时候可能会造成服务器阻塞(block)。 在2010年出产的Macbook Pro上， 设置偏移量为 536870911(512MB 内存分配)将耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)将耗费约 80 毫秒， 设置偏移量 33554432(32MB 内存分配)将耗费约 30 毫秒， 设置偏移量为 8388608(8MB 内存分配)将耗费约 8 毫秒。\r\n\r\n#### 返回值\r\nSETRANGE 命令会返回被修改之后， 字符串值的长度。\r\n#### 代码示例\r\n对非空字符串执行 SETRANGE 命令：\r\n```shell\r\nredis> SET greeting \"hello world\"\r\nOK\r\nredis> SETRANGE greeting 6 \"Redis\"\r\n(integer) 11\r\nredis> GET greeting\r\n\"hello Redis\"\r\n```\r\n对空字符串/不存在的键执行 SETRANGE 命令：\r\n```shell\r\nredis> EXISTS empty_string\r\n(integer) 0\r\nredis> SETRANGE empty_string 5 \"Redis!\"   # 对不存在的 key 使用 SETRANGE\r\n(integer) 11\r\nredis> GET empty_string                   # 空白处被\"\\x00\"填充\r\n\"\\x00\\x00\\x00\\x00\\x00Redis!\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`GETRANGE key start end`\r\n#### 说明：\r\n返回键 **key** 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。\r\n负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。\r\n**GETRANGE** 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。\r\n\r\n> Note\r\nGETRANGE 命令在 Redis 2.0 之前的版本里面被称为 SUBSTR 命令。\r\n\r\n#### 返回值\r\nGETRANGE 命令会返回字符串值的指定部分。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SET greeting \"hello, my friend\"\r\nOK\r\nredis> GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。\r\n\"hello\"\r\nredis> GETRANGE greeting -1 -5        # 不支持回绕操作\r\n\"\"\r\nredis> GETRANGE greeting -3 -1        # 负数索引\r\n\"end\"\r\nredis> GETRANGE greeting 0 -1         # 从第一个到最后一个\r\n\"hello, my friend\"\r\nredis> GETRANGE greeting 0 1008611    # 值域范围不超过实际字符串，超过部分自动被符略\r\n\"hello, my friend\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`INCR key`\r\n#### 说明：\r\n为键 **key** 储存的数字值加上一。\r\n如果键 **key** 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 **INCR** 命令。\r\n如果键 **key** 储存的值不能被解释为数字， 那么 **INCR** 命令将返回一个错误。\r\n本操作的值限制在 64 位(bit)有符号数字表示之内。\r\n\r\n> Note\r\nINCR 命令是一个针对字符串的操作。 因为 Redis 并没有专用的整数类型， 所以键 key 储存的值在执行 INCR 命令时会被解释为十进制 64 位有符号整数。\r\n\r\n#### 返回值\r\nINCR 命令会返回键 key 在执行加一操作之后的值。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SET page_view 20\r\nOK\r\nredis> INCR page_view\r\n(integer) 21\r\nredis> GET page_view    # 数字值在 Redis 中以字符串的形式保存\r\n\"21\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`INCRBY key increment`\r\n#### 说明：\r\n为键 **key** 储存的数字值加上增量 **increment** 。\r\n如果键 **key** 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 **INCRBY** 命令。\r\n如果键 **key** 储存的值不能被解释为数字， 那么 **INCRBY** 命令将返回一个错误。\r\n本操作的值限制在 64 位(bit)有符号数字表示之内。\r\n关于递增(increment) / 递减(decrement)操作的更多信息， 请参见 INCR 命令的文档。\r\n\r\n#### 返回值\r\n在加上增量 increment 之后， 键 key 当前的值。\r\n\r\n#### 代码示例\r\n键存在，并且值为数字：\r\n```shell\r\nredis> SET rank 50\r\nOK\r\nredis> INCRBY rank 20\r\n(integer) 70\r\nredis> GET rank\r\n\"70\"\r\n```\r\n键不存在：\r\n```shell\r\nredis> EXISTS counter\r\n(integer) 0\r\nredis> INCRBY counter 30\r\n(integer) 30\r\nredis> GET counter\r\n\"30\"\r\n```\r\n键存在，但值无法被解释为数字：\r\n```shell\r\nredis> SET book \"long long ago...\"\r\nOK\r\nredis> INCRBY book 200\r\n(error) ERR value is not an integer or out of range\r\n```\r\n\r\n\r\n------------\r\n\r\n#### 语法：\r\n`INCRBYFLOAT key increment`\r\n#### 说明：\r\n为键 **key** 储存的值加上浮点数增量 increment 。\r\n如果键 **key** 不存在， 那么 **INCRBYFLOAT** 会先将键 **key** 的值设为 0 ， 然后再执行加法操作。\r\n\r\n如果命令执行成功， 那么键 **key** 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。\r\n\r\n无论是键 **key** 的值还是增量 **increment** ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 **INCRBYFLOAT** 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。\r\n\r\n此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。\r\n\r\n当以下任意一个条件发生时， 命令返回一个错误：\r\n\r\n1.键 **key** 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）；\r\n\r\n2.键 **key** 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。\r\n\r\n#### 返回值\r\n在加上增量 increment 之后， 键 key 的值。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> GET decimal\r\n\"3.0\"\r\nredis> INCRBYFLOAT decimal 2.56\r\n\"5.56\"\r\nredis> GET decimal\r\n\"5.56\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`DECR key`\r\n#### 说明：\r\n为键 **key** 储存的数字值减去一。\r\n如果键 **key** 不存在， 那么键 **key** 的值会先被初始化为 0 ， 然后再执行 DECR 操作。\r\n如果键 **key** 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。\r\n本操作的值限制在 64 位(bit)有符号数字表示之内。\r\n关于递增(increment) / 递减(decrement)操作的更多信息， 请参见 **INCR** 命令的文档。\r\n\r\n#### 返回值\r\nDECR 命令会返回键 key 在执行减一操作之后的值。\r\n\r\n#### 代码示例\r\n对储存数字值的键 key 执行 DECR 命令：\r\n\r\n```shell\r\nredis> SET failure_times 10\r\nOK\r\nredis> DECR failure_times\r\n(integer) 9\r\n对不存在的键执行 DECR 命令：\r\nredis> EXISTS count\r\n(integer) 0\r\nredis> DECR count\r\n(integer) -1\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`DECRBY key decrement`\r\n#### 说明:\r\n将键 **key** 储存的整数值减去减量 **decrement** 。\r\n如果键 **key** 不存在， 那么键 **key** 的值会先被初始化为 0 ， 然后再执行 **DECRBY** 命令。\r\n如果键 key 储存的值不能被解释为数字， 那么 **DECRBY** 命令将返回一个错误。\r\n本操作的值限制在 64 位(bit)有符号数字表示之内。\r\n关于更多递增(increment) / 递减(decrement)操作的更多信息， 请参见 **INCR** 命令的文档。\r\n\r\n#### 返回值\r\nDECRBY 命令会返回键在执行减法操作之后的值。\r\n\r\n#### 代码示例\r\n对已经存在的键执行 DECRBY 命令：\r\n```shell\r\nredis> SET count 100\r\nOK\r\nredis> DECRBY count 20\r\n(integer) 80\r\n```\r\n对不存在的键执行 DECRBY 命令：\r\n```shell\r\nredis> EXISTS pages\r\n(integer) 0\r\nredis> DECRBY pages 10\r\n(integer) -10\r\n```\r\n\r\n\r\n------------\r\n\r\n#### 语法：\r\n`MSET key value [key value …]`\r\n#### 说明：\r\n同时为多个键设置值。\r\n如果某个给定键已经存在， 那么 **MSET** 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 **MSETNX** 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。\r\nMSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。\r\n\r\n#### 返回值\r\nMSET 命令总是返回 OK 。\r\n\r\n#### 代码示例\r\n同时对多个键进行设置：\r\n```shell\r\nredis> MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\"\r\nOK\r\nredis> MGET date time weather\r\n1) \"2012.3.30\"\r\n2) \"11:00 a.m.\"\r\n3) \"sunny\"\r\n```\r\n覆盖已有的值：\r\n```shell\r\nredis> MGET k1 k2\r\n1) \"hello\"\r\n2) \"world\"\r\nredis> MSET k1 \"good\" k2 \"bye\"\r\nOK\r\nredis> MGET k1 k2\r\n1) \"good\"\r\n2) \"bye\"\r\n```\r\n\r\n------------\r\n\r\n#### 语法：\r\n`MSETNX key value [key value …]`\r\n#### 说明：\r\n当且仅当所有给定键都不存在时， 为所有给定键设置值。\r\n即使只有一个给定键已经存在， **MSETNX** 命令也会拒绝执行对所有键的设置操作。\r\n**MSETNX** 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。\r\n\r\n#### 返回值\r\n当所有给定键都设置成功时， 命令返回 1 ； 如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。\r\n\r\n#### 代码示例\r\n对不存在的键执行 MSETNX 命令：\r\n\r\n```shell\r\nredis> MSETNX rmdbs \"MySQL\" nosql \"MongoDB\" key-value-store \"redis\"\r\n(integer) 1\r\nredis> MGET rmdbs nosql key-value-store\r\n1) \"MySQL\"\r\n2) \"MongoDB\"\r\n3) \"redis\"\r\n```\r\n对某个已经存在的键进行设置：\r\n```shell\r\nredis> MSETNX rmdbs \"Sqlite\" language \"python\"  # rmdbs 键已经存在，操作失败\r\n(integer) 0\r\nredis> EXISTS language                          # 因为 MSETNX 命令没有成功执行\r\n(integer) 0                                     # 所以 language 键没有被设置\r\nredis> GET rmdbs                                # rmdbs 键也没有被修改\r\n\"MySQL\"\r\n```\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>将字符串值 <strong>value</strong> 关联到<strong> key</strong> 。<br>如果 <strong>key </strong>已经持有其他值，<strong> SET </strong>就覆写旧值， 无视类型。<br>当 <strong>SET</strong> 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的<strong> TTL </strong>将被清除。</p>\r\n<h4 id=\"h4--\"><a name=\"可选参数：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>可选参数：</h4><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：<br><code>EX seconds</code> ： 将键的过期时间设置为 seconds 秒。 执行 <code>SET key value EX seconds</code>的效果等同于执行 <code>SETEX key seconds value</code> 。<br><code>PX milliseconds</code>： 将键的过期时间设置为 milliseconds 毫秒。 执行<code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code> 。<br><code>NX</code> ： 只在键不存在时， 才对键进行设置操作。 执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code> 。<br><code>XX</code> ： 只在键已经存在时， 才对键进行设置操作。</p>\r\n<blockquote>\r\n<p>因为 SET 命令可以通过参数来实现 SETNX 、 SETEX 以及 PSETEX 命令的效果， 所以 Redis 将来的版本可能会移除并废弃 SETNX 、 SETEX 和 PSETEX 这三个命令。</p>\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。<br>从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK ； 如果命令使用了 NX 或者 XX 选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>对不存在的键进行设置：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET key \"value\"\r\nOK\r\nredis&gt; GET key\r\n\"value\"\r\n</code></pre>\r\n<p>对已存在的键进行设置：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET key \"new-value\"\r\nOK\r\nredis&gt; GET key\r\n\"new-value\"\r\n</code></pre>\r\n<p>使用 EX 选项：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET key-with-expire-time \"hello\" EX 10086\r\nOK\r\nredis&gt; GET key-with-expire-time\r\n\"hello\"\r\nredis&gt; TTL key-with-expire-time\r\n(integer) 10069\r\n</code></pre>\r\n<p>使用 PX 选项：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET key-with-pexpire-time \"moto\" PX 123321\r\nOK\r\nredis&gt; GET key-with-pexpire-time\r\n\"moto\"\r\nredis&gt; PTTL key-with-pexpire-time\r\n(integer) 111939\r\n</code></pre>\r\n<p>使用 NX 选项：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET not-exists-key \"value\" NX\r\nOK      # 键不存在，设置成功\r\nredis&gt; GET not-exists-key\r\n\"value\"\r\nredis&gt; SET not-exists-key \"new-value\" NX\r\n(nil)   # 键已经存在，设置失败\r\nredis&gt; GEt not-exists-key\r\n\"value\" # 维持原值不变\r\n</code></pre>\r\n<p>使用 XX 选项：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS exists-key\r\n(integer) 0\r\nredis&gt; SET exists-key \"value\" XX\r\n(nil)   # 因为键不存在，设置失败\r\nredis&gt; SET exists-key \"value\"\r\nOK      # 先给键设置一个值\r\nredis&gt; SET exists-key \"new-value\" XX\r\nOK      # 设置新值成功\r\nredis&gt; GET exists-key\r\n\"new-value\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>SETNX key value</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>只在键 <strong>key</strong> 不存在的情况下， 将键 <strong>key</strong> 的值设置为 <strong>value</strong> 。<br>若键 <strong>key</strong> 已经存在， 则 <strong>SETNX</strong> 命令不做任何动作。<br><strong>SETNX</strong> 是『<code>SET if Not eXists</code>』(如果不存在，则 <strong>SET</strong>)的简写</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>命令在设置成功时返回 1 ， 设置失败时返回 0 </p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; EXISTS job                # job 不存在\r\n(integer) 0\r\nredis&gt; SETNX job \"programmer\"    # job 设置成功\r\n(integer) 1\r\nredis&gt; SETNX job \"code-farmer\"   # 尝试覆盖 job ，失败\r\n(integer) 0\r\nredis&gt; GET job                   # 没有被覆盖\r\n\"programmer\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>SETEX key seconds value</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>将键 <strong>key</strong> 的值设置为 <strong>value</strong> ， 并将键 <strong>key</strong> 的生存时间设置为 <strong>seconds</strong> 秒钟。<br>如果键 <strong>key</strong> 已经存在， 那么 SETEX 命令将覆盖已有的值。<br><strong>SETEX</strong> 命令的效果和以下两个命令的效果类似：</p>\r\n<pre><code class=\"lang-shell\">SET key value\r\nEXPIRE key seconds  # 设置生存时间\r\n</code></pre>\r\n<p><strong>SETEX</strong> 和这两个命令的不同之处在于 <strong>SETEX</strong> 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 <strong>SETEX</strong> 命令在储存缓存的时候非常实用。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>命令在设置成功时返回 OK 。 当 seconds 参数不合法时， 命令将返回一个错误。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>在键 key 不存在的情况下执行 SETEX ：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SETEX cache_user_id 60 10086\r\nOK\r\nredis&gt; GET cache_user_id  # 值\r\n\"10086\"\r\nredis&gt; TTL cache_user_id  # 剩余生存时间\r\n(integer) 49\r\n</code></pre>\r\n<p>键 key 已经存在， 使用 SETEX 覆盖旧值：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET cd \"timeless\"\r\nOK\r\nredis&gt; SETEX cd 3000 \"goodbye my love\"\r\nOK\r\nredis&gt; GET cd\r\n\"goodbye my love\"\r\nredis&gt; TTL cd\r\n(integer) 2997\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>PSETEX key milliseconds value</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>这个命令和 <strong>SETEX</strong> 命令相似， 但它以毫秒为单位设置 <strong>key</strong> 的生存时间， 而不是像 <strong>SETEX</strong> 命令那样以秒为单位进行设置。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>命令在设置成功时返回 OK</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; PSETEX mykey 1000 \"Hello\"\r\nOK\r\nredis&gt; PTTL mykey\r\n(integer) 999\r\nredis&gt; GET mykey\r\n\"Hello\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>GET key</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>返回与键 <strong>key</strong> 相关联的字符串值。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值。<br>如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>对不存在的键 key 或是字符串类型的键 key 执行 GET 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; GET db\r\n(nil)\r\nredis&gt; SET db redis\r\nOK\r\nredis&gt; GET db\r\n\"redis\"\r\n</code></pre>\r\n<p>对不是字符串类型的键 key 执行 GET 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; DEL db\r\n(integer) 1\r\nredis&gt; LPUSH db redis mongodb mysql\r\n(integer) 3\r\nredis&gt; GET db\r\n(error) ERR Operation against a key holding the wrong kind of value\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>GETSET key value</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>将键 <strong>key</strong> 的值设为 <strong>value</strong> ， 并返回键 <strong>key</strong> 在被设置之前的旧值</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>返回给定键 key 的旧值。<br>如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 。<br>当键 key 存在但不是字符串类型时， 命令返回一个错误。\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GETSET db mongodb    # 没有旧值，返回 nil\r\n(nil)\r\nredis&gt; GET db\r\n\"mongodb\"\r\nredis&gt; GETSET db redis      # 返回旧值 mongodb\r\n\"mongodb\"\r\nredis&gt; GET db\r\n\"redis\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>STRLEN key</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>返回键 <strong>key</strong> 储存的字符串值的长度</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>STRLEN 命令返回字符串值的长度。<br>当键 key 不存在时， 命令返回 0 。<br>当 key 储存的不是字符串值时， 返回一个错误。\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>获取字符串值的长度：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET mykey \"Hello world\"\r\nOK\r\nredis&gt; STRLEN mykey\r\n(integer) 11\r\n</code></pre>\r\n<p>不存在的键的长度为 0 ：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; STRLEN nonexisting\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>APPEND key value</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>如果键 <strong>key</strong> 已经存在并且它的值是一个字符串， <strong>APPEND</strong> 命令将把 <strong>value</strong> 追加到键 key 现有值的末尾。<br>如果 <strong>key</strong> 不存在， <strong>APPEND</strong> 就简单地将键 <strong>key</strong> 的值设为 <strong>value</strong> ， 就像执行 <code>SET key value</code> 一样。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>追加 value 之后， 键 key 的值的长度。</p>\r\n<h4 id=\"h4-u793Au4F8Bu4EE3u7801\"><a name=\"示例代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>示例代码</h4><p>对不存在的 key 执行 APPEND ：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS myphone               # 确保 myphone 不存在\r\n(integer) 0\r\nredis&gt; APPEND myphone \"nokia\"       # 对不存在的 key 进行 APPEND ，等同于 SET myphone \"nokia\"\r\n(integer) 5                         # 字符长度\r\n</code></pre>\r\n<p>对已存在的字符串进行 APPEND ：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; APPEND myphone \" - 1110\"     # 长度从 5 个字符增加到 12 个字符\r\n(integer) 12\r\nredis&gt; GET myphone\r\n\"nokia - 1110\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>SETRANGE key offset value</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>从偏移量 <strong>offset</strong> 开始， 用 <strong>value</strong> 参数覆写(overwrite)键 <strong>key</strong> 储存的字符串值。<br>不存在的键 <strong>key</strong> 当作空白字符串处理。<br><strong>SETRANGE</strong> 命令会确保字符串足够长以便将 <strong>value</strong> 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 <strong>offset</strong> 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, “\\x00” )进行填充。<br>因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。\r\n<blockquote>\r\n<p>Warning<br>当生成一个很长的字符串时， Redis 需要分配内存空间， 该操作有时候可能会造成服务器阻塞(block)。 在2010年出产的Macbook Pro上， 设置偏移量为 536870911(512MB 内存分配)将耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)将耗费约 80 毫秒， 设置偏移量 33554432(32MB 内存分配)将耗费约 30 毫秒， 设置偏移量为 8388608(8MB 内存分配)将耗费约 8 毫秒。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>SETRANGE 命令会返回被修改之后， 字符串值的长度。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>对非空字符串执行 SETRANGE 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET greeting \"hello world\"\r\nOK\r\nredis&gt; SETRANGE greeting 6 \"Redis\"\r\n(integer) 11\r\nredis&gt; GET greeting\r\n\"hello Redis\"\r\n</code></pre>\r\n<p>对空字符串/不存在的键执行 SETRANGE 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS empty_string\r\n(integer) 0\r\nredis&gt; SETRANGE empty_string 5 \"Redis!\"   # 对不存在的 key 使用 SETRANGE\r\n(integer) 11\r\nredis&gt; GET empty_string                   # 空白处被\"\\x00\"填充\r\n\"\\x00\\x00\\x00\\x00\\x00Redis!\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>GETRANGE key start end</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>返回键 <strong>key</strong> 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。<br>负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。<br><strong>GETRANGE</strong> 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p>\r\n<blockquote>\r\n<p>Note<br>GETRANGE 命令在 Redis 2.0 之前的版本里面被称为 SUBSTR 命令。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>GETRANGE 命令会返回字符串值的指定部分。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SET greeting \"hello, my friend\"\r\nOK\r\nredis&gt; GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。\r\n\"hello\"\r\nredis&gt; GETRANGE greeting -1 -5        # 不支持回绕操作\r\n\"\"\r\nredis&gt; GETRANGE greeting -3 -1        # 负数索引\r\n\"end\"\r\nredis&gt; GETRANGE greeting 0 -1         # 从第一个到最后一个\r\n\"hello, my friend\"\r\nredis&gt; GETRANGE greeting 0 1008611    # 值域范围不超过实际字符串，超过部分自动被符略\r\n\"hello, my friend\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>INCR key</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>为键 <strong>key</strong> 储存的数字值加上一。<br>如果键 <strong>key</strong> 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 <strong>INCR</strong> 命令。<br>如果键 <strong>key</strong> 储存的值不能被解释为数字， 那么 <strong>INCR</strong> 命令将返回一个错误。<br>本操作的值限制在 64 位(bit)有符号数字表示之内。\r\n<blockquote>\r\n<p>Note<br>INCR 命令是一个针对字符串的操作。 因为 Redis 并没有专用的整数类型， 所以键 key 储存的值在执行 INCR 命令时会被解释为十进制 64 位有符号整数。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>INCR 命令会返回键 key 在执行加一操作之后的值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SET page_view 20\r\nOK\r\nredis&gt; INCR page_view\r\n(integer) 21\r\nredis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存\r\n\"21\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>INCRBY key increment</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>为键 <strong>key</strong> 储存的数字值加上增量 <strong>increment</strong> 。<br>如果键 <strong>key</strong> 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 <strong>INCRBY</strong> 命令。<br>如果键 <strong>key</strong> 储存的值不能被解释为数字， 那么 <strong>INCRBY</strong> 命令将返回一个错误。<br>本操作的值限制在 64 位(bit)有符号数字表示之内。<br>关于递增(increment) / 递减(decrement)操作的更多信息， 请参见 INCR 命令的文档。\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>在加上增量 increment 之后， 键 key 当前的值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>键存在，并且值为数字：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET rank 50\r\nOK\r\nredis&gt; INCRBY rank 20\r\n(integer) 70\r\nredis&gt; GET rank\r\n\"70\"\r\n</code></pre>\r\n<p>键不存在：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS counter\r\n(integer) 0\r\nredis&gt; INCRBY counter 30\r\n(integer) 30\r\nredis&gt; GET counter\r\n\"30\"\r\n</code></pre>\r\n<p>键存在，但值无法被解释为数字：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET book \"long long ago...\"\r\nOK\r\nredis&gt; INCRBY book 200\r\n(error) ERR value is not an integer or out of range\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>INCRBYFLOAT key increment</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>为键 <strong>key</strong> 储存的值加上浮点数增量 increment 。<br>如果键 <strong>key</strong> 不存在， 那么 <strong>INCRBYFLOAT</strong> 会先将键 <strong>key</strong> 的值设为 0 ， 然后再执行加法操作。</p>\r\n<p>如果命令执行成功， 那么键 <strong>key</strong> 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</p>\r\n<p>无论是键 <strong>key</strong> 的值还是增量 <strong>increment</strong> ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 <strong>INCRBYFLOAT</strong> 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</p>\r\n<p>此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</p>\r\n<p>当以下任意一个条件发生时， 命令返回一个错误：</p>\r\n<p>1.键 <strong>key</strong> 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）；</p>\r\n<p>2.键 <strong>key</strong> 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>在加上增量 increment 之后， 键 key 的值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GET decimal\r\n\"3.0\"\r\nredis&gt; INCRBYFLOAT decimal 2.56\r\n\"5.56\"\r\nredis&gt; GET decimal\r\n\"5.56\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>DECR key</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>为键 <strong>key</strong> 储存的数字值减去一。<br>如果键 <strong>key</strong> 不存在， 那么键 <strong>key</strong> 的值会先被初始化为 0 ， 然后再执行 DECR 操作。<br>如果键 <strong>key</strong> 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。<br>本操作的值限制在 64 位(bit)有符号数字表示之内。<br>关于递增(increment) / 递减(decrement)操作的更多信息， 请参见 <strong>INCR</strong> 命令的文档。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>DECR 命令会返回键 key 在执行减一操作之后的值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>对储存数字值的键 key 执行 DECR 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET failure_times 10\r\nOK\r\nredis&gt; DECR failure_times\r\n(integer) 9\r\n对不存在的键执行 DECR 命令：\r\nredis&gt; EXISTS count\r\n(integer) 0\r\nredis&gt; DECR count\r\n(integer) -1\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>DECRBY key decrement</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明:</h4><p>将键 <strong>key</strong> 储存的整数值减去减量 <strong>decrement</strong> 。<br>如果键 <strong>key</strong> 不存在， 那么键 <strong>key</strong> 的值会先被初始化为 0 ， 然后再执行 <strong>DECRBY</strong> 命令。<br>如果键 key 储存的值不能被解释为数字， 那么 <strong>DECRBY</strong> 命令将返回一个错误。<br>本操作的值限制在 64 位(bit)有符号数字表示之内。<br>关于更多递增(increment) / 递减(decrement)操作的更多信息， 请参见 <strong>INCR</strong> 命令的文档。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>DECRBY 命令会返回键在执行减法操作之后的值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>对已经存在的键执行 DECRBY 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; SET count 100\r\nOK\r\nredis&gt; DECRBY count 20\r\n(integer) 80\r\n</code></pre>\r\n<p>对不存在的键执行 DECRBY 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS pages\r\n(integer) 0\r\nredis&gt; DECRBY pages 10\r\n(integer) -10\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>MSET key value [key value …]</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>同时为多个键设置值。<br>如果某个给定键已经存在， 那么 <strong>MSET</strong> 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 <strong>MSETNX</strong> 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。<br>MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>MSET 命令总是返回 OK 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>同时对多个键进行设置：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\"\r\nOK\r\nredis&gt; MGET date time weather\r\n1) \"2012.3.30\"\r\n2) \"11:00 a.m.\"\r\n3) \"sunny\"\r\n</code></pre>\r\n<p>覆盖已有的值：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; MGET k1 k2\r\n1) \"hello\"\r\n2) \"world\"\r\nredis&gt; MSET k1 \"good\" k2 \"bye\"\r\nOK\r\nredis&gt; MGET k1 k2\r\n1) \"good\"\r\n2) \"bye\"\r\n</code></pre>\r\n<hr>\r\n<h4 id=\"h4--\"><a name=\"语法：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法：</h4><p><code>MSETNX key value [key value …]</code></p>\r\n<h4 id=\"h4--\"><a name=\"说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明：</h4><p>当且仅当所有给定键都不存在时， 为所有给定键设置值。<br>即使只有一个给定键已经存在， <strong>MSETNX</strong> 命令也会拒绝执行对所有键的设置操作。<br><strong>MSETNX</strong> 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>当所有给定键都设置成功时， 命令返回 1 ； 如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p>对不存在的键执行 MSETNX 命令：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; MSETNX rmdbs \"MySQL\" nosql \"MongoDB\" key-value-store \"redis\"\r\n(integer) 1\r\nredis&gt; MGET rmdbs nosql key-value-store\r\n1) \"MySQL\"\r\n2) \"MongoDB\"\r\n3) \"redis\"\r\n</code></pre>\r\n<p>对某个已经存在的键进行设置：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; MSETNX rmdbs \"Sqlite\" language \"python\"  # rmdbs 键已经存在，操作失败\r\n(integer) 0\r\nredis&gt; EXISTS language                          # 因为 MSETNX 命令没有成功执行\r\n(integer) 0                                     # 所以 language 键没有被设置\r\nredis&gt; GET rmdbs                                # rmdbs 键也没有被修改\r\n\"MySQL\"\r\n</code></pre>\r\n<hr>\r\n', null, null, null, '2020-11-03 21:02:38', '2020-11-03 21:52:22', '1');
INSERT INTO `articles` VALUES ('76', '1', 'redis常用数据类型---List列表', '', '`LPUSH key value [value …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度： O(1)\r\n\r\n将一个或多个值 value 插入到列表 key 的表头\r\n如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 `LPUSH mylist a b c `，列表的值将是 c b a ，这等同于原子性地执行 `LPUSH mylist a `、 `LPUSH mylist b `和 `LPUSH mylist c` 三个命令。\r\n\r\n如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。\r\n当 key 存在但不是列表类型时，返回一个错误。\r\n\r\n> Note\r\n在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。\r\n\r\n#### 返回值\r\n执行 LPUSH 命令后，列表的长度。\r\n\r\n#### 代码示例\r\n**加入单个元素**\r\n```shell\r\nredis> LPUSH languages python\r\n(integer) 1\r\n```\r\n**加入重复元素**\r\n\r\n```shell\r\nredis> LPUSH languages python\r\n(integer) 2\r\nredis> LRANGE languages 0 -1     # 列表允许重复元素\r\n1) \"python\"\r\n2) \"python\"\r\n```\r\n\r\n**加入多个元素**\r\n\r\n```shell\r\nredis> LPUSH mylist a b c\r\n(integer) 3\r\nredis> LRANGE mylist 0 -1\r\n1) \"c\"\r\n2) \"b\"\r\n3) \"a\"\r\n```\r\n\r\n------------\r\n\r\n\r\n`LPUSHX key value`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度： O(1)\r\n\r\n将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。\r\n和 `LPUSH key value [value …] `命令相反，当 key 不存在时， LPUSHX 命令什么也不做。\r\n\r\n#### 返回值\r\nLPUSHX 命令执行之后，表的长度。\r\n#### 代码示例\r\n**对空列表执行 LPUSHX**\r\n```shell\r\nredis> LLEN greet                       # greet 是一个空列表\r\n(integer) 0\r\nredis> LPUSHX greet \"hello\"             # 尝试 LPUSHX，失败，因为列表为空\r\n(integer) 0\r\n```\r\n**对非空列表执行 LPUSHX**\r\n```shell\r\nredis> LPUSH greet \"hello\"              # 先用 LPUSH 创建一个有一个元素的列表\r\n(integer) 1\r\nredis> LPUSHX greet \"good morning\"      # 这次 LPUSHX 执行成功\r\n(integer) 2\r\nredis> LRANGE greet 0 -1\r\n1) \"good morning\"\r\n2) \"hello\"\r\n```\r\n\r\n------------\r\n\r\n`RPUSH key value [value …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度： O(1)\r\n\r\n将一个或多个值 value 插入到列表 key 的表尾(最右边)。\r\n\r\n如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 `RPUSH mylist a b c` ，得出的结果列表为 a b c ，等同于执行命令 `RPUSH mylist a` 、 `RPUSH mylist b` 、 `RPUSH mylist c` 。\r\n\r\n如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。\r\n\r\n当 key 存在但不是列表类型时，返回一个错误。\r\n\r\n> Note\r\n在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。\r\n\r\n#### 返回值\r\n执行 RPUSH 操作后，表的长度。\r\n\r\n代码示例\r\n**# 添加单个元素**\r\n\r\n```shell\r\nredis> RPUSH languages c\r\n(integer) 1\r\n```\r\n\r\n\r\n**# 添加重复元素**\r\n\r\n```shell\r\nredis> RPUSH languages c\r\n(integer) 2\r\nredis> LRANGE languages 0 -1 # 列表允许重复元素\r\n1) \"c\"\r\n2) \"c\"\r\n```\r\n\r\n\r\n**# 添加多个元素**\r\n\r\n```shell\r\nredis> RPUSH mylist a b c\r\n(integer) 3\r\nredis> LRANGE mylist 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n```\r\n\r\n------------\r\n\r\n`RPUSHX key value`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度： O(1)\r\n\r\n将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。\r\n\r\n和 R`PUSH key value [value …] `命令相反，当 key 不存在时， RPUSHX 命令什么也不做。\r\n\r\n#### 返回值\r\nRPUSHX 命令执行之后，表的长度。\r\n\r\n代码示例\r\n**# key不存在**\r\n\r\n```shell\r\nredis> LLEN greet\r\n(integer) 0\r\nredis> RPUSHX greet \"hello\"     # 对不存在的 key 进行 RPUSHX，PUSH 失败。\r\n(integer) 0\r\n```\r\n\r\n\r\n**# key 存在且是一个非空列表**\r\n\r\n```shell\r\nredis> RPUSH greet \"hi\"         # 先用 RPUSH 插入一个元素\r\n(integer) 1\r\nredis> RPUSHX greet \"hello\"     # greet 现在是一个列表类型，RPUSHX 操作成功。\r\n(integer) 2\r\nredis> LRANGE greet 0 -1\r\n1) \"hi\"\r\n2) \"hello\"\r\n```\r\n\r\n\r\n------------\r\n\r\n`LPOP key`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度： O(1)\r\n\r\n移除并返回列表 key 的头元素。\r\n\r\n#### 返回值\r\n列表的头元素。 当 key 不存在时，返回 nil 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> LLEN course\r\n(integer) 0\r\nredis> RPUSH course algorithm001\r\n(integer) 1\r\nredis> RPUSH course c++101\r\n(integer) 2\r\nredis> LPOP course  # 移除头元素\r\n\"algorithm001\"\r\n```\r\n\r\n------------\r\n\r\n`RPOP key`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度： O(1)\r\n\r\n移除并返回列表 key 的尾元素。\r\n\r\n#### 返回值\r\n列表的尾元素。 当 key 不存在时，返回 nil 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> RPUSH mylist \"one\"\r\n(integer) 1\r\nredis> RPUSH mylist \"two\"\r\n(integer) 2\r\nredis> RPUSH mylist \"three\"\r\n(integer) 3\r\nredis> RPOP mylist           # 返回被弹出的元素\r\n\"three\"\r\nredis> LRANGE mylist 0 -1    # 列表剩下的元素\r\n1) \"one\"\r\n2) \"two\"\r\n```\r\n\r\n\r\n------------\r\n\r\n`RPOPLPUSH source destination`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度： O(1)\r\n\r\n命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：\r\n\r\n将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。\r\n\r\n将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。\r\n\r\n举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。\r\n\r\n如果 source 不存在，值 nil 被返回，并且不执行其他动作。\r\n\r\n如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。\r\n\r\n#### 返回值\r\n被弹出的元素。\r\n#### 代码示例\r\n**# source 和 destination 不同**\r\n\r\n```shell\r\nredis> LRANGE alpha 0 -1         # 查看所有元素\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n4) \"d\"\r\nredis> RPOPLPUSH alpha reciver   # 执行一次 RPOPLPUSH 看看\r\n\"d\"\r\nredis> LRANGE alpha 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\nredis> LRANGE reciver 0 -1\r\n1) \"d\"\r\nredis> RPOPLPUSH alpha reciver   # 再执行一次，证实 RPOP 和 LPUSH 的位置正确\r\n\"c\"\r\nredis> LRANGE alpha 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\nredis> LRANGE reciver 0 -1\r\n1) \"c\"\r\n2) \"d\"\r\n```\r\n\r\n\r\n**# source 和 destination 相同**\r\n\r\n```shell\r\nredis> LRANGE number 0 -1\r\n1) \"1\"\r\n2) \"2\"\r\n3) \"3\"\r\n4) \"4\"\r\nredis> RPOPLPUSH number number\r\n\"4\"\r\nredis> LRANGE number 0 -1           # 4 被旋转到了表头\r\n1) \"4\"\r\n2) \"1\"\r\n3) \"2\"\r\n4) \"3\"\r\nredis> RPOPLPUSH number number\r\n\"3\"\r\nredis> LRANGE number 0 -1           # 这次是 3 被旋转到了表头\r\n1) \"3\"\r\n2) \"4\"\r\n3) \"1\"\r\n4) \"2\"\r\n```\r\n模式： 安全的队列\r\nRedis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH key value [value …] 命令将消息放入队列中，而另一个客户端通过 RPOP key 或者 BRPOP key [key …] timeout 命令取出队列中等待时间最长的消息。\r\n\r\n不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。\r\n\r\n使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH source destination timeout )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM key count value 命令将这个消息从备份表删除。\r\n\r\n最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。\r\n\r\n模式：循环列表\r\n通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE key start stop 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。\r\n\r\n以上的模式甚至在以下的两个情况下也能正常工作：\r\n\r\n有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。\r\n\r\n有客户端在向列表尾部(右边)添加新元素。\r\n\r\n这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。\r\n\r\n注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。\r\n\r\n\r\n------------\r\n\r\n`LREM key count value`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度： O(N)， N 为列表的长度。\r\n\r\n根据参数 count 的值，移除列表中与参数 value 相等的元素。\r\n\r\ncount 的值可以是以下几种：\r\n\r\ncount > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。\r\n\r\ncount < 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。\r\n\r\ncount = 0 : 移除表中所有与 value 相等的值。\r\n\r\n#### 返回值\r\n被移除元素的数量。 因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。\r\n\r\n#### 代码示例\r\n**# 先创建一个表，内容排列是**\r\n**# morning hello morning helllo morning**\r\n\r\n```shell\r\nredis> LPUSH greet \"morning\"\r\n(integer) 1\r\nredis> LPUSH greet \"hello\"\r\n(integer) 2\r\nredis> LPUSH greet \"morning\"\r\n(integer) 3\r\nredis> LPUSH greet \"hello\"\r\n(integer) 4\r\nredis> LPUSH greet \"morning\"\r\n(integer) 5\r\nredis> LRANGE greet 0 4         # 查看所有元素\r\n1) \"morning\"\r\n2) \"hello\"\r\n3) \"morning\"\r\n4) \"hello\"\r\n5) \"morning\"\r\nredis> LREM greet 2 morning     # 移除从表头到表尾，最先发现的两个 morning\r\n(integer) 2                     # 两个元素被移除\r\nredis> LLEN greet               # 还剩 3 个元素\r\n(integer) 3\r\nredis> LRANGE greet 0 2\r\n1) \"hello\"\r\n2) \"hello\"\r\n3) \"morning\"\r\nredis> LREM greet -1 morning    # 移除从表尾到表头，第一个 morning\r\n(integer) 1\r\nredis> LLEN greet               # 剩下两个元素\r\n(integer) 2\r\nredis> LRANGE greet 0 1\r\n1) \"hello\"\r\n2) \"hello\"\r\nredis> LREM greet 0 hello      # 移除表中所有 hello\r\n(integer) 2                    # 两个 hello 被移除\r\nredis> LLEN greet\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n`LLEN key`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度： O(1)\r\n\r\n返回列表 key 的长度。\r\n\r\n如果 key 不存在，则 key 被解释为一个空列表，返回 0 .\r\n\r\n如果 key 不是列表类型，返回一个错误。\r\n\r\n#### 返回值\r\n列表 key 的长度。\r\n\r\n#### 代码示例\r\n**# 空列表**\r\n\r\n```shell\r\nredis> LLEN job\r\n(integer) 0\r\n```\r\n\r\n\r\n**# 非空列表**\r\n\r\n```shell\r\nredis> LPUSH job \"cook food\"\r\n(integer) 1\r\nredis> LPUSH job \"have lunch\"\r\n(integer) 2\r\nredis> LLEN job\r\n(integer) 2\r\n```\r\n\r\n------------\r\n\r\n`LINDEX key index`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度：O(N)， N 为到达下标 index 过程中经过的元素数量。\r\n\r\n因此，对列表的头元素和尾元素执行 LINDEX 命令，复杂度为O(1)。\r\n返回列表 key 中，下标为 index 的元素。\r\n\r\n下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。\r\n\r\n你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\r\n\r\n如果 key 不是列表类型，返回一个错误。\r\n\r\n#### 返回值\r\n列表中下标为 index 的元素。 如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> LPUSH mylist \"World\"\r\n(integer) 1\r\nredis> LPUSH mylist \"Hello\"\r\n(integer) 2\r\nredis> LINDEX mylist 0\r\n\"Hello\"\r\nredis> LINDEX mylist -1\r\n\"World\"\r\nredis> LINDEX mylist 3        # index不在 mylist 的区间范围内\r\n(nil)\r\n```\r\n\r\n------------\r\n\r\n`LINSERT key BEFORE|AFTER pivot value`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度: O(N)， N 为寻找 pivot 过程中经过的元素数量。\r\n\r\n将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。\r\n\r\n当 pivot 不存在于列表 key 时，不执行任何操作。\r\n\r\n当 key 不存在时， key 被视为空列表，不执行任何操作。\r\n\r\n如果 key 不是列表类型，返回一个错误。\r\n\r\n#### 返回值\r\n如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 pivot ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> RPUSH mylist \"Hello\"\r\n(integer) 1\r\nredis> RPUSH mylist \"World\"\r\n(integer) 2\r\nredis> LINSERT mylist BEFORE \"World\" \"There\"\r\n(integer) 3\r\nredis> LRANGE mylist 0 -1\r\n1) \"Hello\"\r\n2) \"There\"\r\n3) \"World\"\r\n```\r\n\r\n\r\n**# 对一个非空列表插入，查找一个不存在的 pivot**\r\n```shell\r\nredis> LINSERT mylist BEFORE \"go\" \"let\'s\"\r\n(integer) -1                                    # 失败\r\n```\r\n\r\n\r\n**# 对一个空列表执行 LINSERT 命令**\r\n\r\n```shell\r\nredis> EXISTS fake_list\r\n(integer) 0\r\nredis> LINSERT fake_list BEFORE \"nono\" \"gogogog\"\r\n(integer) 0                                      # 失败\r\n```\r\n\r\n------------\r\n\r\n`LSET key index value`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度：对头元素或尾元素进行 LSET 操作，复杂度为 O(1)。其他情况下，为 O(N)， N 为列表的长度。\r\n\r\n将列表 key 下标为 index 的元素的值设置为 value 。\r\n\r\n当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。\r\n\r\n关于列表下标的更多信息，请参考 LINDEX key index 命令。\r\n\r\n#### 返回值\r\n操作成功返回 ok ，否则返回错误信息。\r\n\r\n#### 代码示例\r\n**# 对空列表(key 不存在)进行 LSET**\r\n\r\n```shell\r\nredis> EXISTS list\r\n(integer) 0\r\nredis> LSET list 0 item\r\n(error) ERR no such key\r\n```\r\n\r\n\r\n**# 对非空列表进行 LSET**\r\n\r\n```shell\r\nredis> LPUSH job \"cook food\"\r\n(integer) 1\r\nredis> LRANGE job 0 0\r\n1) \"cook food\"\r\nredis> LSET job 0 \"play game\"\r\nOK\r\nredis> LRANGE job  0 0\r\n1) \"play game\"\r\n```\r\n\r\n\r\n**# index 超出范围**\r\n\r\n```shell\r\nredis> LLEN list                    # 列表长度为 1\r\n(integer) 1\r\nredis> LSET list 3 \'out of range\'\r\n(error) ERR index out of range\r\n\r\n```\r\n\r\n------------\r\n\r\n`LRANGE key start stop`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。\r\n\r\n返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。\r\n\r\n下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。\r\n\r\n你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\r\n\r\n注意LRANGE命令和编程语言区间函数的区别\r\n假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。\r\n\r\n超出范围的下标\r\n超出范围的下标值不会引起错误。\r\n\r\n如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。\r\n\r\n如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。\r\n\r\n#### 返回值\r\n一个列表，包含指定区间内的元素。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> RPUSH fp-language lisp\r\n(integer) 1\r\nredis> LRANGE fp-language 0 0\r\n1) \"lisp\"\r\nredis> RPUSH fp-language scheme\r\n(integer) 2\r\nredis> LRANGE fp-language 0 1\r\n1) \"lisp\"\r\n2) \"scheme\"\r\n```\r\n\r\n------------\r\n\r\n`LTRIM key start stop`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 为被移除的元素的数量。\r\n\r\n对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\r\n\r\n举个例子，执行命令 `LTRIM list 0 2` ，表示只保留列表 list 的前三个元素，其余元素全部删除。\r\n\r\n下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。\r\n\r\n你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\r\n\r\n当 key 不是列表类型时，返回一个错误。\r\n\r\nLTRIM 命令通常和 `LPUSH key value [value …]` 命令或` RPUSH key value [value …] `命令配合使用，举个例子：\r\n\r\n`LPUSH log newest_log`\r\n`LTRIM log 0 99`\r\n这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 log 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。\r\n\r\n注意LTRIM命令和编程语言区间函数的区别\r\n假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。\r\n\r\n超出范围的下标\r\n超出范围的下标值不会引起错误。\r\n\r\n如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start > stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。\r\n\r\n如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。\r\n\r\n#### 返回值\r\n命令执行成功时，返回 ok 。\r\n\r\n#### 代码示例\r\n**# 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内**\r\n\r\n```shell\r\nredis> LRANGE alpha 0 -1       # alpha 是一个包含 5 个字符串的列表\r\n1) \"h\"\r\n2) \"e\"\r\n3) \"l\"\r\n4) \"l\"\r\n5) \"o\"\r\nredis> LTRIM alpha 1 -1        # 删除 alpha 列表索引为 0 的元素\r\nOK\r\nredis> LRANGE alpha 0 -1       # \"h\" 被删除了\r\n1) \"e\"\r\n2) \"l\"\r\n3) \"l\"\r\n4) \"o\"\r\n\r\n```\r\n\r\n**# 情况 2： stop 比列表的最大下标还要大**\r\n\r\n\r\n```shell\r\nredis> LTRIM alpha 1 10086     # 保留 alpha 列表索引 1 至索引 10086 上的元素\r\nOK\r\nredis> LRANGE alpha 0 -1       # 只有索引 0 上的元素 \"e\" 被删除了，其他元素还在\r\n1) \"l\"\r\n2) \"l\"\r\n3) \"o\"\r\n```\r\n\r\n\r\n**# 情况 3： start 和 stop 都比列表的最大下标要大，并且 start < stop**\r\n\r\n```shell\r\nredis> LTRIM alpha 10086 123321\r\nOK\r\nredis> LRANGE alpha 0 -1        # 列表被清空\r\n(empty list or set)\r\n```\r\n\r\n\r\n**# 情况 4： start 和 stop 都比列表的最大下标要大，并且 start > stop**\r\n\r\n```shell\r\nredis> RPUSH new-alpha \"h\" \"e\" \"l\" \"l\" \"o\"     # 重新建立一个新列表\r\n(integer) 5\r\nredis> LRANGE new-alpha 0 -1\r\n1) \"h\"\r\n2) \"e\"\r\n3) \"l\"\r\n4) \"l\"\r\n5) \"o\"\r\nredis> LTRIM new-alpha 123321 10086    # 执行 LTRIM\r\nOK\r\nredis> LRANGE new-alpha 0 -1           # 同样被清空\r\n(empty list or set)\r\n```\r\n\r\n------------\r\n\r\n`BLPOP key [key …] timeout`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度： O(1)\r\n\r\nBLPOP 是列表的阻塞式(blocking)弹出原语。\r\n\r\n它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。\r\n\r\n当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。\r\n\r\n非阻塞行为\r\n当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。\r\n\r\n当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。\r\n\r\n假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：\r\n\r\n`BLPOP job command request 0`\r\n\r\nBLPOP 保证返回的元素来自 command ，因为它是按”查找 job -> 查找 command -> 查找 request “这样的顺序，第一个找到的非空列表。\r\n\r\n```shell\r\nredis> DEL job command request           # 确保key都被删除\r\n(integer) 0\r\nredis> LPUSH command \"update system...\"  # 为command列表增加一个值\r\n(integer) 1\r\nredis> LPUSH request \"visit page\"        # 为request列表增加一个值\r\n(integer) 1\r\nredis> BLPOP job command request 0       # job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。\r\n1) \"command\"                             # 弹出元素所属的列表\r\n2) \"update system...\"                    # 弹出元素所属的值\r\n```\r\n阻塞行为\r\n如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。\r\n\r\n超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。\r\n\r\n```shell\r\nredis> EXISTS job                # 确保两个 key 都不存在\r\n(integer) 0\r\nredis> EXISTS command\r\n(integer) 0\r\nredis> BLPOP job command 300     # 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。\r\n1) \"job\"                         # 这里被 push 的是 job\r\n2) \"do my home work\"             # 被弹出的值\r\n(26.26s)                         # 等待的秒数\r\nredis> BLPOP job command 5       # 等待超时的情况\r\n(nil)\r\n(5.66s)                          # 等待的秒数\r\n```\r\n相同的key被多个客户端同时阻塞\r\n相同的 key 可以被多个客户端同时阻塞。\r\n\r\n不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。\r\n\r\n在MULTI/EXEC事务中的BLPOP\r\nBLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 `LPUSH key value [value …] `或 `RPUSH key value [value …]` 命令。\r\n\r\n因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP key 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。\r\n\r\n**# 对非空列表进行操作**\r\n\r\n```shell\r\nredis> RPUSH job programming\r\n(integer) 1\r\nredis> MULTI\r\nOK\r\nredis> BLPOP job 30\r\nQUEUED\r\nredis> EXEC           # 不阻塞，立即返回\r\n1) 1) \"job\"\r\n   2) \"programming\"\r\n```\r\n\r\n\r\n**# 对空列表进行操作**\r\n\r\n```shell\r\nredis> LLEN job      # 空列表\r\n(integer) 0\r\nredis> MULTI\r\nOK\r\nredis> BLPOP job 30\r\nQUEUED\r\nredis> EXEC         # 不阻塞，立即返回\r\n1) (nil)\r\n```\r\n#### 返回值\r\n如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。\r\n\r\n模式：事件提醒\r\n有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。\r\n\r\n另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。\r\n\r\n对于 Redis ，我们似乎需要一个阻塞版的 SPOP key 命令，但实际上，使用 BLPOP 或者 BRPOP key [key …] timeout 就能很好地解决这个问题。\r\n\r\n使用元素的客户端(消费者)可以执行类似以下的代码：\r\n\r\n```shell\r\nLOOP forever\r\n    WHILE SPOP(key) returns elements\r\n        ... process elements ...\r\n    END\r\n    BRPOP helper_key\r\nEND\r\n```\r\n添加元素的客户端(生产者)则执行以下代码：\r\n\r\n```shell\r\nMULTI\r\n    SADD key element\r\n    LPUSH helper_key x\r\nEXEC\r\n```\r\n\r\n------------\r\n\r\n`BRPOP key [key …] timeout`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度： O(1)\r\n\r\nBRPOP 是列表的阻塞式(blocking)弹出原语。\r\n\r\n它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。\r\n\r\n当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。\r\n\r\n关于阻塞操作的更多信息，请查看 `BLPOP key [key …] timeout` 命令， BRPOP 除了弹出元素的位置和 BL`POP key [key …] timeout` 不同之外，其他表现一致。\r\n\r\n#### 返回值\r\n假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> LLEN course\r\n(integer) 0\r\nredis> RPUSH course algorithm001\r\n(integer) 1\r\nredis> RPUSH course c++101\r\n(integer) 2\r\nredis> BRPOP course 30\r\n1) \"course\"             # 被弹出元素所属的列表键\r\n2) \"c++101\"             # 被弹出的元素\r\n```\r\n\r\n\r\n------------\r\n\r\n`BRPOPLPUSH source destination timeout`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度： O(1)\r\n\r\nBRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。\r\n\r\n当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 `LPUSH key value [value …] `或 `RPUSH key value [value …]` 命令为止。\r\n\r\n超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。\r\n\r\n更多相关信息，请参考 `RPOPLPUSH source destination` 命令。\r\n\r\n#### 返回值\r\n假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。\r\n\r\n#### 代码示例\r\n**# 非空列表**\r\n\r\n```shell\r\nredis> BRPOPLPUSH msg reciver 500\r\n\"hello moto\"                        # 弹出元素的值\r\n(3.38s)                             # 等待时长\r\nredis> LLEN reciver\r\n(integer) 1\r\nredis> LRANGE reciver 0 0\r\n1) \"hello moto\"\r\n```\r\n\r\n\r\n**# 空列表**\r\n\r\n```shell\r\nredis> BRPOPLPUSH msg reciver 1\r\n(nil)\r\n(1.34s)\r\n```\r\n模式：安全队列\r\n参考 RPOPLPUSH source destination 命令的《安全队列》一节。\r\n\r\n模式：循环列表\r\n参考 RPOPLPUSH source destination 命令的《循环列表》一节。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<p><code>LPUSH key value [value …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>将一个或多个值 value 插入到列表 key 的表头<br>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 <code>LPUSH mylist a b c</code>，列表的值将是 c b a ，这等同于原子性地执行 <code>LPUSH mylist a</code>、 <code>LPUSH mylist b</code>和 <code>LPUSH mylist c</code> 三个命令。</p>\r\n<p>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。<br>当 key 存在但不是列表类型时，返回一个错误。\r\n<blockquote>\r\n<p>Note<br>在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>执行 LPUSH 命令后，列表的长度。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong>加入单个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH languages python\r\n(integer) 1\r\n</code></pre>\r\n<p><strong>加入重复元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH languages python\r\n(integer) 2\r\nredis&gt; LRANGE languages 0 -1     # 列表允许重复元素\r\n1) \"python\"\r\n2) \"python\"\r\n</code></pre>\r\n<p><strong>加入多个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH mylist a b c\r\n(integer) 3\r\nredis&gt; LRANGE mylist 0 -1\r\n1) \"c\"\r\n2) \"b\"\r\n3) \"a\"\r\n</code></pre>\r\n<hr>\r\n<p><code>LPUSHX key value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。<br>和 <code>LPUSH key value [value …]</code>命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>LPUSHX 命令执行之后，表的长度。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong>对空列表执行 LPUSHX</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LLEN greet                       # greet 是一个空列表\r\n(integer) 0\r\nredis&gt; LPUSHX greet \"hello\"             # 尝试 LPUSHX，失败，因为列表为空\r\n(integer) 0\r\n</code></pre>\r\n<p><strong>对非空列表执行 LPUSHX</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH greet \"hello\"              # 先用 LPUSH 创建一个有一个元素的列表\r\n(integer) 1\r\nredis&gt; LPUSHX greet \"good morning\"      # 这次 LPUSHX 执行成功\r\n(integer) 2\r\nredis&gt; LRANGE greet 0 -1\r\n1) \"good morning\"\r\n2) \"hello\"\r\n</code></pre>\r\n<hr>\r\n<p><code>RPUSH key value [value …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>将一个或多个值 value 插入到列表 key 的表尾(最右边)。</p>\r\n<p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 <code>RPUSH mylist a b c</code> ，得出的结果列表为 a b c ，等同于执行命令 <code>RPUSH mylist a</code> 、 <code>RPUSH mylist b</code> 、 <code>RPUSH mylist c</code> 。</p>\r\n<p>如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</p>\r\n<p>当 key 存在但不是列表类型时，返回一个错误。</p>\r\n<blockquote>\r\n<p>Note<br>在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>执行 RPUSH 操作后，表的长度。</p>\r\n<p>代码示例<br><strong># 添加单个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; RPUSH languages c\r\n(integer) 1\r\n</code></pre>\r\n<p><strong># 添加重复元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; RPUSH languages c\r\n(integer) 2\r\nredis&gt; LRANGE languages 0 -1 # 列表允许重复元素\r\n1) \"c\"\r\n2) \"c\"\r\n</code></pre>\r\n<p><strong># 添加多个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; RPUSH mylist a b c\r\n(integer) 3\r\nredis&gt; LRANGE mylist 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n</code></pre>\r\n<hr>\r\n<p><code>RPUSHX key value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</p>\r\n<p>和 R<code>PUSH key value [value …]</code>命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>RPUSHX 命令执行之后，表的长度。</p>\r\n<p>代码示例<br><strong># key不存在</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LLEN greet\r\n(integer) 0\r\nredis&gt; RPUSHX greet \"hello\"     # 对不存在的 key 进行 RPUSHX，PUSH 失败。\r\n(integer) 0\r\n</code></pre>\r\n<p><strong># key 存在且是一个非空列表</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; RPUSH greet \"hi\"         # 先用 RPUSH 插入一个元素\r\n(integer) 1\r\nredis&gt; RPUSHX greet \"hello\"     # greet 现在是一个列表类型，RPUSHX 操作成功。\r\n(integer) 2\r\nredis&gt; LRANGE greet 0 -1\r\n1) \"hi\"\r\n2) \"hello\"\r\n</code></pre>\r\n<hr>\r\n<p><code>LPOP key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>移除并返回列表 key 的头元素。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>列表的头元素。 当 key 不存在时，返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; LLEN course\r\n(integer) 0\r\nredis&gt; RPUSH course algorithm001\r\n(integer) 1\r\nredis&gt; RPUSH course c++101\r\n(integer) 2\r\nredis&gt; LPOP course  # 移除头元素\r\n\"algorithm001\"\r\n</code></pre>\r\n<hr>\r\n<p><code>RPOP key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>移除并返回列表 key 的尾元素。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>列表的尾元素。 当 key 不存在时，返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; RPUSH mylist \"one\"\r\n(integer) 1\r\nredis&gt; RPUSH mylist \"two\"\r\n(integer) 2\r\nredis&gt; RPUSH mylist \"three\"\r\n(integer) 3\r\nredis&gt; RPOP mylist           # 返回被弹出的元素\r\n\"three\"\r\nredis&gt; LRANGE mylist 0 -1    # 列表剩下的元素\r\n1) \"one\"\r\n2) \"two\"\r\n</code></pre>\r\n<hr>\r\n<p><code>RPOPLPUSH source destination</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p>\r\n<p>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</p>\r\n<p>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</p>\r\n<p>举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。</p>\r\n<p>如果 source 不存在，值 nil 被返回，并且不执行其他动作。</p>\r\n<p>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被弹出的元素。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># source 和 destination 不同</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LRANGE alpha 0 -1         # 查看所有元素\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n4) \"d\"\r\nredis&gt; RPOPLPUSH alpha reciver   # 执行一次 RPOPLPUSH 看看\r\n\"d\"\r\nredis&gt; LRANGE alpha 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\nredis&gt; LRANGE reciver 0 -1\r\n1) \"d\"\r\nredis&gt; RPOPLPUSH alpha reciver   # 再执行一次，证实 RPOP 和 LPUSH 的位置正确\r\n\"c\"\r\nredis&gt; LRANGE alpha 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\nredis&gt; LRANGE reciver 0 -1\r\n1) \"c\"\r\n2) \"d\"\r\n</code></pre>\r\n<p><strong># source 和 destination 相同</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LRANGE number 0 -1\r\n1) \"1\"\r\n2) \"2\"\r\n3) \"3\"\r\n4) \"4\"\r\nredis&gt; RPOPLPUSH number number\r\n\"4\"\r\nredis&gt; LRANGE number 0 -1           # 4 被旋转到了表头\r\n1) \"4\"\r\n2) \"1\"\r\n3) \"2\"\r\n4) \"3\"\r\nredis&gt; RPOPLPUSH number number\r\n\"3\"\r\nredis&gt; LRANGE number 0 -1           # 这次是 3 被旋转到了表头\r\n1) \"3\"\r\n2) \"4\"\r\n3) \"1\"\r\n4) \"2\"\r\n</code></pre>\r\n<p>模式： 安全的队列<br>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH key value [value …] 命令将消息放入队列中，而另一个客户端通过 RPOP key 或者 BRPOP key [key …] timeout 命令取出队列中等待时间最长的消息。\r\n<p>不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p>\r\n<p>使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH source destination timeout )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM key count value 命令将这个消息从备份表删除。</p>\r\n<p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p>\r\n<p>模式：循环列表<br>通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE key start stop 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。\r\n<p>以上的模式甚至在以下的两个情况下也能正常工作：</p>\r\n<p>有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。</p>\r\n<p>有客户端在向列表尾部(右边)添加新元素。</p>\r\n<p>这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。</p>\r\n<p>注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。</p>\r\n<hr>\r\n<p><code>LREM key count value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度： O(N)， N 为列表的长度。\r\n</blockquote>\r\n<p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p>\r\n<p>count 的值可以是以下几种：</p>\r\n<p>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</p>\r\n<p>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</p>\r\n<p>count = 0 : 移除表中所有与 value 相等的值。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被移除元素的数量。 因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 先创建一个表，内容排列是</strong><br><strong># morning hello morning helllo morning</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH greet \"morning\"\r\n(integer) 1\r\nredis&gt; LPUSH greet \"hello\"\r\n(integer) 2\r\nredis&gt; LPUSH greet \"morning\"\r\n(integer) 3\r\nredis&gt; LPUSH greet \"hello\"\r\n(integer) 4\r\nredis&gt; LPUSH greet \"morning\"\r\n(integer) 5\r\nredis&gt; LRANGE greet 0 4         # 查看所有元素\r\n1) \"morning\"\r\n2) \"hello\"\r\n3) \"morning\"\r\n4) \"hello\"\r\n5) \"morning\"\r\nredis&gt; LREM greet 2 morning     # 移除从表头到表尾，最先发现的两个 morning\r\n(integer) 2                     # 两个元素被移除\r\nredis&gt; LLEN greet               # 还剩 3 个元素\r\n(integer) 3\r\nredis&gt; LRANGE greet 0 2\r\n1) \"hello\"\r\n2) \"hello\"\r\n3) \"morning\"\r\nredis&gt; LREM greet -1 morning    # 移除从表尾到表头，第一个 morning\r\n(integer) 1\r\nredis&gt; LLEN greet               # 剩下两个元素\r\n(integer) 2\r\nredis&gt; LRANGE greet 0 1\r\n1) \"hello\"\r\n2) \"hello\"\r\nredis&gt; LREM greet 0 hello      # 移除表中所有 hello\r\n(integer) 2                    # 两个 hello 被移除\r\nredis&gt; LLEN greet\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<p><code>LLEN key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>返回列表 key 的长度。</p>\r\n<p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p>\r\n<p>如果 key 不是列表类型，返回一个错误。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>列表 key 的长度。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 空列表</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LLEN job\r\n(integer) 0\r\n</code></pre>\r\n<p><strong># 非空列表</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH job \"cook food\"\r\n(integer) 1\r\nredis&gt; LPUSH job \"have lunch\"\r\n(integer) 2\r\nredis&gt; LLEN job\r\n(integer) 2\r\n</code></pre>\r\n<hr>\r\n<p><code>LINDEX key index</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度：O(N)， N 为到达下标 index 过程中经过的元素数量。\r\n</blockquote>\r\n<p>因此，对列表的头元素和尾元素执行 LINDEX 命令，复杂度为O(1)。<br>返回列表 key 中，下标为 index 的元素。\r\n<p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p>\r\n<p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>\r\n<p>如果 key 不是列表类型，返回一个错误。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>列表中下标为 index 的元素。 如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; LPUSH mylist \"World\"\r\n(integer) 1\r\nredis&gt; LPUSH mylist \"Hello\"\r\n(integer) 2\r\nredis&gt; LINDEX mylist 0\r\n\"Hello\"\r\nredis&gt; LINDEX mylist -1\r\n\"World\"\r\nredis&gt; LINDEX mylist 3        # index不在 mylist 的区间范围内\r\n(nil)\r\n</code></pre>\r\n<hr>\r\n<p><code>LINSERT key BEFORE|AFTER pivot value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度: O(N)， N 为寻找 pivot 过程中经过的元素数量。\r\n</blockquote>\r\n<p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p>\r\n<p>当 pivot 不存在于列表 key 时，不执行任何操作。</p>\r\n<p>当 key 不存在时， key 被视为空列表，不执行任何操作。</p>\r\n<p>如果 key 不是列表类型，返回一个错误。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 pivot ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; RPUSH mylist \"Hello\"\r\n(integer) 1\r\nredis&gt; RPUSH mylist \"World\"\r\n(integer) 2\r\nredis&gt; LINSERT mylist BEFORE \"World\" \"There\"\r\n(integer) 3\r\nredis&gt; LRANGE mylist 0 -1\r\n1) \"Hello\"\r\n2) \"There\"\r\n3) \"World\"\r\n</code></pre>\r\n<p><strong># 对一个非空列表插入，查找一个不存在的 pivot</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LINSERT mylist BEFORE \"go\" \"let\'s\"\r\n(integer) -1                                    # 失败\r\n</code></pre>\r\n<p><strong># 对一个空列表执行 LINSERT 命令</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS fake_list\r\n(integer) 0\r\nredis&gt; LINSERT fake_list BEFORE \"nono\" \"gogogog\"\r\n(integer) 0                                      # 失败\r\n</code></pre>\r\n<hr>\r\n<p><code>LSET key index value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度：对头元素或尾元素进行 LSET 操作，复杂度为 O(1)。其他情况下，为 O(N)， N 为列表的长度。\r\n</blockquote>\r\n<p>将列表 key 下标为 index 的元素的值设置为 value 。</p>\r\n<p>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p>\r\n<p>关于列表下标的更多信息，请参考 LINDEX key index 命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>操作成功返回 ok ，否则返回错误信息。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 对空列表(key 不存在)进行 LSET</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS list\r\n(integer) 0\r\nredis&gt; LSET list 0 item\r\n(error) ERR no such key\r\n</code></pre>\r\n<p><strong># 对非空列表进行 LSET</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LPUSH job \"cook food\"\r\n(integer) 1\r\nredis&gt; LRANGE job 0 0\r\n1) \"cook food\"\r\nredis&gt; LSET job 0 \"play game\"\r\nOK\r\nredis&gt; LRANGE job  0 0\r\n1) \"play game\"\r\n</code></pre>\r\n<p><strong># index 超出范围</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LLEN list                    # 列表长度为 1\r\n(integer) 1\r\nredis&gt; LSET list 3 \'out of range\'\r\n(error) ERR index out of range\r\n</code></pre>\r\n<hr>\r\n<p><code>LRANGE key start stop</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。\r\n</blockquote>\r\n<p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p>\r\n<p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p>\r\n<p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>\r\n<p>注意LRANGE命令和编程语言区间函数的区别<br>假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。\r\n<p>超出范围的下标<br>超出范围的下标值不会引起错误。\r\n<p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。</p>\r\n<p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>一个列表，包含指定区间内的元素。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; RPUSH fp-language lisp\r\n(integer) 1\r\nredis&gt; LRANGE fp-language 0 0\r\n1) \"lisp\"\r\nredis&gt; RPUSH fp-language scheme\r\n(integer) 2\r\nredis&gt; LRANGE fp-language 0 1\r\n1) \"lisp\"\r\n2) \"scheme\"\r\n</code></pre>\r\n<hr>\r\n<p><code>LTRIM key start stop</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 为被移除的元素的数量。\r\n</blockquote>\r\n<p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>\r\n<p>举个例子，执行命令 <code>LTRIM list 0 2</code> ，表示只保留列表 list 的前三个元素，其余元素全部删除。</p>\r\n<p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p>\r\n<p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>\r\n<p>当 key 不是列表类型时，返回一个错误。</p>\r\n<p>LTRIM 命令通常和 <code>LPUSH key value [value …]</code> 命令或<code>RPUSH key value [value …]</code>命令配合使用，举个例子：</p>\r\n<p><code>LPUSH log newest_log</code><br><code>LTRIM log 0 99</code><br>这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 log 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。\r\n<p>注意LTRIM命令和编程语言区间函数的区别<br>假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。\r\n<p>超出范围的下标<br>超出范围的下标值不会引起错误。\r\n<p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start &gt; stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。</p>\r\n<p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>命令执行成功时，返回 ok 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LRANGE alpha 0 -1       # alpha 是一个包含 5 个字符串的列表\r\n1) \"h\"\r\n2) \"e\"\r\n3) \"l\"\r\n4) \"l\"\r\n5) \"o\"\r\nredis&gt; LTRIM alpha 1 -1        # 删除 alpha 列表索引为 0 的元素\r\nOK\r\nredis&gt; LRANGE alpha 0 -1       # \"h\" 被删除了\r\n1) \"e\"\r\n2) \"l\"\r\n3) \"l\"\r\n4) \"o\"\r\n</code></pre>\r\n<p><strong># 情况 2： stop 比列表的最大下标还要大</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LTRIM alpha 1 10086     # 保留 alpha 列表索引 1 至索引 10086 上的元素\r\nOK\r\nredis&gt; LRANGE alpha 0 -1       # 只有索引 0 上的元素 \"e\" 被删除了，其他元素还在\r\n1) \"l\"\r\n2) \"l\"\r\n3) \"o\"\r\n</code></pre>\r\n<p><strong># 情况 3： start 和 stop 都比列表的最大下标要大，并且 start &lt; stop</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LTRIM alpha 10086 123321\r\nOK\r\nredis&gt; LRANGE alpha 0 -1        # 列表被清空\r\n(empty list or set)\r\n</code></pre>\r\n<p><strong># 情况 4： start 和 stop 都比列表的最大下标要大，并且 start &gt; stop</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; RPUSH new-alpha \"h\" \"e\" \"l\" \"l\" \"o\"     # 重新建立一个新列表\r\n(integer) 5\r\nredis&gt; LRANGE new-alpha 0 -1\r\n1) \"h\"\r\n2) \"e\"\r\n3) \"l\"\r\n4) \"l\"\r\n5) \"o\"\r\nredis&gt; LTRIM new-alpha 123321 10086    # 执行 LTRIM\r\nOK\r\nredis&gt; LRANGE new-alpha 0 -1           # 同样被清空\r\n(empty list or set)\r\n</code></pre>\r\n<hr>\r\n<p><code>BLPOP key [key …] timeout</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>BLPOP 是列表的阻塞式(blocking)弹出原语。</p>\r\n<p>它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p>\r\n<p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>\r\n<p>非阻塞行为<br>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。\r\n<p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。</p>\r\n<p>假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：</p>\r\n<p><code>BLPOP job command request 0</code></p>\r\n<p>BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，第一个找到的非空列表。</p>\r\n<pre><code class=\"lang-shell\">redis&gt; DEL job command request           # 确保key都被删除\r\n(integer) 0\r\nredis&gt; LPUSH command \"update system...\"  # 为command列表增加一个值\r\n(integer) 1\r\nredis&gt; LPUSH request \"visit page\"        # 为request列表增加一个值\r\n(integer) 1\r\nredis&gt; BLPOP job command request 0       # job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。\r\n1) \"command\"                             # 弹出元素所属的列表\r\n2) \"update system...\"                    # 弹出元素所属的值\r\n</code></pre>\r\n<p>阻塞行为<br>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。\r\n<p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS job                # 确保两个 key 都不存在\r\n(integer) 0\r\nredis&gt; EXISTS command\r\n(integer) 0\r\nredis&gt; BLPOP job command 300     # 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。\r\n1) \"job\"                         # 这里被 push 的是 job\r\n2) \"do my home work\"             # 被弹出的值\r\n(26.26s)                         # 等待的秒数\r\nredis&gt; BLPOP job command 5       # 等待超时的情况\r\n(nil)\r\n(5.66s)                          # 等待的秒数\r\n</code></pre>\r\n<p>相同的key被多个客户端同时阻塞<br>相同的 key 可以被多个客户端同时阻塞。\r\n<p>不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。</p>\r\n<p>在MULTI/EXEC事务中的BLPOP<br>BLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 <code>LPUSH key value [value …]</code>或 <code>RPUSH key value [value …]</code> 命令。</p>\r\n<p>因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP key 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。</p>\r\n<p><strong># 对非空列表进行操作</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; RPUSH job programming\r\n(integer) 1\r\nredis&gt; MULTI\r\nOK\r\nredis&gt; BLPOP job 30\r\nQUEUED\r\nredis&gt; EXEC           # 不阻塞，立即返回\r\n1) 1) \"job\"\r\n   2) \"programming\"\r\n</code></pre>\r\n<p><strong># 对空列表进行操作</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; LLEN job      # 空列表\r\n(integer) 0\r\nredis&gt; MULTI\r\nOK\r\nredis&gt; BLPOP job 30\r\nQUEUED\r\nredis&gt; EXEC         # 不阻塞，立即返回\r\n1) (nil)\r\n</code></pre>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p>\r\n<p>模式：事件提醒<br>有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。\r\n<p>另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。</p>\r\n<p>对于 Redis ，我们似乎需要一个阻塞版的 SPOP key 命令，但实际上，使用 BLPOP 或者 BRPOP key [key …] timeout 就能很好地解决这个问题。</p>\r\n<p>使用元素的客户端(消费者)可以执行类似以下的代码：</p>\r\n<pre><code class=\"lang-shell\">LOOP forever\r\n    WHILE SPOP(key) returns elements\r\n        ... process elements ...\r\n    END\r\n    BRPOP helper_key\r\nEND\r\n</code></pre>\r\n<p>添加元素的客户端(生产者)则执行以下代码：</p>\r\n<pre><code class=\"lang-shell\">MULTI\r\n    SADD key element\r\n    LPUSH helper_key x\r\nEXEC\r\n</code></pre>\r\n<hr>\r\n<p><code>BRPOP key [key …] timeout</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>BRPOP 是列表的阻塞式(blocking)弹出原语。</p>\r\n<p>它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p>\r\n<p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p>\r\n<p>关于阻塞操作的更多信息，请查看 <code>BLPOP key [key …] timeout</code> 命令， BRPOP 除了弹出元素的位置和 BL<code>POP key [key …] timeout</code> 不同之外，其他表现一致。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; LLEN course\r\n(integer) 0\r\nredis&gt; RPUSH course algorithm001\r\n(integer) 1\r\nredis&gt; RPUSH course c++101\r\n(integer) 2\r\nredis&gt; BRPOP course 30\r\n1) \"course\"             # 被弹出元素所属的列表键\r\n2) \"c++101\"             # 被弹出的元素\r\n</code></pre>\r\n<hr>\r\n<p><code>BRPOPLPUSH source destination timeout</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</p>\r\n<p>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 <code>LPUSH key value [value …]</code>或 <code>RPUSH key value [value …]</code> 命令为止。</p>\r\n<p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p>\r\n<p>更多相关信息，请参考 <code>RPOPLPUSH source destination</code> 命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 非空列表</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; BRPOPLPUSH msg reciver 500\r\n\"hello moto\"                        # 弹出元素的值\r\n(3.38s)                             # 等待时长\r\nredis&gt; LLEN reciver\r\n(integer) 1\r\nredis&gt; LRANGE reciver 0 0\r\n1) \"hello moto\"\r\n</code></pre>\r\n<p><strong># 空列表</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; BRPOPLPUSH msg reciver 1\r\n(nil)\r\n(1.34s)\r\n</code></pre>\r\n<p>模式：安全队列<br>参考 RPOPLPUSH source destination 命令的《安全队列》一节。\r\n<p>模式：循环列表<br>参考 RPOPLPUSH source destination 命令的《循环列表》一节。\r\n', null, null, null, '2020-11-03 22:33:19', '2020-11-03 22:33:19', '1');
INSERT INTO `articles` VALUES ('77', '1', 'redis常用数据类型---Set集合', '', '`SADD key member [member …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 是被添加的元素的数量。\r\n\r\n将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。\r\n\r\n假如 key 不存在，则创建一个只包含 member 元素作成员的集合。\r\n\r\n当 key 不是集合类型时，返回一个错误。\r\n\r\n> Note\r\n在Redis2.4版本以前， SADD 只接受单个 member 值。\r\n\r\n#### 返回值\r\n被添加到集合中的新元素的数量，不包括被忽略的元素。\r\n\r\n#### 代码示例\r\n**# 添加单个元素**\r\n```shell\r\nredis> SADD bbs \"discuz.net\"\r\n(integer) 1\r\n```\r\n\r\n**# 添加重复元素**\r\n\r\n```shell\r\nredis> SADD bbs \"discuz.net\"\r\n(integer) 0\r\n```\r\n\r\n**# 添加多个元素**\r\n\r\n```shell\r\nredis> SADD bbs \"tianya.cn\" \"groups.google.com\"\r\n(integer) 2\r\nredis> SMEMBERS bbs\r\n1) \"discuz.net\"\r\n2) \"groups.google.com\"\r\n3) \"tianya.cn\"\r\n```\r\n\r\n------------\r\n\r\n`SISMEMBER key member`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(1)\r\n\r\n判断 member 元素是否集合 key 的成员。\r\n\r\n#### 返回值\r\n如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS joe\'s_movies\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n3) \"2012\"\r\nredis> SISMEMBER joe\'s_movies \"bet man\"\r\n(integer) 0\r\nredis> SISMEMBER joe\'s_movies \"Fast Five\"\r\n(integer) 1\r\n```\r\n\r\n------------\r\n\r\n`SPOP key`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(1)\r\n\r\n移除并返回集合中的一个随机元素。\r\n\r\n如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 `SRANDMEMBER key [count] `命令。\r\n\r\n#### 返回值\r\n被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS db\r\n1) \"MySQL\"\r\n2) \"MongoDB\"\r\n3) \"Redis\"\r\nredis> SPOP db\r\n\"Redis\"\r\nredis> SMEMBERS db\r\n1) \"MySQL\"\r\n2) \"MongoDB\"\r\nredis> SPOP db\r\n\"MySQL\"\r\nredis> SMEMBERS db\r\n1) \"MongoDB\"\r\n```\r\n\r\n------------\r\n\r\n`SRANDMEMBER key [count]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: 只提供 key 参数时为 O(1) 。如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。\r\n\r\n如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。\r\n\r\n从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：\r\n\r\n如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。\r\n\r\n如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。\r\n\r\n该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。\r\n\r\n#### 返回值\r\n只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。 如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。\r\n\r\n#### 代码示例\r\n**# 添加元素**\r\n\r\n```shell\r\nredis> SADD fruit apple banana cherry\r\n(integer) 3\r\n```\r\n\r\n**# 只给定 key 参数，返回一个随机元素**\r\n\r\n```shell\r\nredis> SRANDMEMBER fruit\r\n\"cherry\"\r\nredis> SRANDMEMBER fruit\r\n\"apple\"\r\n```\r\n\r\n**# 给定 3 为 count 参数，返回 3 个随机元素**\r\n**# 每个随机元素都不相同**\r\n```shell\r\nredis> SRANDMEMBER fruit 3\r\n1) \"apple\"\r\n2) \"banana\"\r\n3) \"cherry\"\r\n```\r\n**# 给定 -3 为 count 参数，返回 3 个随机元素**\r\n**# 元素可能会重复出现多次**\r\n\r\n```shell\r\nredis> SRANDMEMBER fruit -3\r\n1) \"banana\"\r\n2) \"cherry\"\r\n3) \"apple\"\r\nredis> SRANDMEMBER fruit -3\r\n1) \"apple\"\r\n2) \"apple\"\r\n3) \"cherry\"\r\n```\r\n\r\n**# 如果 count 是整数，且大于等于集合基数，那么返回整个集合**\r\n\r\n```shell\r\nredis> SRANDMEMBER fruit 10\r\n1) \"apple\"\r\n2) \"banana\"\r\n3) \"cherry\"\r\n```\r\n\r\n**# 如果 count 是负数，且 count 的绝对值大于集合的基数**\r\n**# 那么返回的数组的长度为 count 的绝对值**\r\n\r\n```shell\r\nredis> SRANDMEMBER fruit -10\r\n1) \"banana\"\r\n2) \"apple\"\r\n3) \"banana\"\r\n4) \"cherry\"\r\n5) \"apple\"\r\n6) \"apple\"\r\n7) \"cherry\"\r\n8) \"apple\"\r\n9) \"apple\"\r\n10) \"banana\"\r\n```\r\n\r\n**# SRANDMEMBER 并不会修改集合内容**\r\n\r\n```shell\r\nredis> SMEMBERS fruit\r\n1) \"apple\"\r\n2) \"cherry\"\r\n3) \"banana\"\r\n```\r\n\r\n**# 集合为空时返回 nil 或者空数组**\r\n\r\n```shell\r\nredis> SRANDMEMBER not-exists\r\n(nil)\r\nredis> SRANDMEMBER not-eixsts 10\r\n(empty list or set)\r\n```\r\n\r\n------------\r\n\r\n> `SREM key member [member …]`\r\n可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 为给定 member 元素的数量。\r\n\r\n移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。\r\n\r\n当 key 不是集合类型，返回一个错误。\r\n\r\n> Note\r\n在 Redis 2.4 版本以前， SREM 只接受单个 member 值。\r\n\r\n#### 返回值\r\n被成功移除的元素的数量，不包括被忽略的元素。\r\n\r\n#### 代码示例\r\n**# 测试数据**\r\n\r\n```shell\r\nredis> SMEMBERS languages\r\n1) \"c\"\r\n2) \"lisp\"\r\n3) \"python\"\r\n4) \"ruby\"\r\n```\r\n\r\n\r\n**# 移除单个元素**\r\n\r\n```shell\r\nredis> SREM languages ruby\r\n(integer) 1\r\n```\r\n\r\n\r\n**# 移除不存在元素**\r\n\r\n```shell\r\nredis> SREM languages non-exists-language\r\n(integer) 0\r\n```\r\n\r\n\r\n**# 移除多个元素**\r\n\r\n```shell\r\nredis> SREM languages lisp python c\r\n(integer) 3\r\nredis> SMEMBERS languages\r\n(empty list or set)\r\n```\r\n\r\n------------\r\n\r\n`SMOVE source destination member`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(1)\r\n\r\n将 member 元素从 source 集合移动到 destination 集合。\r\n\r\nSMOVE 是原子性操作。\r\n\r\n如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。\r\n\r\n当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。\r\n\r\n当 source 或 destination 不是集合类型时，返回一个错误。\r\n\r\n#### 返回值\r\n如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS songs\r\n1) \"Billie Jean\"\r\n2) \"Believe Me\"\r\nredis> SMEMBERS my_songs\r\n(empty list or set)\r\nredis> SMOVE songs my_songs \"Believe Me\"\r\n(integer) 1\r\nredis> SMEMBERS songs\r\n1) \"Billie Jean\"\r\nredis> SMEMBERS my_songs\r\n1) \"Believe Me\"\r\n```\r\n\r\n------------\r\n\r\n`SCARD key`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(1)\r\n\r\n返回集合 key 的基数(集合中元素的数量)。\r\n\r\n#### 返回值\r\n集合的基数。 当 key 不存在时，返回 0 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SADD tool pc printer phone\r\n(integer) 3\r\nredis> SCARD tool   # 非空集合\r\n(integer) 3\r\nredis> DEL tool\r\n(integer) 1\r\nredis> SCARD tool   # 空集合\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n`SMEMBERS key`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 为集合的基数。\r\n\r\n返回集合 key 中的所有成员。\r\n\r\n不存在的 key 被视为空集合。\r\n\r\n#### 返回值\r\n集合中的所有成员。\r\n\r\n#### 代码示例\r\n**# key 不存在或集合为空**\r\n\r\n```shell\r\nredis> EXISTS not_exists_key\r\n(integer) 0\r\nredis> SMEMBERS not_exists_key\r\n(empty list or set)\r\n```\r\n\r\n\r\n**# 非空集合**\r\n\r\n```shell\r\nredis> SADD language Ruby Python Clojure\r\n(integer) 3\r\nredis> SMEMBERS language\r\n1) \"Python\"\r\n2) \"Ruby\"\r\n3) \"Clojure\"\r\n```\r\n\r\n------------\r\n\r\n`SINTER key [key …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。\r\n\r\n返回一个集合的全部成员，该集合是所有给定集合的交集。\r\n\r\n不存在的 key 被视为空集。\r\n\r\n当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。\r\n\r\n#### 返回值\r\n交集成员的列表。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS group_1\r\n1) \"LI LEI\"\r\n2) \"TOM\"\r\n3) \"JACK\"\r\nredis> SMEMBERS group_2\r\n1) \"HAN MEIMEI\"\r\n2) \"JACK\"\r\nredis> SINTER group_1 group_2\r\n1) \"JACK\"\r\n```\r\n\r\n------------\r\n\r\n`SINTERSTORE destination key [key …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。\r\n\r\n这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。\r\n\r\n如果 destination 集合已经存在，则将其覆盖。\r\n\r\ndestination 可以是 key 本身。\r\n\r\n#### 返回值\r\n结果集中的成员数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS songs\r\n1) \"good bye joe\"\r\n2) \"hello,peter\"\r\nredis> SMEMBERS my_songs\r\n1) \"good bye joe\"\r\n2) \"falling\"\r\nredis> SINTERSTORE song_interset songs my_songs\r\n(integer) 1\r\nredis> SMEMBERS song_interset\r\n1) \"good bye joe\"\r\n```\r\n\r\n------------\r\n\r\n`SUNION key [key …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n\r\n返回一个集合的全部成员，该集合是所有给定集合的并集。\r\n\r\n不存在的 key 被视为空集。\r\n\r\n#### 返回值\r\n并集成员的列表。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS songs\r\n1) \"Billie Jean\"\r\nredis> SMEMBERS my_songs\r\n1) \"Believe Me\"\r\nredis> SUNION songs my_songs\r\n1) \"Billie Jean\"\r\n2) \"Believe Me\"\r\n```\r\n\r\n------------\r\n\r\n\r\n`SUNIONSTORE destination key [key …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n\r\n这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。\r\n\r\n如果 destination 已经存在，则将其覆盖。\r\n\r\ndestination 可以是 key 本身。\r\n\r\n#### 返回值\r\n结果集中的元素数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS NoSQL\r\n1) \"MongoDB\"\r\n2) \"Redis\"\r\nredis> SMEMBERS SQL\r\n1) \"sqlite\"\r\n2) \"MySQL\"\r\nredis> SUNIONSTORE db NoSQL SQL\r\n(integer) 4\r\nredis> SMEMBERS db\r\n1) \"MySQL\"\r\n2) \"sqlite\"\r\n3) \"MongoDB\"\r\n4) \"Redis\"\r\n```\r\n\r\n------------\r\n\r\n`SDIFF key [key …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n\r\n返回一个集合的全部成员，该集合是所有给定集合之间的差集。\r\n\r\n不存在的 key 被视为空集。\r\n\r\n#### 返回值\r\n一个包含差集成员的列表。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS peter\'s_movies\r\n1) \"bet man\"\r\n2) \"start war\"\r\n3) \"2012\"\r\nredis> SMEMBERS joe\'s_movies\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n3) \"2012\"\r\nredis> SDIFF peter\'s_movies joe\'s_movies\r\n1) \"bet man\"\r\n2) \"start war\"\r\n```\r\n\r\n------------\r\n\r\n`SDIFFSTORE destination key [key …]`\r\n> 可用版本： >= 1.0.0\r\n时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n\r\n这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。\r\n\r\n如果 destination 集合已经存在，则将其覆盖。\r\n\r\ndestination 可以是 key 本身。\r\n\r\n#### 返回值\r\n结果集中的元素数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SMEMBERS joe\'s_movies\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n3) \"2012\"\r\nredis> SMEMBERS peter\'s_movies\r\n1) \"bet man\"\r\n2) \"start war\"\r\n3) \"2012\"\r\nredis> SDIFFSTORE joe_diff_peter joe\'s_movies peter\'s_movies\r\n(integer) 2\r\nredis> SMEMBERS joe_diff_peter\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n```\r\n\r\n\r\n', '<p><code>SADD key member [member …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 是被添加的元素的数量。\r\n</blockquote>\r\n<p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p>\r\n<p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</p>\r\n<p>当 key 不是集合类型时，返回一个错误。</p>\r\n<blockquote>\r\n<p>Note<br>在Redis2.4版本以前， SADD 只接受单个 member 值。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 添加单个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SADD bbs \"discuz.net\"\r\n(integer) 1\r\n</code></pre>\r\n<p><strong># 添加重复元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SADD bbs \"discuz.net\"\r\n(integer) 0\r\n</code></pre>\r\n<p><strong># 添加多个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SADD bbs \"tianya.cn\" \"groups.google.com\"\r\n(integer) 2\r\nredis&gt; SMEMBERS bbs\r\n1) \"discuz.net\"\r\n2) \"groups.google.com\"\r\n3) \"tianya.cn\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SISMEMBER key member</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>判断 member 元素是否集合 key 的成员。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS joe\'s_movies\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n3) \"2012\"\r\nredis&gt; SISMEMBER joe\'s_movies \"bet man\"\r\n(integer) 0\r\nredis&gt; SISMEMBER joe\'s_movies \"Fast Five\"\r\n(integer) 1\r\n</code></pre>\r\n<hr>\r\n<p><code>SPOP key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>移除并返回集合中的一个随机元素。</p>\r\n<p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 <code>SRANDMEMBER key [count]</code>命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS db\r\n1) \"MySQL\"\r\n2) \"MongoDB\"\r\n3) \"Redis\"\r\nredis&gt; SPOP db\r\n\"Redis\"\r\nredis&gt; SMEMBERS db\r\n1) \"MySQL\"\r\n2) \"MongoDB\"\r\nredis&gt; SPOP db\r\n\"MySQL\"\r\nredis&gt; SMEMBERS db\r\n1) \"MongoDB\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SRANDMEMBER key [count]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: 只提供 key 参数时为 O(1) 。如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。\r\n</blockquote>\r\n<p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p>\r\n<p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p>\r\n<p>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。</p>\r\n<p>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</p>\r\n<p>该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。 如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 添加元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SADD fruit apple banana cherry\r\n(integer) 3\r\n</code></pre>\r\n<p><strong># 只给定 key 参数，返回一个随机元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SRANDMEMBER fruit\r\n\"cherry\"\r\nredis&gt; SRANDMEMBER fruit\r\n\"apple\"\r\n</code></pre>\r\n<p><strong># 给定 3 为 count 参数，返回 3 个随机元素</strong><br><strong># 每个随机元素都不相同</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SRANDMEMBER fruit 3\r\n1) \"apple\"\r\n2) \"banana\"\r\n3) \"cherry\"\r\n</code></pre>\r\n<p><strong># 给定 -3 为 count 参数，返回 3 个随机元素</strong><br><strong># 元素可能会重复出现多次</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SRANDMEMBER fruit -3\r\n1) \"banana\"\r\n2) \"cherry\"\r\n3) \"apple\"\r\nredis&gt; SRANDMEMBER fruit -3\r\n1) \"apple\"\r\n2) \"apple\"\r\n3) \"cherry\"\r\n</code></pre>\r\n<p><strong># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SRANDMEMBER fruit 10\r\n1) \"apple\"\r\n2) \"banana\"\r\n3) \"cherry\"\r\n</code></pre>\r\n<p><strong># 如果 count 是负数，且 count 的绝对值大于集合的基数</strong><br><strong># 那么返回的数组的长度为 count 的绝对值</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SRANDMEMBER fruit -10\r\n1) \"banana\"\r\n2) \"apple\"\r\n3) \"banana\"\r\n4) \"cherry\"\r\n5) \"apple\"\r\n6) \"apple\"\r\n7) \"cherry\"\r\n8) \"apple\"\r\n9) \"apple\"\r\n10) \"banana\"\r\n</code></pre>\r\n<p><strong># SRANDMEMBER 并不会修改集合内容</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SMEMBERS fruit\r\n1) \"apple\"\r\n2) \"cherry\"\r\n3) \"banana\"\r\n</code></pre>\r\n<p><strong># 集合为空时返回 nil 或者空数组</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SRANDMEMBER not-exists\r\n(nil)\r\nredis&gt; SRANDMEMBER not-eixsts 10\r\n(empty list or set)\r\n</code></pre>\r\n<hr>\r\n<blockquote>\r\n<p><code>SREM key member [member …]</code><br>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 为给定 member 元素的数量。\r\n</blockquote>\r\n<p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</p>\r\n<p>当 key 不是集合类型，返回一个错误。</p>\r\n<blockquote>\r\n<p>Note<br>在 Redis 2.4 版本以前， SREM 只接受单个 member 值。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被成功移除的元素的数量，不包括被忽略的元素。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 测试数据</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SMEMBERS languages\r\n1) \"c\"\r\n2) \"lisp\"\r\n3) \"python\"\r\n4) \"ruby\"\r\n</code></pre>\r\n<p><strong># 移除单个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SREM languages ruby\r\n(integer) 1\r\n</code></pre>\r\n<p><strong># 移除不存在元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SREM languages non-exists-language\r\n(integer) 0\r\n</code></pre>\r\n<p><strong># 移除多个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SREM languages lisp python c\r\n(integer) 3\r\nredis&gt; SMEMBERS languages\r\n(empty list or set)\r\n</code></pre>\r\n<hr>\r\n<p><code>SMOVE source destination member</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>将 member 元素从 source 集合移动到 destination 集合。</p>\r\n<p>SMOVE 是原子性操作。</p>\r\n<p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</p>\r\n<p>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</p>\r\n<p>当 source 或 destination 不是集合类型时，返回一个错误。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS songs\r\n1) \"Billie Jean\"\r\n2) \"Believe Me\"\r\nredis&gt; SMEMBERS my_songs\r\n(empty list or set)\r\nredis&gt; SMOVE songs my_songs \"Believe Me\"\r\n(integer) 1\r\nredis&gt; SMEMBERS songs\r\n1) \"Billie Jean\"\r\nredis&gt; SMEMBERS my_songs\r\n1) \"Believe Me\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SCARD key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>返回集合 key 的基数(集合中元素的数量)。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>集合的基数。 当 key 不存在时，返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SADD tool pc printer phone\r\n(integer) 3\r\nredis&gt; SCARD tool   # 非空集合\r\n(integer) 3\r\nredis&gt; DEL tool\r\n(integer) 1\r\nredis&gt; SCARD tool   # 空集合\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<p><code>SMEMBERS key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 为集合的基数。\r\n</blockquote>\r\n<p>返回集合 key 中的所有成员。</p>\r\n<p>不存在的 key 被视为空集合。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>集合中的所有成员。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># key 不存在或集合为空</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS not_exists_key\r\n(integer) 0\r\nredis&gt; SMEMBERS not_exists_key\r\n(empty list or set)\r\n</code></pre>\r\n<p><strong># 非空集合</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SADD language Ruby Python Clojure\r\n(integer) 3\r\nredis&gt; SMEMBERS language\r\n1) \"Python\"\r\n2) \"Ruby\"\r\n3) \"Clojure\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SINTER key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。\r\n</blockquote>\r\n<p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p>\r\n<p>不存在的 key 被视为空集。</p>\r\n<p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>交集成员的列表。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS group_1\r\n1) \"LI LEI\"\r\n2) \"TOM\"\r\n3) \"JACK\"\r\nredis&gt; SMEMBERS group_2\r\n1) \"HAN MEIMEI\"\r\n2) \"JACK\"\r\nredis&gt; SINTER group_1 group_2\r\n1) \"JACK\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SINTERSTORE destination key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。\r\n</blockquote>\r\n<p>这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p>\r\n<p>如果 destination 集合已经存在，则将其覆盖。</p>\r\n<p>destination 可以是 key 本身。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>结果集中的成员数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS songs\r\n1) \"good bye joe\"\r\n2) \"hello,peter\"\r\nredis&gt; SMEMBERS my_songs\r\n1) \"good bye joe\"\r\n2) \"falling\"\r\nredis&gt; SINTERSTORE song_interset songs my_songs\r\n(integer) 1\r\nredis&gt; SMEMBERS song_interset\r\n1) \"good bye joe\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SUNION key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n</blockquote>\r\n<p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p>\r\n<p>不存在的 key 被视为空集。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>并集成员的列表。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS songs\r\n1) \"Billie Jean\"\r\nredis&gt; SMEMBERS my_songs\r\n1) \"Believe Me\"\r\nredis&gt; SUNION songs my_songs\r\n1) \"Billie Jean\"\r\n2) \"Believe Me\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SUNIONSTORE destination key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n</blockquote>\r\n<p>这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p>\r\n<p>如果 destination 已经存在，则将其覆盖。</p>\r\n<p>destination 可以是 key 本身。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>结果集中的元素数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS NoSQL\r\n1) \"MongoDB\"\r\n2) \"Redis\"\r\nredis&gt; SMEMBERS SQL\r\n1) \"sqlite\"\r\n2) \"MySQL\"\r\nredis&gt; SUNIONSTORE db NoSQL SQL\r\n(integer) 4\r\nredis&gt; SMEMBERS db\r\n1) \"MySQL\"\r\n2) \"sqlite\"\r\n3) \"MongoDB\"\r\n4) \"Redis\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SDIFF key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n</blockquote>\r\n<p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p>\r\n<p>不存在的 key 被视为空集。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>一个包含差集成员的列表。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS peter\'s_movies\r\n1) \"bet man\"\r\n2) \"start war\"\r\n3) \"2012\"\r\nredis&gt; SMEMBERS joe\'s_movies\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n3) \"2012\"\r\nredis&gt; SDIFF peter\'s_movies joe\'s_movies\r\n1) \"bet man\"\r\n2) \"start war\"\r\n</code></pre>\r\n<hr>\r\n<p><code>SDIFFSTORE destination key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.0<br>时间复杂度: O(N)， N 是所有给定集合的成员数量之和。\r\n</blockquote>\r\n<p>这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p>\r\n<p>如果 destination 集合已经存在，则将其覆盖。</p>\r\n<p>destination 可以是 key 本身。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>结果集中的元素数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SMEMBERS joe\'s_movies\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n3) \"2012\"\r\nredis&gt; SMEMBERS peter\'s_movies\r\n1) \"bet man\"\r\n2) \"start war\"\r\n3) \"2012\"\r\nredis&gt; SDIFFSTORE joe_diff_peter joe\'s_movies peter\'s_movies\r\n(integer) 2\r\nredis&gt; SMEMBERS joe_diff_peter\r\n1) \"hi, lady\"\r\n2) \"Fast Five\"\r\n</code></pre>\r\n', null, null, null, '2020-11-03 22:50:19', '2020-11-03 22:50:19', '1');
INSERT INTO `articles` VALUES ('78', '1', 'redis常用数据类型---ZSet有序集合', '', '`ZADD key score member [[score member] [score member] …]`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。\r\n\r\n将一个或多个 member 元素及其 score 值加入到有序集 key 当中。\r\n\r\n如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。\r\n\r\nscore 值可以是整数值或双精度浮点数。\r\n\r\n如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。\r\n\r\n当 key 存在但不是有序集类型时，返回一个错误。\r\n\r\n对有序集的更多介绍请参见 sorted set 。\r\n\r\n> Note\r\n在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。\r\n\r\n#### 返回值\r\n被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。\r\n\r\n#### 代码示例\r\n**# 添加单个元素**\r\n\r\n```shell\r\nredis> ZADD page_rank 10 google.com\r\n(integer) 1\r\n```\r\n\r\n\r\n**# 添加多个元素**\r\n\r\n```shell\r\nredis> ZADD page_rank 9 baidu.com 8 bing.com\r\n(integer) 2\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n```\r\n\r\n\r\n**# 添加已存在元素，且 score 值不变**\r\n\r\n```shell\r\nredis> ZADD page_rank 10 google.com\r\n(integer) 0\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n```\r\n\r\n\r\n**# 添加已存在元素，但是改变 score 值**\r\n\r\n```shell\r\nredis> ZADD page_rank 6 bing.com\r\n(integer) 0\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变\r\n1) \"bing.com\"\r\n2) \"6\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n```\r\n\r\n------------\r\n\r\n`ZSCORE key member`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(1)\r\n\r\n返回有序集 key 中，成员 member 的 score 值。\r\n\r\n如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。\r\n\r\n#### 返回值\r\nmember 成员的 score 值，以字符串形式表示。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZRANGE salary 0 -1 WITHSCORES    # 测试数据\r\n1) \"tom\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis> ZSCORE salary peter              # 注意返回值是字符串\r\n\"3500\"\r\n```\r\n\r\n------------\r\n\r\n`ZINCRBY key increment member`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(log(N))\r\n\r\n为有序集 key 的成员 member 的 score 值加上增量 increment 。\r\n\r\n可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 `ZINCRBY key -5 member` ，就是让 member 的 score 值减去 5 。\r\n\r\n当 key 不存在，或 member 不是 key 的成员时， `ZINCRBY key increment member` 等同于 `ZADD key increment member` 。\r\n\r\n当 key 不是有序集类型时，返回一个错误。\r\n\r\nscore 值可以是整数值或双精度浮点数。\r\n\r\n#### 返回值\r\nmember 成员的新 score 值，以字符串形式表示。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZSCORE salary tom\r\n\"2000\"\r\nredis> ZINCRBY salary 2000 tom   # tom 加薪啦！\r\n\"4000\"\r\n```\r\n\r\n------------\r\n\r\n`ZCARD key`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(1)\r\n\r\n返回有序集 key 的基数。\r\n\r\n#### 返回值\r\n当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis > ZADD salary 2000 tom    # 添加一个成员\r\n(integer) 1\r\nredis > ZCARD salary\r\n(integer) 1\r\nredis > ZADD salary 5000 jack   # 再添加一个成员\r\n(integer) 1\r\nredis > ZCARD salary\r\n(integer) 2\r\nredis > EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作\r\n(integer) 0\r\nredis > ZCARD non_exists_key\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n`ZCOUNT key min max`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度: O(log(N))， N 为有序集的基数。\r\n\r\n返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。\r\n\r\n关于参数 min 和 max 的详细使用方法，请参考 `ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]` 命令。\r\n\r\n#### 返回值\r\nscore 值在 min 和 max 之间的成员的数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZRANGE salary 0 -1 WITHSCORES    # 测试数据\r\n1) \"jack\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\nredis> ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数\r\n(integer) 3\r\nredis> ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数\r\n(integer) 2\r\n```\r\n\r\n------------\r\n\r\n`ZRANGE key start stop [WITHSCORES]`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。\r\n\r\n返回有序集 key 中，指定区间内的成员。\r\n\r\n其中成员的位置按 score 值递增(从小到大)来排序。\r\n\r\n具有相同 score 值的成员按字典序(lexicographical order )来排列。\r\n\r\n如果你需要成员按 score 值递减(从大到小)来排列，请使用 `ZREVRANGE key start stop [WITHSCORES]` 命令。\r\n\r\n下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。\r\n\r\n超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start > stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。\r\n\r\n可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。\r\n\r\n#### 返回值\r\n指定区间内，带有 score 值(可选)的有序集成员的列表。\r\n\r\n#### 代码示例\r\n```shell\r\nredis > ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员\r\n1) \"jack\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\n5) \"boss\"\r\n6) \"10086\"\r\nredis > ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员\r\n1) \"tom\"\r\n2) \"5000\"\r\n3) \"boss\"\r\n4) \"10086\"\r\nredis > ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况\r\n1) \"jack\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\n5) \"boss\"\r\n6) \"10086\"\r\nredis > ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况\r\n(empty list or set)\r\n```\r\n\r\n------------\r\n\r\n`ZREVRANGE key start stop [WITHSCORES]`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。\r\n\r\n返回有序集 key 中，指定区间内的成员。\r\n\r\n其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。\r\n\r\n除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。\r\n\r\n#### 返回值\r\n指定区间内，带有 score 值(可选)的有序集成员的列表。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZRANGE salary 0 -1 WITHSCORES        # 递增排列\r\n1) \"peter\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"4000\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis> ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列\r\n1) \"jack\"\r\n2) \"5000\"\r\n3) \"tom\"\r\n4) \"4000\"\r\n5) \"peter\"\r\n6) \"3500\"\r\n```\r\n\r\n------------\r\n\r\n`ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]`\r\n> 可用版本： >= 1.0.5\r\n时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。\r\n\r\n返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。\r\n\r\n具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。\r\n\r\n可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。\r\n\r\n可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。\r\n\r\n区间及无限\r\nmin 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。\r\n\r\n默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。\r\n\r\n举个例子：\r\n\r\n`ZRANGEBYSCORE zset (1 5`\r\n返回所有符合条件 1 < score <= 5 的成员，而\r\n\r\n`ZRANGEBYSCORE zset (5 (10`\r\n则返回所有符合条件 5 < score < 10 的成员。\r\n\r\n#### 返回值\r\n指定区间内，带有 score 值(可选)的有序集成员的列表。\r\n#### \r\n代码示例\r\n```shell\r\nredis> ZADD salary 2500 jack                        # 测试数据\r\n(integer) 0\r\nredis> ZADD salary 5000 tom\r\n(integer) 0\r\nredis> ZADD salary 12000 peter\r\n(integer) 0\r\nredis> ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集\r\n1) \"jack\"\r\n2) \"tom\"\r\n3) \"peter\"\r\nredis> ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值\r\n1) \"jack\"\r\n2) \"2500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\n5) \"peter\"\r\n6) \"12000\"\r\nredis> ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 <=5000 的所有成员\r\n1) \"jack\"\r\n2) \"2500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\nredis> ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员\r\n1) \"peter\"\r\n```\r\n\r\n------------\r\n\r\n\r\n`ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。\r\n\r\n返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。\r\n\r\n具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。\r\n\r\n除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 `ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]` 命令一样。\r\n\r\n#### 返回值\r\n指定区间内，带有 score 值(可选)的有序集成员的列表。\r\n\r\n#### 代码示例\r\n```shell\r\nredis > ZADD salary 10086 jack\r\n(integer) 1\r\nredis > ZADD salary 5000 tom\r\n(integer) 1\r\nredis > ZADD salary 7500 peter\r\n(integer) 1\r\nredis > ZADD salary 3500 joe\r\n(integer) 1\r\nredis > ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员\r\n1) \"jack\"\r\n2) \"peter\"\r\n3) \"tom\"\r\n4) \"joe\"\r\nredis > ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员\r\n1) \"peter\"\r\n2) \"tom\"\r\n3) \"joe\"\r\n```\r\n\r\n------------\r\n\r\n`ZRANK key member`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度: O(log(N))\r\n\r\n返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。\r\n\r\n排名以 0 为底，也就是说， score 值最小的成员排名为 0 。\r\n\r\n使用 `ZREVRANK key member` 命令可以获得成员按 score 值递减(从大到小)排列的排名。\r\n\r\n#### 返回值\r\n如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值\r\n1) \"peter\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"4000\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis> ZRANK salary tom                     # 显示 tom 的薪水排名，第二\r\n(integer) 1\r\n```\r\n\r\n------------\r\n\r\n`ZREVRANK key member`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度: O(log(N))\r\n\r\n返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。\r\n\r\n排名以 0 为底，也就是说， score 值最大的成员排名为 0 。\r\n\r\n使用 `ZRANK key member` 命令可以获得成员按 score 值递增(从小到大)排列的排名。\r\n\r\n#### 返回值\r\n如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis 127.0.0.1:6379> ZRANGE salary 0 -1 WITHSCORES     # 测试数据\r\n1) \"jack\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\nredis> ZREVRANK salary peter     # peter 的工资排第二\r\n(integer) 1\r\nredis> ZREVRANK salary tom       # tom 的工资最高\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n`ZREM key member [member …]`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度: O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。\r\n\r\n移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。\r\n\r\n当 key 存在但不是有序集类型时，返回一个错误。\r\n\r\n> Note\r\n在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。\r\n\r\n#### 返回值\r\n被成功移除的成员的数量，不包括被忽略的成员。\r\n\r\n#### 代码示例\r\n**# 测试数据**\r\n\r\n```shell\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n```\r\n\r\n\r\n**# 移除单个元素**\r\n\r\n```shell\r\nredis> ZREM page_rank google.com\r\n(integer) 1\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n```\r\n\r\n\r\n**# 移除多个元素**\r\n\r\n```shell\r\nredis> ZREM page_rank baidu.com bing.com\r\n(integer) 2\r\nredis> ZRANGE page_rank 0 -1 WITHSCORES\r\n(empty list or set)\r\n```\r\n\r\n\r\n**# 移除不存在元素**\r\n\r\n```shell\r\nredis> ZREM page_rank non-exists-element\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n`ZREMRANGEBYRANK key start stop`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。\r\n\r\n移除有序集 key 中，指定排名(rank)区间内的所有成员。\r\n\r\n区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。\r\n\r\n下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。\r\n\r\n#### 返回值\r\n被移除成员的数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZADD salary 2000 jack\r\n(integer) 1\r\nredis> ZADD salary 5000 tom\r\n(integer) 1\r\nredis> ZADD salary 3500 peter\r\n(integer) 1\r\nredis> ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员\r\n(integer) 2\r\nredis> ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员\r\n1) \"tom\"\r\n2) \"5000\"\r\n```\r\n\r\n------------\r\n\r\n`ZREMRANGEBYSCORE key min max`\r\n> 可用版本： >= 1.2.0\r\n时间复杂度： O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。\r\n\r\n移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\r\n\r\n自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 `ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]` 命令。\r\n\r\n#### 返回值\r\n被移除成员的数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值\r\n1) \"tom\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis> ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工\r\n(integer) 2\r\nredis> ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员\r\n1) \"jack\"\r\n2) \"5000\"\r\n```\r\n\r\n------------\r\n\r\n`ZRANGEBYLEX key min max [LIMIT offset count]`\r\n> 可用版本： >= 2.8.9\r\n时间复杂度：O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则是命令返回的元素数量。 如果 M 是一个常数（比如说，用户总是使用 LIMIT 参数来返回最先的 10 个元素）， 那么命令的复杂度也可以看作是 O(log(N)) 。\r\n\r\n当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。\r\n\r\n如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。\r\n\r\n命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。\r\n\r\n可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。\r\n\r\n如何指定范围区间\r\n合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。\r\n\r\n特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX <zset> - + ， 命令将返回有序集合中的所有元素。\r\n\r\n#### 返回值\r\n数组回复：一个列表，列表里面包含了有序集合在指定范围内的成员。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g\r\n(integer) 7\r\nredis> ZRANGEBYLEX myzset - [c\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\nredis> ZRANGEBYLEX myzset - (c\r\n1) \"a\"\r\n2) \"b\"\r\nredis> ZRANGEBYLEX myzset [aaa (g\r\n1) \"b\"\r\n2) \"c\"\r\n3) \"d\"\r\n4) \"e\"\r\n5) \"f\"\r\n```\r\n\r\n------------\r\n\r\n`ZLEXCOUNT key min max`\r\n> 可用版本： >= 2.8.9\r\n时间复杂度： O(log(N))，其中 N 为有序集合包含的元素数量。\r\n\r\n对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。\r\n\r\n这个命令的 min 参数和 max 参数的意义和 `ZRANGEBYLEX key min max [LIMIT offset count]` 命令的 min 参数和 max 参数的意义一样。\r\n\r\n#### 返回值\r\n整数回复：指定范围内的元素数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZADD myzset 0 a 0 b 0 c 0 d 0 e\r\n(integer) 5\r\nredis> ZADD myzset 0 f 0 g\r\n(integer) 2\r\nredis> ZLEXCOUNT myzset - +\r\n(integer) 7\r\nredis> ZLEXCOUNT myzset [b [f\r\n(integer) 5\r\n```\r\n\r\n------------\r\n\r\n`ZREMRANGEBYLEX key min max`\r\n> 可用版本： >= 2.8.9\r\n时间复杂度： O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则为被移除的元素数量。\r\n\r\n对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。\r\n\r\n这个命令的 min 参数和 max 参数的意义和 `ZRANGEBYLEX key min max [LIMIT offset count] `命令的 min 参数和 max 参数的意义一样。\r\n\r\n#### 返回值\r\n整数回复：被移除的元素数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e\r\n(integer) 5\r\nredis> ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha\r\n(integer) 5\r\nredis> ZRANGE myzset 0 -1\r\n1) \"ALPHA\"\r\n2) \"aaaa\"\r\n3) \"alpha\"\r\n4) \"b\"\r\n5) \"c\"\r\n6) \"d\"\r\n7) \"e\"\r\n8) \"foo\"\r\n9) \"zap\"\r\n10) \"zip\"\r\nredis> ZREMRANGEBYLEX myzset [alpha [omega\r\n(integer) 6\r\nredis> ZRANGE myzset 0 -1\r\n1) \"ALPHA\"\r\n2) \"aaaa\"\r\n3) \"zap\"\r\n4) \"zip\"\r\n```\r\n\r\n------------\r\n\r\n`ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]`\r\n> 可用版本：>= 2.0.0\r\n时间复杂度: O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。\r\n\r\n计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。\r\n\r\n默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。\r\n\r\nWEIGHTS\r\n使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。\r\n\r\n如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。\r\n\r\nAGGREGATE\r\n使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。\r\n\r\n默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。\r\n\r\n#### 返回值\r\n保存到 destination 的结果集的基数。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> ZRANGE programmer 0 -1 WITHSCORES\r\n1) \"peter\"\r\n2) \"2000\"\r\n3) \"jack\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\nredis> ZRANGE manager 0 -1 WITHSCORES\r\n1) \"herry\"\r\n2) \"2000\"\r\n3) \"mary\"\r\n4) \"3500\"\r\n5) \"bob\"\r\n6) \"4000\"\r\nredis> ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。\r\n(integer) 6\r\nredis> ZRANGE salary 0 -1 WITHSCORES\r\n1) \"peter\"\r\n2) \"2000\"\r\n3) \"jack\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\n7) \"herry\"\r\n8) \"6000\"\r\n9) \"mary\"\r\n10) \"10500\"\r\n11) \"bob\"\r\n12) \"12000\"\r\n```\r\n\r\n------------\r\n\r\n`ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度: O(N*K)+O(M*log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。\r\n\r\n计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。\r\n\r\n默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.\r\n\r\n关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 Z`UNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]` 命令。\r\n\r\n#### 返回值\r\n保存到 destination 的结果集的基数。\r\n\r\n#### 代码示例\r\n```shell\r\nredis > ZADD mid_test 70 \"Li Lei\"\r\n(integer) 1\r\nredis > ZADD mid_test 70 \"Han Meimei\"\r\n(integer) 1\r\nredis > ZADD mid_test 99.5 \"Tom\"\r\n(integer) 1\r\nredis > ZADD fin_test 88 \"Li Lei\"\r\n(integer) 1\r\nredis > ZADD fin_test 75 \"Han Meimei\"\r\n(integer) 1\r\nredis > ZADD fin_test 99.5 \"Tom\"\r\n(integer) 1\r\nredis > ZINTERSTORE sum_point 2 mid_test fin_test\r\n(integer) 3\r\nredis > ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值\r\n1) \"Han Meimei\"\r\n2) \"145\"\r\n3) \"Li Lei\"\r\n4) \"158\"\r\n5) \"Tom\"\r\n6) \"199\"\r\n```\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<p><code>ZADD key score member [[score member] [score member] …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。\r\n</blockquote>\r\n<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>\r\n<p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p>\r\n<p>score 值可以是整数值或双精度浮点数。</p>\r\n<p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p>\r\n<p>当 key 存在但不是有序集类型时，返回一个错误。</p>\r\n<p>对有序集的更多介绍请参见 sorted set 。</p>\r\n<blockquote>\r\n<p>Note<br>在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 添加单个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZADD page_rank 10 google.com\r\n(integer) 1\r\n</code></pre>\r\n<p><strong># 添加多个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com\r\n(integer) 2\r\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n</code></pre>\r\n<p><strong># 添加已存在元素，且 score 值不变</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZADD page_rank 10 google.com\r\n(integer) 0\r\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n</code></pre>\r\n<p><strong># 添加已存在元素，但是改变 score 值</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZADD page_rank 6 bing.com\r\n(integer) 0\r\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变\r\n1) \"bing.com\"\r\n2) \"6\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZSCORE key member</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>返回有序集 key 中，成员 member 的 score 值。</p>\r\n<p>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据\r\n1) \"tom\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis&gt; ZSCORE salary peter              # 注意返回值是字符串\r\n\"3500\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZINCRBY key increment member</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(log(N))\r\n</blockquote>\r\n<p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p>\r\n<p>可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 member 的 score 值减去 5 。</p>\r\n<p>当 key 不存在，或 member 不是 key 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member</code> 。</p>\r\n<p>当 key 不是有序集类型时，返回一个错误。</p>\r\n<p>score 值可以是整数值或双精度浮点数。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZSCORE salary tom\r\n\"2000\"\r\nredis&gt; ZINCRBY salary 2000 tom   # tom 加薪啦！\r\n\"4000\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZCARD key</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>返回有序集 key 的基数。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis &gt; ZADD salary 2000 tom    # 添加一个成员\r\n(integer) 1\r\nredis &gt; ZCARD salary\r\n(integer) 1\r\nredis &gt; ZADD salary 5000 jack   # 再添加一个成员\r\n(integer) 1\r\nredis &gt; ZCARD salary\r\n(integer) 2\r\nredis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作\r\n(integer) 0\r\nredis &gt; ZCARD non_exists_key\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<p><code>ZCOUNT key min max</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度: O(log(N))， N 为有序集的基数。\r\n</blockquote>\r\n<p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p>\r\n<p>关于参数 min 和 max 的详细使用方法，请参考 <code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> 命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据\r\n1) \"jack\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\nredis&gt; ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数\r\n(integer) 3\r\nredis&gt; ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数\r\n(integer) 2\r\n</code></pre>\r\n<hr>\r\n<p><code>ZRANGE key start stop [WITHSCORES]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。\r\n</blockquote>\r\n<p>返回有序集 key 中，指定区间内的成员。</p>\r\n<p>其中成员的位置按 score 值递增(从小到大)来排序。</p>\r\n<p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p>\r\n<p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 <code>ZREVRANGE key start stop [WITHSCORES]</code> 命令。</p>\r\n<p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p>\r\n<p>超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</p>\r\n<p>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis &gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员\r\n1) \"jack\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\n5) \"boss\"\r\n6) \"10086\"\r\nredis &gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员\r\n1) \"tom\"\r\n2) \"5000\"\r\n3) \"boss\"\r\n4) \"10086\"\r\nredis &gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况\r\n1) \"jack\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\n5) \"boss\"\r\n6) \"10086\"\r\nredis &gt; ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况\r\n(empty list or set)\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREVRANGE key start stop [WITHSCORES]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。\r\n</blockquote>\r\n<p>返回有序集 key 中，指定区间内的成员。</p>\r\n<p>其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</p>\r\n<p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 递增排列\r\n1) \"peter\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"4000\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis&gt; ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列\r\n1) \"jack\"\r\n2) \"5000\"\r\n3) \"tom\"\r\n4) \"4000\"\r\n5) \"peter\"\r\n6) \"3500\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.0.5<br>时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。\r\n</blockquote>\r\n<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</p>\r\n<p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p>\r\n<p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p>\r\n<p>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</p>\r\n<p>区间及无限<br>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。\r\n<p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p>\r\n<p>举个例子：</p>\r\n<p><code>ZRANGEBYSCORE zset (1 5</code><br>返回所有符合条件 1 < score <= 5 的成员，而\r\n<p><code>ZRANGEBYSCORE zset (5 (10</code><br>则返回所有符合条件 5 < score < 10 的成员。\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p>\r\n<h4 id=\"h4-\"><a name=\"\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span> </h4><p>代码示例</p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZADD salary 2500 jack                        # 测试数据\r\n(integer) 0\r\nredis&gt; ZADD salary 5000 tom\r\n(integer) 0\r\nredis&gt; ZADD salary 12000 peter\r\n(integer) 0\r\nredis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集\r\n1) \"jack\"\r\n2) \"tom\"\r\n3) \"peter\"\r\nredis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值\r\n1) \"jack\"\r\n2) \"2500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\n5) \"peter\"\r\n6) \"12000\"\r\nredis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员\r\n1) \"jack\"\r\n2) \"2500\"\r\n3) \"tom\"\r\n4) \"5000\"\r\nredis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员\r\n1) \"peter\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。\r\n</blockquote>\r\n<p>返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</p>\r\n<p>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</p>\r\n<p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 <code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> 命令一样。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis &gt; ZADD salary 10086 jack\r\n(integer) 1\r\nredis &gt; ZADD salary 5000 tom\r\n(integer) 1\r\nredis &gt; ZADD salary 7500 peter\r\n(integer) 1\r\nredis &gt; ZADD salary 3500 joe\r\n(integer) 1\r\nredis &gt; ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员\r\n1) \"jack\"\r\n2) \"peter\"\r\n3) \"tom\"\r\n4) \"joe\"\r\nredis &gt; ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员\r\n1) \"peter\"\r\n2) \"tom\"\r\n3) \"joe\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZRANK key member</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度: O(log(N))\r\n</blockquote>\r\n<p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p>\r\n<p>排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</p>\r\n<p>使用 <code>ZREVRANK key member</code> 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值\r\n1) \"peter\"\r\n2) \"3500\"\r\n3) \"tom\"\r\n4) \"4000\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis&gt; ZRANK salary tom                     # 显示 tom 的薪水排名，第二\r\n(integer) 1\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREVRANK key member</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度: O(log(N))\r\n</blockquote>\r\n<p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</p>\r\n<p>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</p>\r\n<p>使用 <code>ZRANK key member</code> 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     # 测试数据\r\n1) \"jack\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\nredis&gt; ZREVRANK salary peter     # peter 的工资排第二\r\n(integer) 1\r\nredis&gt; ZREVRANK salary tom       # tom 的工资最高\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREM key member [member …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度: O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。\r\n</blockquote>\r\n<p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p>\r\n<p>当 key 存在但不是有序集类型时，返回一个错误。</p>\r\n<blockquote>\r\n<p>Note<br>在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 测试数据</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n5) \"google.com\"\r\n6) \"10\"\r\n</code></pre>\r\n<p><strong># 移除单个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZREM page_rank google.com\r\n(integer) 1\r\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES\r\n1) \"bing.com\"\r\n2) \"8\"\r\n3) \"baidu.com\"\r\n4) \"9\"\r\n</code></pre>\r\n<p><strong># 移除多个元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZREM page_rank baidu.com bing.com\r\n(integer) 2\r\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES\r\n(empty list or set)\r\n</code></pre>\r\n<p><strong># 移除不存在元素</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; ZREM page_rank non-exists-element\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREMRANGEBYRANK key start stop</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。\r\n</blockquote>\r\n<p>移除有序集 key 中，指定排名(rank)区间内的所有成员。</p>\r\n<p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p>\r\n<p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被移除成员的数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZADD salary 2000 jack\r\n(integer) 1\r\nredis&gt; ZADD salary 5000 tom\r\n(integer) 1\r\nredis&gt; ZADD salary 3500 peter\r\n(integer) 1\r\nredis&gt; ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员\r\n(integer) 2\r\nredis&gt; ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员\r\n1) \"tom\"\r\n2) \"5000\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREMRANGEBYSCORE key min max</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 1.2.0<br>时间复杂度： O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。\r\n</blockquote>\r\n<p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p>\r\n<p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 <code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> 命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被移除成员的数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值\r\n1) \"tom\"\r\n2) \"2000\"\r\n3) \"peter\"\r\n4) \"3500\"\r\n5) \"jack\"\r\n6) \"5000\"\r\nredis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工\r\n(integer) 2\r\nredis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员\r\n1) \"jack\"\r\n2) \"5000\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.9<br>时间复杂度：O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则是命令返回的元素数量。 如果 M 是一个常数（比如说，用户总是使用 LIMIT 参数来返回最先的 10 个元素）， 那么命令的复杂度也可以看作是 O(log(N)) 。\r\n</blockquote>\r\n<p>当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</p>\r\n<p>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</p>\r\n<p>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</p>\r\n<p>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</p>\r\n<p>如何指定范围区间<br>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。\r\n<p>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX <zset> - + ， 命令将返回有序集合中的所有元素。<p></p></zset>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>数组回复：一个列表，列表里面包含了有序集合在指定范围内的成员。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g\r\n(integer) 7\r\nredis&gt; ZRANGEBYLEX myzset - [c\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\nredis&gt; ZRANGEBYLEX myzset - (c\r\n1) \"a\"\r\n2) \"b\"\r\nredis&gt; ZRANGEBYLEX myzset [aaa (g\r\n1) \"b\"\r\n2) \"c\"\r\n3) \"d\"\r\n4) \"e\"\r\n5) \"f\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZLEXCOUNT key min max</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.9<br>时间复杂度： O(log(N))，其中 N 为有序集合包含的元素数量。\r\n</blockquote>\r\n<p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</p>\r\n<p>这个命令的 min 参数和 max 参数的意义和 <code>ZRANGEBYLEX key min max [LIMIT offset count]</code> 命令的 min 参数和 max 参数的意义一样。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>整数回复：指定范围内的元素数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e\r\n(integer) 5\r\nredis&gt; ZADD myzset 0 f 0 g\r\n(integer) 2\r\nredis&gt; ZLEXCOUNT myzset - +\r\n(integer) 7\r\nredis&gt; ZLEXCOUNT myzset [b [f\r\n(integer) 5\r\n</code></pre>\r\n<hr>\r\n<p><code>ZREMRANGEBYLEX key min max</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.9<br>时间复杂度： O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则为被移除的元素数量。\r\n</blockquote>\r\n<p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</p>\r\n<p>这个命令的 min 参数和 max 参数的意义和 <code>ZRANGEBYLEX key min max [LIMIT offset count]</code>命令的 min 参数和 max 参数的意义一样。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>整数回复：被移除的元素数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e\r\n(integer) 5\r\nredis&gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha\r\n(integer) 5\r\nredis&gt; ZRANGE myzset 0 -1\r\n1) \"ALPHA\"\r\n2) \"aaaa\"\r\n3) \"alpha\"\r\n4) \"b\"\r\n5) \"c\"\r\n6) \"d\"\r\n7) \"e\"\r\n8) \"foo\"\r\n9) \"zap\"\r\n10) \"zip\"\r\nredis&gt; ZREMRANGEBYLEX myzset [alpha [omega\r\n(integer) 6\r\nredis&gt; ZRANGE myzset 0 -1\r\n1) \"ALPHA\"\r\n2) \"aaaa\"\r\n3) \"zap\"\r\n4) \"zip\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</code></p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度: O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。\r\n</blockquote>\r\n<p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</p>\r\n<p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p>\r\n<p>WEIGHTS<br>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。\r\n<p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p>\r\n<p>AGGREGATE<br>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。\r\n<p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>保存到 destination 的结果集的基数。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; ZRANGE programmer 0 -1 WITHSCORES\r\n1) \"peter\"\r\n2) \"2000\"\r\n3) \"jack\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\nredis&gt; ZRANGE manager 0 -1 WITHSCORES\r\n1) \"herry\"\r\n2) \"2000\"\r\n3) \"mary\"\r\n4) \"3500\"\r\n5) \"bob\"\r\n6) \"4000\"\r\nredis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。\r\n(integer) 6\r\nredis&gt; ZRANGE salary 0 -1 WITHSCORES\r\n1) \"peter\"\r\n2) \"2000\"\r\n3) \"jack\"\r\n4) \"3500\"\r\n5) \"tom\"\r\n6) \"5000\"\r\n7) \"herry\"\r\n8) \"6000\"\r\n9) \"mary\"\r\n10) \"10500\"\r\n11) \"bob\"\r\n12) \"12000\"\r\n</code></pre>\r\n<hr>\r\n<p><code>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度: O(N<em>K)+O(M</em>log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</p>\r\n</blockquote>\r\n<p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</p>\r\n<p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p>\r\n<p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 Z<code>UNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</code> 命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>保存到 destination 的结果集的基数。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis &gt; ZADD mid_test 70 \"Li Lei\"\r\n(integer) 1\r\nredis &gt; ZADD mid_test 70 \"Han Meimei\"\r\n(integer) 1\r\nredis &gt; ZADD mid_test 99.5 \"Tom\"\r\n(integer) 1\r\nredis &gt; ZADD fin_test 88 \"Li Lei\"\r\n(integer) 1\r\nredis &gt; ZADD fin_test 75 \"Han Meimei\"\r\n(integer) 1\r\nredis &gt; ZADD fin_test 99.5 \"Tom\"\r\n(integer) 1\r\nredis &gt; ZINTERSTORE sum_point 2 mid_test fin_test\r\n(integer) 3\r\nredis &gt; ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值\r\n1) \"Han Meimei\"\r\n2) \"145\"\r\n3) \"Li Lei\"\r\n4) \"158\"\r\n5) \"Tom\"\r\n6) \"199\"\r\n</code></pre>\r\n<hr>\r\n', null, null, null, '2020-11-05 21:52:59', '2020-11-05 21:52:59', '1');
INSERT INTO `articles` VALUES ('79', '1', 'redis常用数据类型---Hash哈希表', '', '`HSET hash field value`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度： O(1)\r\n\r\n将哈希表 hash 中域 field 的值设置为 value 。\r\n\r\n如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。\r\n\r\n如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。\r\n\r\n#### 返回值\r\n当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 。\r\n\r\n#### 代码示例\r\n**设置一个新域：**\r\n\r\n```shell\r\nredis> HSET website google \"www.g.cn\"\r\n(integer) 1\r\nredis> HGET website google\r\n\"www.g.cn\"\r\n```\r\n**对一个已存在的域进行更新：**\r\n```shell\r\nredis> HSET website google \"www.google.com\"\r\n(integer) 0\r\nredis> HGET website google\r\n\"www.google.com\"\r\n```\r\n\r\n------------\r\n\r\n`HSETNX hash field value`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度： O(1)\r\n\r\n当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。\r\n\r\n如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。\r\n\r\n如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。\r\n\r\n#### 返回值\r\nHSETNX 命令在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。\r\n\r\n#### 代码示例\r\n**域尚未存在， 设置成功：**\r\n\r\n```shell\r\nredis> HSETNX database key-value-store Redis\r\n(integer) 1\r\nredis> HGET database key-value-store\r\n\"Redis\"\r\n```\r\n**域已经存在， 设置未成功， 域原有的值未被改变：**\r\n```shell\r\nredis> HSETNX database key-value-store Riak\r\n(integer) 0\r\nredis> HGET database key-value-store\r\n\"Redis\"\r\n\r\n```\r\n\r\n------------\r\n\r\n`HGET hash field`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度： O(1)\r\n\r\n返回哈希表中给定域的值。\r\n\r\n#### 返回值\r\nHGET 命令在默认情况下返回给定域的值。\r\n\r\n如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。\r\n\r\n#### 代码示例\r\n**域存在的情况：**\r\n\r\n```shell\r\nredis> HSET homepage redis redis.com\r\n(integer) 1\r\nredis> HGET homepage redis\r\n\"redis.com\"\r\n```\r\n域不存在的情况：\r\n\r\n```shell\r\nredis> HGET site mysql\r\n(nil)\r\n```\r\n\r\n------------\r\n\r\n\r\n`HEXISTS hash field`\r\n> 可用版本： >= 2.0.0\r\n时间复杂度： O(1)\r\n\r\n检查给定域 field 是否存在于哈希表 hash 当中。\r\n\r\n#### 返回值\r\nHEXISTS 命令在给定域存在时返回 1 ， 在给定域不存在时返回 0 。\r\n\r\n#### 代码示例\r\n**给定域不存在：**\r\n\r\n```shell\r\nredis> HEXISTS phone myphone\r\n(integer) 0\r\n```\r\n**给定域存在：**\r\n```shell\r\nredis> HSET phone myphone nokia-1110\r\n(integer) 1\r\nredis> HEXISTS phone myphone\r\n(integer) 1\r\n```\r\n\r\n------------\r\n\r\n\r\n`HDEL key field [field …]`\r\n\r\n删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。\r\n\r\n> Note\r\n在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 MULTI / EXEC 块内。\r\n\r\n可用版本：>= 2.0.0\r\n\r\n> 时间复杂度:\r\nO(N)， N 为要删除的域的数量。\r\n\r\n#### 返回值:\r\n被成功移除的域的数量，不包括被忽略的域。\r\n\r\n**# 测试数据**\r\n\r\n```shell\r\nredis> HGETALL abbr\r\n1) \"a\"\r\n2) \"apple\"\r\n3) \"b\"\r\n4) \"banana\"\r\n5) \"c\"\r\n6) \"cat\"\r\n7) \"d\"\r\n8) \"dog\"\r\n```\r\n\r\n\r\n**# 删除单个域**\r\n\r\n```shell\r\nredis> HDEL abbr a\r\n(integer) 1\r\n```\r\n\r\n\r\n**# 删除不存在的域**\r\n```shell\r\nredis> HDEL abbr not-exists-field\r\n(integer) 0\r\n```\r\n\r\n\r\n**# 删除多个域**\r\n```shell\r\nredis> HDEL abbr b c\r\n(integer) 2\r\nredis> HGETALL abbr\r\n1) \"d\"\r\n2) \"dog\"\r\n```\r\n\r\n------------\r\n\r\n\r\n`HLEN key`\r\n\r\n返回哈希表 key 中域的数量。\r\n\r\n> 时间复杂度：\r\nO(1)\r\n\r\n#### 返回值：\r\n哈希表中域的数量。\r\n当 key 不存在时，返回 0 。\r\n```shell\r\nredis> HSET db redis redis.com\r\n(integer) 1\r\nredis> HSET db mysql mysql.com\r\n(integer) 1\r\nredis> HLEN db\r\n(integer) 2\r\nredis> HSET db mongodb mongodb.org\r\n(integer) 1\r\nredis> HLEN db\r\n(integer) 3\r\n```\r\n\r\n------------\r\n\r\n`HSTRLEN key field`\r\n\r\n返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。\r\n\r\n如果给定的键或者域不存在， 那么命令返回 0 。\r\n\r\n> 可用版本：>= 3.2.0\r\n时间复杂度：O(1)\r\n\r\n返回值：一个整数。\r\n\r\n```shell\r\nredis> HMSET myhash f1 \"HelloWorld\" f2 \"99\" f3 \"-256\"\r\nOK\r\nredis> HSTRLEN myhash f1\r\n(integer) 10\r\nredis> HSTRLEN myhash f2\r\n(integer) 2\r\nredis> HSTRLEN myhash f3\r\n(integer) 4\r\n```\r\n\r\n------------\r\n\r\n`HINCRBY key field increment`\r\n\r\n为哈希表 key 中的域 field 的值加上增量 increment 。\r\n\r\n增量也可以为负数，相当于对给定域进行减法操作。\r\n\r\n如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。\r\n\r\n如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。\r\n\r\n对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。\r\n\r\n本操作的值被限制在 64 位(bit)有符号数字表示之内。\r\n\r\n> 可用版本：>= 2.0.0\r\n时间复杂度：O(1)\r\n\r\n#### 返回值：\r\n执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。\r\n\r\n**# increment 为正数**\r\n\r\n```shell\r\nredis> HEXISTS counter page_view    # 对空域进行设置\r\n(integer) 0\r\nredis> HINCRBY counter page_view 200\r\n(integer) 200\r\nredis> HGET counter page_view\r\n\"200\"\r\n```\r\n\r\n\r\n**# increment 为负数**\r\n\r\n```shell\r\nredis> HGET counter page_view\r\n\"200\"\r\nredis> HINCRBY counter page_view -50\r\n(integer) 150\r\nredis> HGET counter page_view\r\n\"150\"\r\n```\r\n\r\n\r\n**# 尝试对字符串值的域执行HINCRBY命令**\r\n\r\n```shell\r\nredis> HSET myhash string hello,world       # 设定一个字符串值\r\n(integer) 1\r\nredis> HGET myhash string\r\n\"hello,world\"\r\nredis> HINCRBY myhash string 1              # 命令执行失败，错误。\r\n(error) ERR hash value is not an integer\r\nredis> HGET myhash string                   # 原值不变\r\n\"hello,world\"\r\n```\r\n\r\n------------\r\n\r\n`HINCRBYFLOAT key field increment`\r\n\r\n为哈希表 key 中的域 field 加上浮点数增量 increment 。\r\n\r\n如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。\r\n\r\n如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。\r\n\r\n当以下任意一个条件发生时，返回一个错误：\r\n\r\n域 field 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）\r\n\r\n域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number)\r\n\r\nHINCRBYFLOAT 命令的详细功能和 INCRBYFLOAT key increment 命令类似，请查看 INCRBYFLOAT key increment 命令获取更多相关信息。\r\n\r\n> 可用版本：>= 2.6.0\r\n时间复杂度：O(1)\r\n\r\n#### 返回值：\r\n执行加法操作之后 field 域的值。\r\n\r\n**# 值和增量都是普通小数**\r\n\r\n```shell\r\nredis> HSET mykey field 10.50\r\n(integer) 1\r\nredis> HINCRBYFLOAT mykey field 0.1\r\n\"10.6\"\r\n```\r\n\r\n\r\n**# 值和增量都是指数符号**\r\n\r\n```shell\r\nredis> HSET mykey field 5.0e3\r\n(integer) 0\r\nredis> HINCRBYFLOAT mykey field 2.0e2\r\n\"5200\"\r\n```\r\n\r\n\r\n**# 对不存在的键执行 HINCRBYFLOAT**\r\n\r\n```shell\r\nredis> EXISTS price\r\n(integer) 0\r\nredis> HINCRBYFLOAT price milk 3.5\r\n\"3.5\"\r\nredis> HGETALL price\r\n1) \"milk\"\r\n2) \"3.5\"\r\n```\r\n\r\n\r\n**# 对不存在的域进行 HINCRBYFLOAT**\r\n\r\n```shell\r\nredis> HGETALL price\r\n1) \"milk\"\r\n2) \"3.5\"\r\nredis> HINCRBYFLOAT price coffee 4.5   # 新增 coffee 域\r\n\"4.5\"\r\nredis> HGETALL price\r\n1) \"milk\"\r\n2) \"3.5\"\r\n3) \"coffee\"\r\n4) \"4.5\"\r\n```\r\n\r\n------------\r\n\r\n`HMSET key field value [field value …]`\r\n\r\n同时将多个 field-value (域-值)对设置到哈希表 key 中。\r\n\r\n此命令会覆盖哈希表中已存在的域。\r\n\r\n如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。\r\n\r\n> 可用版本：>= 2.0.0\r\n时间复杂度：O(N)， N 为 field-value 对的数量。\r\n\r\n#### 返回值：\r\n如果命令执行成功，返回 OK 。\r\n当 key 不是哈希表(hash)类型时，返回一个错误。\r\n```shell\r\nredis> HMSET website google www.google.com yahoo www.yahoo.com\r\nOK\r\nredis> HGET website google\r\n\"www.google.com\"\r\nredis> HGET website yahoo\r\n\"www.yahoo.com\"\r\n```\r\n\r\n------------\r\n\r\n`HMGET key field [field …]`\r\n\r\n返回哈希表 key 中，一个或多个给定域的值。\r\n\r\n如果给定的域不存在于哈希表，那么返回一个 nil 值。\r\n\r\n因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。\r\n\r\n> 可用版本：>= 2.0.0\r\n时间复杂度：O(N)， N 为给定域的数量。\r\n\r\n#### 返回值：\r\n一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。\r\n\r\n```shell\r\nredis> HMSET pet dog \"doudou\" cat \"nounou\"    # 一次设置多个域\r\nOK\r\nredis> HMGET pet dog cat fake_pet             # 返回值的顺序和传入参数的顺序一样\r\n1) \"doudou\"\r\n2) \"nounou\"\r\n3) (nil)                                      # 不存在的域返回nil值\r\n```\r\n\r\n------------\r\n\r\n`HKEYS key`\r\n\r\n返回哈希表 key 中的所有域。\r\n\r\n> 可用版本：>= 2.0.0\r\n时间复杂度：O(N)， N 为哈希表的大小。\r\n\r\n#### 返回值：\r\n一个包含哈希表中所有域的表。\r\n当 key 不存在时，返回一个空表。\r\n**# 哈希表非空**\r\n\r\n```shell\r\nredis> HMSET website google www.google.com yahoo www.yahoo.com\r\nOK\r\nredis> HKEYS website\r\n1) \"google\"\r\n2) \"yahoo\"\r\n```\r\n\r\n\r\n**# 空哈希表/key不存在**\r\n\r\n```shell\r\nredis> EXISTS fake_key\r\n(integer) 0\r\nredis> HKEYS fake_key\r\n(empty list or set)\r\n```\r\n\r\n------------\r\n\r\n`HVALS key`\r\n\r\n返回哈希表 key 中所有域的值。\r\n\r\n> 可用版本：>= 2.0.0\r\n时间复杂度：O(N)， N 为哈希表的大小。\r\n\r\n#### 返回值：\r\n一个包含哈希表中所有值的表。\r\n当 key 不存在时，返回一个空表。\r\n**# 非空哈希表**\r\n\r\n```shell\r\nredis> HMSET website google www.google.com yahoo www.yahoo.com\r\nOK\r\nredis> HVALS website\r\n1) \"www.google.com\"\r\n2) \"www.yahoo.com\"\r\n```\r\n\r\n\r\n **# 空哈希表/不存在的key**\r\n\r\n```shell\r\nredis> EXISTS not_exists\r\n(integer) 0\r\nredis> HVALS not_exists\r\n(empty list or set)\r\n```\r\n\r\n------------\r\n\r\n`HGETALL key`\r\n\r\n返回哈希表 key 中，所有的域和值。\r\n\r\n在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。\r\n\r\n> 可用版本：>= 2.0.0\r\n时间复杂度：O(N)， N 为哈希表的大小。\r\n\r\n#### 返回值：\r\n以列表形式返回哈希表的域和域的值。\r\n若 key 不存在，返回空列表。\r\n```shell\r\nredis> HSET people jack \"Jack Sparrow\"\r\n(integer) 1\r\nredis> HSET people gump \"Forrest Gump\"\r\n(integer) 1\r\nredis> HGETALL people\r\n1) \"jack\"          # 域\r\n2) \"Jack Sparrow\"  # 值\r\n3) \"gump\"\r\n4) \"Forrest Gump\"\r\n```\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n', '<p><code>HSET hash field value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>将哈希表 hash 中域 field 的值设置为 value 。</p>\r\n<p>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</p>\r\n<p>如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong>设置一个新域：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET website google \"www.g.cn\"\r\n(integer) 1\r\nredis&gt; HGET website google\r\n\"www.g.cn\"\r\n</code></pre>\r\n<p><strong>对一个已存在的域进行更新：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET website google \"www.google.com\"\r\n(integer) 0\r\nredis&gt; HGET website google\r\n\"www.google.com\"\r\n</code></pre>\r\n<hr>\r\n<p><code>HSETNX hash field value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。</p>\r\n<p>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</p>\r\n<p>如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>HSETNX 命令在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong>域尚未存在， 设置成功：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSETNX database key-value-store Redis\r\n(integer) 1\r\nredis&gt; HGET database key-value-store\r\n\"Redis\"\r\n</code></pre>\r\n<p><strong>域已经存在， 设置未成功， 域原有的值未被改变：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSETNX database key-value-store Riak\r\n(integer) 0\r\nredis&gt; HGET database key-value-store\r\n\"Redis\"\r\n</code></pre>\r\n<hr>\r\n<p><code>HGET hash field</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>返回哈希表中给定域的值。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>HGET 命令在默认情况下返回给定域的值。</p>\r\n<p>如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong>域存在的情况：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET homepage redis redis.com\r\n(integer) 1\r\nredis&gt; HGET homepage redis\r\n\"redis.com\"\r\n</code></pre>\r\n<p>域不存在的情况：</p>\r\n<pre><code class=\"lang-shell\">redis&gt; HGET site mysql\r\n(nil)\r\n</code></pre>\r\n<hr>\r\n<p><code>HEXISTS hash field</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.0.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>检查给定域 field 是否存在于哈希表 hash 当中。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>HEXISTS 命令在给定域存在时返回 1 ， 在给定域不存在时返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong>给定域不存在：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HEXISTS phone myphone\r\n(integer) 0\r\n</code></pre>\r\n<p><strong>给定域存在：</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET phone myphone nokia-1110\r\n(integer) 1\r\nredis&gt; HEXISTS phone myphone\r\n(integer) 1\r\n</code></pre>\r\n<hr>\r\n<p><code>HDEL key field [field …]</code></p>\r\n<p>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</p>\r\n<blockquote>\r\n<p>Note<br>在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 MULTI / EXEC 块内。\r\n</blockquote>\r\n<p>可用版本：&gt;= 2.0.0</p>\r\n<blockquote>\r\n<p>时间复杂度:<br>O(N)， N 为要删除的域的数量。\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值:</h4><p>被成功移除的域的数量，不包括被忽略的域。</p>\r\n<p><strong># 测试数据</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HGETALL abbr\r\n1) \"a\"\r\n2) \"apple\"\r\n3) \"b\"\r\n4) \"banana\"\r\n5) \"c\"\r\n6) \"cat\"\r\n7) \"d\"\r\n8) \"dog\"\r\n</code></pre>\r\n<p><strong># 删除单个域</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HDEL abbr a\r\n(integer) 1\r\n</code></pre>\r\n<p><strong># 删除不存在的域</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HDEL abbr not-exists-field\r\n(integer) 0\r\n</code></pre>\r\n<p><strong># 删除多个域</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HDEL abbr b c\r\n(integer) 2\r\nredis&gt; HGETALL abbr\r\n1) \"d\"\r\n2) \"dog\"\r\n</code></pre>\r\n<hr>\r\n<p><code>HLEN key</code></p>\r\n<p>返回哈希表 key 中域的数量。</p>\r\n<blockquote>\r\n<p>时间复杂度：<br>O(1)\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>哈希表中域的数量。<br>当 key 不存在时，返回 0 。\r\n<pre><code class=\"lang-shell\">redis&gt; HSET db redis redis.com\r\n(integer) 1\r\nredis&gt; HSET db mysql mysql.com\r\n(integer) 1\r\nredis&gt; HLEN db\r\n(integer) 2\r\nredis&gt; HSET db mongodb mongodb.org\r\n(integer) 1\r\nredis&gt; HLEN db\r\n(integer) 3\r\n</code></pre>\r\n<hr>\r\n<p><code>HSTRLEN key field</code></p>\r\n<p>返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</p>\r\n<p>如果给定的键或者域不存在， 那么命令返回 0 。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 3.2.0<br>时间复杂度：O(1)\r\n</blockquote>\r\n<p>返回值：一个整数。</p>\r\n<pre><code class=\"lang-shell\">redis&gt; HMSET myhash f1 \"HelloWorld\" f2 \"99\" f3 \"-256\"\r\nOK\r\nredis&gt; HSTRLEN myhash f1\r\n(integer) 10\r\nredis&gt; HSTRLEN myhash f2\r\n(integer) 2\r\nredis&gt; HSTRLEN myhash f3\r\n(integer) 4\r\n</code></pre>\r\n<hr>\r\n<p><code>HINCRBY key field increment</code></p>\r\n<p>为哈希表 key 中的域 field 的值加上增量 increment 。</p>\r\n<p>增量也可以为负数，相当于对给定域进行减法操作。</p>\r\n<p>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</p>\r\n<p>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</p>\r\n<p>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</p>\r\n<p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度：O(1)\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</p>\r\n<p><strong># increment 为正数</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HEXISTS counter page_view    # 对空域进行设置\r\n(integer) 0\r\nredis&gt; HINCRBY counter page_view 200\r\n(integer) 200\r\nredis&gt; HGET counter page_view\r\n\"200\"\r\n</code></pre>\r\n<p><strong># increment 为负数</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HGET counter page_view\r\n\"200\"\r\nredis&gt; HINCRBY counter page_view -50\r\n(integer) 150\r\nredis&gt; HGET counter page_view\r\n\"150\"\r\n</code></pre>\r\n<p><strong># 尝试对字符串值的域执行HINCRBY命令</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET myhash string hello,world       # 设定一个字符串值\r\n(integer) 1\r\nredis&gt; HGET myhash string\r\n\"hello,world\"\r\nredis&gt; HINCRBY myhash string 1              # 命令执行失败，错误。\r\n(error) ERR hash value is not an integer\r\nredis&gt; HGET myhash string                   # 原值不变\r\n\"hello,world\"\r\n</code></pre>\r\n<hr>\r\n<p><code>HINCRBYFLOAT key field increment</code></p>\r\n<p>为哈希表 key 中的域 field 加上浮点数增量 increment 。</p>\r\n<p>如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</p>\r\n<p>如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</p>\r\n<p>当以下任意一个条件发生时，返回一个错误：</p>\r\n<p>域 field 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</p>\r\n<p>域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number)</p>\r\n<p>HINCRBYFLOAT 命令的详细功能和 INCRBYFLOAT key increment 命令类似，请查看 INCRBYFLOAT key increment 命令获取更多相关信息。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.6.0<br>时间复杂度：O(1)\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>执行加法操作之后 field 域的值。</p>\r\n<p><strong># 值和增量都是普通小数</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET mykey field 10.50\r\n(integer) 1\r\nredis&gt; HINCRBYFLOAT mykey field 0.1\r\n\"10.6\"\r\n</code></pre>\r\n<p><strong># 值和增量都是指数符号</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HSET mykey field 5.0e3\r\n(integer) 0\r\nredis&gt; HINCRBYFLOAT mykey field 2.0e2\r\n\"5200\"\r\n</code></pre>\r\n<p><strong># 对不存在的键执行 HINCRBYFLOAT</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS price\r\n(integer) 0\r\nredis&gt; HINCRBYFLOAT price milk 3.5\r\n\"3.5\"\r\nredis&gt; HGETALL price\r\n1) \"milk\"\r\n2) \"3.5\"\r\n</code></pre>\r\n<p><strong># 对不存在的域进行 HINCRBYFLOAT</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HGETALL price\r\n1) \"milk\"\r\n2) \"3.5\"\r\nredis&gt; HINCRBYFLOAT price coffee 4.5   # 新增 coffee 域\r\n\"4.5\"\r\nredis&gt; HGETALL price\r\n1) \"milk\"\r\n2) \"3.5\"\r\n3) \"coffee\"\r\n4) \"4.5\"\r\n</code></pre>\r\n<hr>\r\n<p><code>HMSET key field value [field value …]</code></p>\r\n<p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p>\r\n<p>此命令会覆盖哈希表中已存在的域。</p>\r\n<p>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度：O(N)， N 为 field-value 对的数量。\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>如果命令执行成功，返回 OK 。<br>当 key 不是哈希表(hash)类型时，返回一个错误。\r\n<pre><code class=\"lang-shell\">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com\r\nOK\r\nredis&gt; HGET website google\r\n\"www.google.com\"\r\nredis&gt; HGET website yahoo\r\n\"www.yahoo.com\"\r\n</code></pre>\r\n<hr>\r\n<p><code>HMGET key field [field …]</code></p>\r\n<p>返回哈希表 key 中，一个或多个给定域的值。</p>\r\n<p>如果给定的域不存在于哈希表，那么返回一个 nil 值。</p>\r\n<p>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度：O(N)， N 为给定域的数量。\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</p>\r\n<pre><code class=\"lang-shell\">redis&gt; HMSET pet dog \"doudou\" cat \"nounou\"    # 一次设置多个域\r\nOK\r\nredis&gt; HMGET pet dog cat fake_pet             # 返回值的顺序和传入参数的顺序一样\r\n1) \"doudou\"\r\n2) \"nounou\"\r\n3) (nil)                                      # 不存在的域返回nil值\r\n</code></pre>\r\n<hr>\r\n<p><code>HKEYS key</code></p>\r\n<p>返回哈希表 key 中的所有域。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度：O(N)， N 为哈希表的大小。\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>一个包含哈希表中所有域的表。<br>当 key 不存在时，返回一个空表。<br><strong># 哈希表非空</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com\r\nOK\r\nredis&gt; HKEYS website\r\n1) \"google\"\r\n2) \"yahoo\"\r\n</code></pre>\r\n<p><strong># 空哈希表/key不存在</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS fake_key\r\n(integer) 0\r\nredis&gt; HKEYS fake_key\r\n(empty list or set)\r\n</code></pre>\r\n<hr>\r\n<p><code>HVALS key</code></p>\r\n<p>返回哈希表 key 中所有域的值。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度：O(N)， N 为哈希表的大小。\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>一个包含哈希表中所有值的表。<br>当 key 不存在时，返回一个空表。<br><strong># 非空哈希表</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com\r\nOK\r\nredis&gt; HVALS website\r\n1) \"www.google.com\"\r\n2) \"www.yahoo.com\"\r\n</code></pre>\r\n<p> <strong># 空哈希表/不存在的key</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS not_exists\r\n(integer) 0\r\nredis&gt; HVALS not_exists\r\n(empty list or set)\r\n</code></pre>\r\n<hr>\r\n<p><code>HGETALL key</code></p>\r\n<p>返回哈希表 key 中，所有的域和值。</p>\r\n<p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p>\r\n<blockquote>\r\n<p>可用版本：&gt;= 2.0.0<br>时间复杂度：O(N)， N 为哈希表的大小。\r\n</blockquote>\r\n<h4 id=\"h4--\"><a name=\"返回值：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值：</h4><p>以列表形式返回哈希表的域和域的值。<br>若 key 不存在，返回空列表。\r\n<pre><code class=\"lang-shell\">redis&gt; HSET people jack \"Jack Sparrow\"\r\n(integer) 1\r\nredis&gt; HSET people gump \"Forrest Gump\"\r\n(integer) 1\r\nredis&gt; HGETALL people\r\n1) \"jack\"          # 域\r\n2) \"Jack Sparrow\"  # 值\r\n3) \"gump\"\r\n4) \"Forrest Gump\"\r\n</code></pre>\r\n<hr>\r\n', null, null, null, '2020-11-05 22:06:59', '2020-11-05 22:06:59', '0');
INSERT INTO `articles` VALUES ('80', '1', 'redis常用数据类型---HyperLogLog', '', '`PFADD key element [element …]`\r\n> 可用版本： >= 2.8.9\r\n时间复杂度： 每添加一个元素的复杂度为 O(1) 。\r\n\r\n将任意数量的元素添加到指定的 HyperLogLog 里面。\r\n\r\n作为这个命令的副作用， HyperLogLog 内部可能会被更新， 以便反映一个不同的唯一元素估计数量（也即是集合的基数）。\r\n\r\n如果 HyperLogLog 估计的近似基数（approximated cardinality）在命令执行之后出现了变化， 那么命令返回 1 ， 否则返回 0 。 如果命令执行时给定的键不存在， 那么程序将先创建一个空的 HyperLogLog 结构， 然后再执行命令。\r\n\r\n调用 `PFADD key element [element …]` 命令时可以只给定键名而不给定元素：\r\n\r\n如果给定键已经是一个 HyperLogLog ， 那么这种调用不会产生任何效果；\r\n\r\n但如果给定的键不存在， 那么命令会创建一个空的 HyperLogLog ， 并向客户端返回 1 。\r\n\r\n要了解更多关于 HyperLogLog 数据结构的介绍知识， 请查阅 PFCOUNT key [key …] 命令的文档。\r\n\r\n#### 返回值\r\n整数回复： 如果 HyperLogLog 的内部储存被修改了， 那么返回 1 ， 否则返回 0 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> PFADD  databases  \"Redis\"  \"MongoDB\"  \"MySQL\"\r\n(integer) 1\r\nredis> PFCOUNT  databases\r\n(integer) 3\r\nredis> PFADD  databases  \"Redis\"    # Redis 已经存在，不必对估计数量进行更新\r\n(integer) 0\r\nredis> PFCOUNT  databases    # 元素估计数量没有变化\r\n(integer) 3\r\nredis> PFADD  databases  \"PostgreSQL\"    # 添加一个不存在的元素\r\n(integer) 1\r\nredis> PFCOUNT  databases    # 估计数量增一\r\n4\r\n```\r\n\r\n------------\r\n\r\n`PFCOUNT key [key …]`\r\n> 可用版本： >= 2.8.9\r\n时间复杂度： 当命令作用于单个 HyperLogLog 时， 复杂度为 O(1) ， 并且具有非常低的平均常数时间。 当命令作用于 N 个 HyperLogLog 时， 复杂度为 O(N) ， 常数时间也比处理单个 HyperLogLog 时要大得多。\r\n\r\n当 `PFCOUNT key [key …] `命令作用于单个键时， 返回储存在给定键的 HyperLogLog 的近似基数， 如果键不存在， 那么返回 0 。\r\n\r\n当 `PFCOUNT key [key …]` 命令作用于多个键时， 返回所有给定 HyperLogLog 的并集的近似基数， 这个近似基数是通过将所有给定 HyperLogLog 合并至一个临时 HyperLogLog 来计算得出的。\r\n\r\n通过 HyperLogLog 数据结构， 用户可以使用少量固定大小的内存， 来储存集合中的唯一元素 （每个 HyperLogLog 只需使用 12k 字节内存，以及几个字节的内存来储存键本身）。\r\n\r\n命令返回的可见集合（observed set）基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。\r\n\r\n举个例子， 为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次 PFADD key element [element …] ， 并通过调用 PFCOUNT key [key …] 命令来获取这个记录的近似结果。\r\n\r\n#### 返回值\r\n整数回复： 给定 HyperLogLog 包含的唯一元素的近似数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> PFADD  databases  \"Redis\"  \"MongoDB\"  \"MySQL\"\r\n(integer) 1\r\nredis> PFCOUNT  databases\r\n(integer) 3\r\nredis> PFADD  databases  \"Redis\"    # Redis 已经存在，不必对估计数量进行更新\r\n(integer) 0\r\nredis> PFCOUNT  databases    # 元素估计数量没有变化\r\n(integer) 3\r\nredis> PFADD  databases  \"PostgreSQL\"    # 添加一个不存在的元素\r\n(integer) 1\r\nredis> PFCOUNT  databases    # 估计数量增\r\n\r\n```\r\n\r\n------------\r\n\r\n\r\n`PFMERGE destkey sourcekey [sourcekey …]`\r\n> 可用版本： >= 2.8.9\r\n时间复杂度： O(N) ， 其中 N 为被合并的 HyperLogLog 数量， 不过这个命令的常数复杂度比较高。\r\n\r\n将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。\r\n\r\n合并得出的 HyperLogLog 会被储存在 destkey 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。\r\n\r\n#### 返回值\r\n字符串回复：返回 OK 。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> PFADD  nosql  \"Redis\"  \"MongoDB\"  \"Memcached\"\r\n(integer) 1\r\nredis> PFADD  RDBMS  \"MySQL\" \"MSSQL\" \"PostgreSQL\"\r\n(integer) 1\r\nredis> PFMERGE  databases  nosql  RDBMS\r\nOK\r\nredis> PFCOUNT  databases\r\n(integer) 6\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<p><code>PFADD key element [element …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.9<br>时间复杂度： 每添加一个元素的复杂度为 O(1) 。\r\n</blockquote>\r\n<p>将任意数量的元素添加到指定的 HyperLogLog 里面。</p>\r\n<p>作为这个命令的副作用， HyperLogLog 内部可能会被更新， 以便反映一个不同的唯一元素估计数量（也即是集合的基数）。</p>\r\n<p>如果 HyperLogLog 估计的近似基数（approximated cardinality）在命令执行之后出现了变化， 那么命令返回 1 ， 否则返回 0 。 如果命令执行时给定的键不存在， 那么程序将先创建一个空的 HyperLogLog 结构， 然后再执行命令。</p>\r\n<p>调用 <code>PFADD key element [element …]</code> 命令时可以只给定键名而不给定元素：</p>\r\n<p>如果给定键已经是一个 HyperLogLog ， 那么这种调用不会产生任何效果；</p>\r\n<p>但如果给定的键不存在， 那么命令会创建一个空的 HyperLogLog ， 并向客户端返回 1 。</p>\r\n<p>要了解更多关于 HyperLogLog 数据结构的介绍知识， 请查阅 PFCOUNT key [key …] 命令的文档。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>整数回复： 如果 HyperLogLog 的内部储存被修改了， 那么返回 1 ， 否则返回 0 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; PFADD  databases  \"Redis\"  \"MongoDB\"  \"MySQL\"\r\n(integer) 1\r\nredis&gt; PFCOUNT  databases\r\n(integer) 3\r\nredis&gt; PFADD  databases  \"Redis\"    # Redis 已经存在，不必对估计数量进行更新\r\n(integer) 0\r\nredis&gt; PFCOUNT  databases    # 元素估计数量没有变化\r\n(integer) 3\r\nredis&gt; PFADD  databases  \"PostgreSQL\"    # 添加一个不存在的元素\r\n(integer) 1\r\nredis&gt; PFCOUNT  databases    # 估计数量增一\r\n4\r\n</code></pre>\r\n<hr>\r\n<p><code>PFCOUNT key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.9<br>时间复杂度： 当命令作用于单个 HyperLogLog 时， 复杂度为 O(1) ， 并且具有非常低的平均常数时间。 当命令作用于 N 个 HyperLogLog 时， 复杂度为 O(N) ， 常数时间也比处理单个 HyperLogLog 时要大得多。\r\n</blockquote>\r\n<p>当 <code>PFCOUNT key [key …]</code>命令作用于单个键时， 返回储存在给定键的 HyperLogLog 的近似基数， 如果键不存在， 那么返回 0 。</p>\r\n<p>当 <code>PFCOUNT key [key …]</code> 命令作用于多个键时， 返回所有给定 HyperLogLog 的并集的近似基数， 这个近似基数是通过将所有给定 HyperLogLog 合并至一个临时 HyperLogLog 来计算得出的。</p>\r\n<p>通过 HyperLogLog 数据结构， 用户可以使用少量固定大小的内存， 来储存集合中的唯一元素 （每个 HyperLogLog 只需使用 12k 字节内存，以及几个字节的内存来储存键本身）。</p>\r\n<p>命令返回的可见集合（observed set）基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。</p>\r\n<p>举个例子， 为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次 PFADD key element [element …] ， 并通过调用 PFCOUNT key [key …] 命令来获取这个记录的近似结果。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>整数回复： 给定 HyperLogLog 包含的唯一元素的近似数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; PFADD  databases  \"Redis\"  \"MongoDB\"  \"MySQL\"\r\n(integer) 1\r\nredis&gt; PFCOUNT  databases\r\n(integer) 3\r\nredis&gt; PFADD  databases  \"Redis\"    # Redis 已经存在，不必对估计数量进行更新\r\n(integer) 0\r\nredis&gt; PFCOUNT  databases    # 元素估计数量没有变化\r\n(integer) 3\r\nredis&gt; PFADD  databases  \"PostgreSQL\"    # 添加一个不存在的元素\r\n(integer) 1\r\nredis&gt; PFCOUNT  databases    # 估计数量增\r\n</code></pre>\r\n<hr>\r\n<p><code>PFMERGE destkey sourcekey [sourcekey …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.9<br>时间复杂度： O(N) ， 其中 N 为被合并的 HyperLogLog 数量， 不过这个命令的常数复杂度比较高。\r\n</blockquote>\r\n<p>将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。</p>\r\n<p>合并得出的 HyperLogLog 会被储存在 destkey 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>字符串回复：返回 OK 。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; PFADD  nosql  \"Redis\"  \"MongoDB\"  \"Memcached\"\r\n(integer) 1\r\nredis&gt; PFADD  RDBMS  \"MySQL\" \"MSSQL\" \"PostgreSQL\"\r\n(integer) 1\r\nredis&gt; PFMERGE  databases  nosql  RDBMS\r\nOK\r\nredis&gt; PFCOUNT  databases\r\n(integer) 6\r\n</code></pre>\r\n', null, null, null, '2020-11-05 22:12:18', '2020-11-05 22:12:18', '1');
INSERT INTO `articles` VALUES ('81', '1', 'redis常用数据类型---地理位置', '', '`GEOADD key longitude latitude member [longitude latitude member …]`\r\n> 可用版本： >= 3.2.0\r\n时间复杂度： 每添加一个元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。\r\n\r\n将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。\r\n\r\nGEOADD 命令以标准的 x,y 格式接受参数， 所以用户必须先输入经度， 然后再输入纬度。 GEOADD 能够记录的坐标是有限的： 非常接近两极的区域是无法被索引的。 精确的坐标限制由 EPSG:900913 / EPSG:3785 / OSGEO:41001 等坐标系统定义， 具体如下：\r\n\r\n有效的经度介于 -180 度至 180 度之间。\r\n\r\n有效的纬度介于 -85.05112878 度至 85.05112878 度之间。\r\n\r\n当用户尝试输入一个超出范围的经度或者纬度时， GEOADD 命令将返回一个错误。\r\n\r\n#### 返回值\r\n新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。\r\n\r\n#### 码示例代码示例\r\n```shell\r\nredis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis> GEODIST Sicily Palermo Catania\r\n\"166274.15156960039\"\r\nredis> GEORADIUS Sicily 15 37 100 km\r\n1) \"Catania\"\r\nredis> GEORADIUS Sicily 15 37 200 km\r\n1) \"Palermo\"\r\n2) \"Catania\"\r\n```\r\n\r\n------------\r\n\r\n`GEOPOS key member [member …]`\r\n> 可用版本： >= 3.2.0\r\n时间复杂度： 获取每个位置元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。\r\n\r\n从键里面返回所有给定位置元素的位置（经度和纬度）。\r\n\r\n因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。\r\n\r\n#### 返回值\r\nGEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis> GEOPOS Sicily Palermo Catania NonExisting\r\n1) 1) \"13.361389338970184\"\r\n   2) \"38.115556395496299\"\r\n2) 1) \"15.087267458438873\"\r\n   2) \"37.50266842333162\"\r\n3) (nil)\r\n```\r\n\r\n------------\r\n\r\n\r\n`GEODIST key member1 member2 [unit]`\r\n> 可用版本： >= 3.2.0\r\n复杂度： O(log(N))\r\n\r\n返回两个给定位置之间的距离。\r\n\r\n如果两个位置之间的其中一个不存在， 那么命令返回空值。\r\n\r\n指定单位的参数 unit 必须是以下单位的其中一个：\r\n\r\nm 表示单位为米。\r\n\r\nkm 表示单位为千米。\r\n\r\nmi 表示单位为英里。\r\n\r\nft 表示单位为英尺。\r\n\r\n如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。\r\n\r\nGEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。\r\n\r\n#### 返回值\r\n计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis> GEODIST Sicily Palermo Catania\r\n\"166274.15156960039\"\r\nredis> GEODIST Sicily Palermo Catania km\r\n\"166.27415156960038\"\r\nredis> GEODIST Sicily Palermo Catania mi\r\n\"103.31822459492736\"\r\nredis> GEODIST Sicily Foo Bar\r\n(nil)\r\n```\r\n\r\n------------\r\n\r\n`GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]`\r\n> 可用版本： >= 3.2.0\r\n时间复杂度： O(N+log(M))， 其中 N 为指定半径范围内的位置元素数量， 而 M 则是被返回位置元素的数量。\r\n\r\n以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。\r\n\r\n范围可以使用以下其中一个单位：\r\n\r\nm 表示单位为米。\r\n\r\nkm 表示单位为千米。\r\n\r\nmi 表示单位为英里。\r\n\r\nft 表示单位为英尺。\r\n\r\n在给定以下可选项时， 命令会返回额外的信息：\r\n\r\nWITHDIST ： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。\r\n\r\nWITHCOORD ： 将位置元素的经度和维度也一并返回。\r\n\r\nWITHHASH ： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。\r\n\r\n命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：\r\n\r\nASC ： 根据中心的位置， 按照从近到远的方式返回位置元素。\r\n\r\nDESC ： 根据中心的位置， 按照从远到近的方式返回位置元素。\r\n\r\n在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT <count> 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。\r\n\r\n#### 返回值\r\nGEORADIUS 命令返回一个数组， 具体来说：\r\n\r\n在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [\"New York\",\"Milan\",\"Paris\"] 这样的线性（linear）列表。\r\n\r\n在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。\r\n\r\n在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：\r\n\r\n以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。\r\n\r\ngeohash 整数。\r\n\r\n由两个元素组成的坐标，分别为经度和纬度。\r\n\r\n举个例子， `GEORADIUS Sicily 15 37 200 km withcoord withdist `这样的命令返回的每个子数组都是类似以下格式的：\r\n\r\n```shell\r\n[\"Palermo\",\"190.4424\",[\"13.361389338970184\",\"38.115556395496299\"]]\r\n```\r\n#### 代码示例\r\n```shell\r\nredis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis> GEORADIUS Sicily 15 37 200 km WITHDIST\r\n1) 1) \"Palermo\"\r\n   2) \"190.4424\"\r\n2) 1) \"Catania\"\r\n   2) \"56.4413\"\r\nredis> GEORADIUS Sicily 15 37 200 km WITHCOORD\r\n1) 1) \"Palermo\"\r\n   2) 1) \"13.361389338970184\"\r\n      2) \"38.115556395496299\"\r\n2) 1) \"Catania\"\r\n   2) 1) \"15.087267458438873\"\r\n      2) \"37.50266842333162\"\r\nredis> GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD\r\n1) 1) \"Palermo\"\r\n   2) \"190.4424\"\r\n   3) 1) \"13.361389338970184\"\r\n      2) \"38.115556395496299\"\r\n2) 1) \"Catania\"\r\n   2) \"56.4413\"\r\n   3) 1) \"15.087267458438873\"\r\n      2) \"37.50266842333162\"\r\n\r\n```\r\n\r\n------------\r\n\r\n`GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]`\r\n> 可用版本： >= 3.2.0\r\n时间复杂度： O(log(N)+M)， 其中 N 为指定范围之内的元素数量， 而 M 则是被返回的元素数量。\r\n\r\n这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点。\r\n\r\n关于 GEORADIUSBYMEMBER 命令的更多信息， 请参考 GEORADIUS 命令的文档。\r\n\r\n#### 返回值\r\n一个数组， 数组中的每个项表示一个范围之内的位置元素。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> GEOADD Sicily 13.583333 37.316667 \"Agrigento\"\r\n(integer) 1\r\nredis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis> GEORADIUSBYMEMBER Sicily Agrigento 100 km\r\n1) \"Agrigento\"\r\n2) \"Palermo\"\r\n```\r\n\r\n------------\r\n\r\n`GEOHASH key member [member …]`\r\n> 可用版本： >= 3.2.0\r\n> 时间复杂度： 寻找每个位置元素的复杂度为 O(log(N)) ， 其中 N 为给定键包含的位置元素数量。\r\n\r\n返回一个或多个位置元素的 Geohash 表示。\r\n\r\n#### 返回值\r\n一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis> GEOHASH Sicily Palermo Catania\r\n1) \"sqc8b49rny0\"\r\n2) \"sqdtr74hyu0\"\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<p><code>GEOADD key longitude latitude member [longitude latitude member …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>时间复杂度： 每添加一个元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。\r\n</blockquote>\r\n<p>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。</p>\r\n<p>GEOADD 命令以标准的 x,y 格式接受参数， 所以用户必须先输入经度， 然后再输入纬度。 GEOADD 能够记录的坐标是有限的： 非常接近两极的区域是无法被索引的。 精确的坐标限制由 EPSG:900913 / EPSG:3785 / OSGEO:41001 等坐标系统定义， 具体如下：</p>\r\n<p>有效的经度介于 -180 度至 180 度之间。</p>\r\n<p>有效的纬度介于 -85.05112878 度至 85.05112878 度之间。</p>\r\n<p>当用户尝试输入一个超出范围的经度或者纬度时， GEOADD 命令将返回一个错误。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</p>\r\n<h4 id=\"h4-u7801u793Au4F8Bu4EE3u7801u793Au4F8B\"><a name=\"码示例代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>码示例代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis&gt; GEODIST Sicily Palermo Catania\r\n\"166274.15156960039\"\r\nredis&gt; GEORADIUS Sicily 15 37 100 km\r\n1) \"Catania\"\r\nredis&gt; GEORADIUS Sicily 15 37 200 km\r\n1) \"Palermo\"\r\n2) \"Catania\"\r\n</code></pre>\r\n<hr>\r\n<p><code>GEOPOS key member [member …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>时间复杂度： 获取每个位置元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。\r\n</blockquote>\r\n<p>从键里面返回所有给定位置元素的位置（经度和纬度）。</p>\r\n<p>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis&gt; GEOPOS Sicily Palermo Catania NonExisting\r\n1) 1) \"13.361389338970184\"\r\n   2) \"38.115556395496299\"\r\n2) 1) \"15.087267458438873\"\r\n   2) \"37.50266842333162\"\r\n3) (nil)\r\n</code></pre>\r\n<hr>\r\n<p><code>GEODIST key member1 member2 [unit]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>复杂度： O(log(N))\r\n</blockquote>\r\n<p>返回两个给定位置之间的距离。</p>\r\n<p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p>\r\n<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>\r\n<p>m 表示单位为米。</p>\r\n<p>km 表示单位为千米。</p>\r\n<p>mi 表示单位为英里。</p>\r\n<p>ft 表示单位为英尺。</p>\r\n<p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</p>\r\n<p>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis&gt; GEODIST Sicily Palermo Catania\r\n\"166274.15156960039\"\r\nredis&gt; GEODIST Sicily Palermo Catania km\r\n\"166.27415156960038\"\r\nredis&gt; GEODIST Sicily Palermo Catania mi\r\n\"103.31822459492736\"\r\nredis&gt; GEODIST Sicily Foo Bar\r\n(nil)\r\n</code></pre>\r\n<hr>\r\n<p><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>时间复杂度： O(N+log(M))， 其中 N 为指定半径范围内的位置元素数量， 而 M 则是被返回位置元素的数量。\r\n</blockquote>\r\n<p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>\r\n<p>范围可以使用以下其中一个单位：</p>\r\n<p>m 表示单位为米。</p>\r\n<p>km 表示单位为千米。</p>\r\n<p>mi 表示单位为英里。</p>\r\n<p>ft 表示单位为英尺。</p>\r\n<p>在给定以下可选项时， 命令会返回额外的信息：</p>\r\n<p>WITHDIST ： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</p>\r\n<p>WITHCOORD ： 将位置元素的经度和维度也一并返回。</p>\r\n<p>WITHHASH ： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</p>\r\n<p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>\r\n<p>ASC ： 根据中心的位置， 按照从近到远的方式返回位置元素。</p>\r\n<p>DESC ： 根据中心的位置， 按照从远到近的方式返回位置元素。</p>\r\n<p>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT <count> 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。<p></p></count>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>GEORADIUS 命令返回一个数组， 具体来说：</p>\r\n<p>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</p>\r\n<p>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</p>\r\n<p>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：</p>\r\n<p>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</p>\r\n<p>geohash 整数。</p>\r\n<p>由两个元素组成的坐标，分别为经度和纬度。</p>\r\n<p>举个例子， <code>GEORADIUS Sicily 15 37 200 km withcoord withdist</code>这样的命令返回的每个子数组都是类似以下格式的：</p>\r\n<pre><code class=\"lang-shell\">[\"Palermo\",\"190.4424\",[\"13.361389338970184\",\"38.115556395496299\"]]\r\n</code></pre>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST\r\n1) 1) \"Palermo\"\r\n   2) \"190.4424\"\r\n2) 1) \"Catania\"\r\n   2) \"56.4413\"\r\nredis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD\r\n1) 1) \"Palermo\"\r\n   2) 1) \"13.361389338970184\"\r\n      2) \"38.115556395496299\"\r\n2) 1) \"Catania\"\r\n   2) 1) \"15.087267458438873\"\r\n      2) \"37.50266842333162\"\r\nredis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD\r\n1) 1) \"Palermo\"\r\n   2) \"190.4424\"\r\n   3) 1) \"13.361389338970184\"\r\n      2) \"38.115556395496299\"\r\n2) 1) \"Catania\"\r\n   2) \"56.4413\"\r\n   3) 1) \"15.087267458438873\"\r\n      2) \"37.50266842333162\"\r\n</code></pre>\r\n<hr>\r\n<p><code>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>时间复杂度： O(log(N)+M)， 其中 N 为指定范围之内的元素数量， 而 M 则是被返回的元素数量。\r\n</blockquote>\r\n<p>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点。</p>\r\n<p>关于 GEORADIUSBYMEMBER 命令的更多信息， 请参考 GEORADIUS 命令的文档。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>一个数组， 数组中的每个项表示一个范围之内的位置元素。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GEOADD Sicily 13.583333 37.316667 \"Agrigento\"\r\n(integer) 1\r\nredis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km\r\n1) \"Agrigento\"\r\n2) \"Palermo\"\r\n</code></pre>\r\n<hr>\r\n<p><code>GEOHASH key member [member …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>时间复杂度： 寻找每个位置元素的复杂度为 O(log(N)) ， 其中 N 为给定键包含的位置元素数量。\r\n</blockquote>\r\n<p>返回一个或多个位置元素的 Geohash 表示。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\r\n(integer) 2\r\nredis&gt; GEOHASH Sicily Palermo Catania\r\n1) \"sqc8b49rny0\"\r\n2) \"sqdtr74hyu0\"\r\n</code></pre>\r\n', null, null, null, '2020-11-05 22:17:39', '2020-11-05 22:17:39', '1');
INSERT INTO `articles` VALUES ('82', '1', 'redis常用数据类型---位图', '', '`SETBIT key offset value`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度: O(1)\r\n\r\n对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。\r\n\r\n位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。\r\n\r\n当 key 不存在时，自动生成一个新的字符串值。\r\n\r\n字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。\r\n\r\noffset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。\r\n\r\n> Warning\r\n对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 SETRANGE key offset value 命令，warning(警告)部分。\r\n\r\n#### 返回值\r\n指定偏移量原来储存的位。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SETBIT bit 10086 1\r\n(integer) 0\r\nredis> GETBIT bit 10086\r\n(integer) 1\r\nredis> GETBIT bit 100   # bit 默认被初始化为 0\r\n(integer) 0\r\n```\r\n\r\n------------\r\n\r\n`GETBIT key offset`\r\n> 可用版本： >= 2.2.0\r\n时间复杂度： O(1)\r\n\r\n对 key 所储存的字符串值，获取指定偏移量上的位(bit)。\r\n\r\n当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。\r\n\r\n#### 返回值\r\n字符串值指定偏移量上的位(bit)。\r\n\r\n#### 代码示例\r\n**# 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0**\r\n\r\n```shell\r\nredis> EXISTS bit\r\n(integer) 0\r\nredis> GETBIT bit 10086\r\n(integer) 0\r\n```\r\n\r\n\r\n**# 对已存在的 offset 进行 GETBIT**\r\n\r\n```shell\r\nredis> SETBIT bit 10086 1\r\n(integer) 0\r\nredis> GETBIT bit 10086\r\n(integer) 1\r\n```\r\n\r\n------------\r\n\r\n\r\n`BITCOUNT key [start] [end]`\r\n> 可用版本： >= 2.6.0\r\n时间复杂度： O(N)\r\n\r\n计算给定字符串中，被设置为 1 的比特位的数量。\r\n\r\n一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。\r\n\r\nstart 和 end 参数的设置和 `GETRANGE key start end` 命令类似，都可以使用负数值： 比如 -1 表示最后一个字节， -2 表示倒数第二个字节，以此类推。\r\n\r\n不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。\r\n\r\n#### 返回值\r\n被设置为 1 的位的数量。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> BITCOUNT bits\r\n(integer) 0\r\nredis> SETBIT bits 0 1          # 0001\r\n(integer) 0\r\nredis> BITCOUNT bits\r\n(integer) 1\r\nredis> SETBIT bits 3 1          # 1001\r\n(integer) 0\r\nredis> BITCOUNT bits\r\n(integer) 2\r\n```\r\n模式：使用 bitmap 实现用户上线次数统计\r\nBitmap 对于一些特定类型的计算非常有效。\r\n\r\n假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 `SETBIT key offset value` 和 `BITCOUNT key [start] [end]` 来实现。\r\n\r\n比如说，每当用户在某一天上线的时候，我们就使用 SETBIT key offset value ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。\r\n\r\n举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 `SETBIT peter 100 1` ；如果明天 peter 也继续阅览网站，那么执行命令 `SETBIT peter 101 1` ，以此类推。\r\n\r\n当要计算 peter 总共以来的上线次数时，就使用 `BITCOUNT key [start] [end] `命令：执行 `BITCOUNT peter` ，得出的结果就是 peter 上线的总天数。\r\n\r\n更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。\r\n\r\n性能\r\n前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， `BITCOUNT key [start] [end] `的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。\r\n\r\n如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：\r\n\r\n将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。\r\n\r\n使用 `BITCOUNT key [start] [end]` 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。\r\n\r\n------------\r\n\r\n`BITPOS key bit [start] [end]`\r\n> 可用版本： >= 2.8.7\r\n时间复杂度： O(N)，其中 N 为位图包含的二进制位数量\r\n\r\n返回位图中第一个值为 bit 的二进制位的位置。\r\n\r\n在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 start 参数和 end 参数指定要检测的范围。\r\n\r\n#### 返回值\r\n整数回复。\r\n\r\n#### 代码示例\r\n```shell\r\n127.0.0.1:6379> SETBIT bits 3 1    # 1000\r\n(integer) 0\r\n127.0.0.1:6379> BITPOS bits 0\r\n(integer) 0\r\n127.0.0.1:6379> BITPOS bits 1\r\n(integer) 3\r\n```\r\n\r\n------------\r\n\r\n`BITOP operation destkey key [key …]`\r\n> 可用版本： >= 2.6.0\r\n时间复杂度： O(N)\r\n\r\n对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\r\n\r\noperation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：\r\n\r\n`BITOP AND destkey key [key ...]` ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。\r\n\r\n`BITOP OR destkey key [key ...]` ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。\r\n\r\n`BITOP XOR destkey key [key ...] `，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。\r\n\r\n`BITOP NOT destkey key` ，对给定 key 求逻辑非，并将结果保存到 destkey 。\r\n\r\n除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。\r\n\r\n处理不同长度的字符串\r\n当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。\r\n\r\n空的 key 也被看作是包含 0 的字符串序列。\r\n\r\n#### 返回值\r\n保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。\r\n\r\n> Note\r\nBITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。\r\n\r\n#### 代码示例\r\n```shell\r\nredis> SETBIT bits-1 0 1        # bits-1 = 1001\r\n(integer) 0\r\nredis> SETBIT bits-1 3 1\r\n(integer) 0\r\nredis> SETBIT bits-2 0 1        # bits-2 = 1011\r\n(integer) 0\r\nredis> SETBIT bits-2 1 1\r\n(integer) 0\r\nredis> SETBIT bits-2 3 1\r\n(integer) 0\r\nredis> BITOP AND and-result bits-1 bits-2\r\n(integer) 1\r\nredis> GETBIT and-result 0      # and-result = 1001\r\n(integer) 1\r\nredis> GETBIT and-result 1\r\n(integer) 0\r\nredis> GETBIT and-result 2\r\n(integer) 0\r\nredis> GETBIT and-result 3\r\n(integer) 1\r\n```\r\n\r\n------------\r\n\r\n`BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]`\r\n> 可用版本： >= 3.2.0\r\n时间复杂度： 每个子命令的复杂度为 O(1) 。\r\n\r\nBITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， BITFIELD 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。\r\n\r\nBITFIELD 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。\r\n\r\n比如以下命令就展示了如何对位于偏移量 100 的 8 位长有符号整数执行加法操作， 并获取位于偏移量 0 上的 4 位长无符号整数：\r\n\r\n> BITFIELD mykey INCRBY i8 100 1 GET u4 0\r\n1) (integer) 1\r\n2) (integer) 0\r\n注意：\r\n\r\n使用 GET 子命令对超出字符串当前范围的二进制位进行访问（包括键不存在的情况）， 超出部分的二进制位的值将被当做是 0 。\r\n\r\n使用 SET 子命令或者 INCRBY 子命令对超出字符串当前范围的二进制位进行访问将导致字符串被扩大， 被扩大的部分会使用值为 0 的二进制位进行填充。 在对字符串进行扩展时， 命令会根据字符串目前已有的最远端二进制位， 计算出执行操作所需的最小长度。\r\n\r\n支持的子命令以及数字类型\r\n以下是 BITFIELD 命令支持的子命令：\r\n\r\n`GET <type> <offset>` —— 返回指定的二进制位范围。\r\n\r\n`SET <type> <offset> <value>` —— 对指定的二进制位范围进行设置，并返回它的旧值。\r\n\r\n`INCRBY <type> <offset> <increment>` —— 对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向 increment 参数传入负值来实现相应的减法操作。\r\n\r\n除了以上三个子命令之外， 还有一个子命令， 它可以改变之后执行的 INCRBY 子命令在发生溢出情况时的行为：\r\n\r\n`OVERFLOW [WRAP|SAT|FAIL]`\r\n\r\n当被设置的二进制位范围值为整数时， 用户可以在类型参数的前面添加 i 来表示有符号整数， 或者使用 u 来表示无符号整数。 比如说， 我们可以使用 u8 来表示 8 位长的无符号整数， 也可以使用 i16 来表示 16 位长的有符号整数。\r\n\r\nBITFIELD 命令最大支持 64 位长的有符号整数以及 63 位长的无符号整数， 其中无符号整数的 63 位长度限制是由于 Redis 协议目前还无法返回 64 位长的无符号整数而导致的。\r\n\r\n二进制位和位置偏移量\r\n在二进制位范围命令中， 用户有两种方法来设置偏移量：\r\n\r\n如果用户给定的是一个没有任何前缀的数字， 那么这个数字指示的就是字符串以零为开始（zero-base）的偏移量。\r\n\r\n另一方面， 如果用户给定的是一个带有 # 前缀的偏移量， 那么命令将使用这个偏移量与被设置的数字类型的位长度相乘， 从而计算出真正的偏移量。\r\n\r\n比如说， 对于以下这个命令来说：\r\n\r\n`BITFIELD mystring SET i8 #0 100 i8 #1 200`\r\n命令会把 mystring 键里面， 第一个 i8 长度的二进制位的值设置为 100 ， 并把第二个 i8 长度的二进制位的值设置为 200 。 当我们把一个字符串键当成数组来使用， 并且数组中储存的都是同等长度的整数时， 使用 # 前缀可以让我们免去手动计算被设置二进制位所在位置的麻烦。\r\n\r\n#### 溢出控制\r\n用户可以通过 OVERFLOW 命令以及以下展示的三个参数， 指定 BITFIELD 命令在执行自增或者自减操作时， 碰上向上溢出（overflow）或者向下溢出（underflow）情况时的行为：\r\n\r\nWRAP ： 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 127 的 i8 整数执行加一操作， 那么将得到结果 -128 。\r\n\r\nSAT ： 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 120 的 i8 整数执行加 10 计算， 那么命令的结果将为 i8 类型所能储存的最大整数值 127 。 与此相反， 如果一个针对 i8 值的计算造成了下溢， 那么这个 i8 值将被设置为 -127 。\r\n\r\nFAIL ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。\r\n\r\n需要注意的是， OVERFLOW 子命令只会对紧随着它之后被执行的 INCRBY 命令产生效果， 这一效果将一直持续到与它一同被执行的下一个 OVERFLOW 命令为止。 在默认情况下， INCRBY 命令使用 WRAP 方式来处理溢出计算。\r\n\r\n**以下是一个使用 OVERFLOW 子命令来控制溢出行为的例子：**\r\n\r\n```shell\r\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 1\r\n2) (integer) 1\r\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 2\r\n2) (integer) 2\r\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 3\r\n2) (integer) 3\r\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 0  -- 使用默认的 WRAP 方式处理溢出\r\n2) (integer) 3  -- 使用 SAT 方式处理溢出\r\n```\r\n**而以下则是一个因为 OVERFLOW FAIL 行为而导致子命令返回空值的例子：**\r\n\r\n```shell\r\n> BITFIELD mykey OVERFLOW FAIL incrby u2 102 1\r\n1) (nil)\r\n```\r\n作用\r\nBITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域： BITFIELD 能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。\r\n\r\n性能注意事项\r\nBITFIELD 在一般情况下都是一个快速的命令， 需要注意的是， 访问一个长度较短的字符串的远端二进制位将引发一次内存分配操作， 这一操作花费的时间可能会比命令访问已有的字符串花费的时间要长。\r\n\r\n二进制位的排列\r\nBITFIELD 把位图第一个字节偏移量 0 上的二进制位看作是 most significant 位， 以此类推。 举个例子， 如果我们对一个已经预先被全部设置为 0 的位图进行设置， 将它在偏移量 7 的值设置为 5 位无符号整数值 23 （二进制位为 10111 ）， 那么命令将生产出以下这个位图表示：\r\n\r\n+--------+--------+\r\n|00000001|01110000|\r\n+--------+--------+\r\n当偏移量和整数长度与字节边界进行对齐时， BITFIELD 表示二进制位的方式跟大端表示法（big endian）一致， 但是在没有对齐的情况下， 理解这些二进制位是如何进行排列也是非常重要的。\r\n\r\n#### 返回值\r\nBITFIELD 命令的返回值是一个数组， 数组中的每个元素对应一个被执行的子命令。 需要注意的是， OVERFLOW 子命令本身并不产生任何回复\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<p><code>SETBIT key offset value</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度: O(1)\r\n</blockquote>\r\n<p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>\r\n<p>位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。</p>\r\n<p>当 key 不存在时，自动生成一个新的字符串值。</p>\r\n<p>字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。</p>\r\n<p>offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p>\r\n<blockquote>\r\n<p>Warning<br>对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 SETRANGE key offset value 命令，warning(警告)部分。\r\n</blockquote>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>指定偏移量原来储存的位。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SETBIT bit 10086 1\r\n(integer) 0\r\nredis&gt; GETBIT bit 10086\r\n(integer) 1\r\nredis&gt; GETBIT bit 100   # bit 默认被初始化为 0\r\n(integer) 0\r\n</code></pre>\r\n<hr>\r\n<p><code>GETBIT key offset</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.2.0<br>时间复杂度： O(1)\r\n</blockquote>\r\n<p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p>\r\n<p>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>字符串值指定偏移量上的位(bit)。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><p><strong># 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; EXISTS bit\r\n(integer) 0\r\nredis&gt; GETBIT bit 10086\r\n(integer) 0\r\n</code></pre>\r\n<p><strong># 对已存在的 offset 进行 GETBIT</strong></p>\r\n<pre><code class=\"lang-shell\">redis&gt; SETBIT bit 10086 1\r\n(integer) 0\r\nredis&gt; GETBIT bit 10086\r\n(integer) 1\r\n</code></pre>\r\n<hr>\r\n<p><code>BITCOUNT key [start] [end]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.6.0<br>时间复杂度： O(N)\r\n</blockquote>\r\n<p>计算给定字符串中，被设置为 1 的比特位的数量。</p>\r\n<p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p>\r\n<p>start 和 end 参数的设置和 <code>GETRANGE key start end</code> 命令类似，都可以使用负数值： 比如 -1 表示最后一个字节， -2 表示倒数第二个字节，以此类推。</p>\r\n<p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>被设置为 1 的位的数量。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; BITCOUNT bits\r\n(integer) 0\r\nredis&gt; SETBIT bits 0 1          # 0001\r\n(integer) 0\r\nredis&gt; BITCOUNT bits\r\n(integer) 1\r\nredis&gt; SETBIT bits 3 1          # 1001\r\n(integer) 0\r\nredis&gt; BITCOUNT bits\r\n(integer) 2\r\n</code></pre>\r\n<p>模式：使用 bitmap 实现用户上线次数统计<br>Bitmap 对于一些特定类型的计算非常有效。\r\n<p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 <code>SETBIT key offset value</code> 和 <code>BITCOUNT key [start] [end]</code> 来实现。</p>\r\n<p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT key offset value ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p>\r\n<p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 <code>SETBIT peter 100 1</code> ；如果明天 peter 也继续阅览网站，那么执行命令 <code>SETBIT peter 101 1</code> ，以此类推。</p>\r\n<p>当要计算 peter 总共以来的上线次数时，就使用 <code>BITCOUNT key [start] [end]</code>命令：执行 <code>BITCOUNT peter</code> ，得出的结果就是 peter 上线的总天数。</p>\r\n<p>更详细的实现可以参考博文(墙外) Fast, easy, realtime metrics using Redis bitmaps 。</p>\r\n<p>性能<br>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， <code>BITCOUNT key [start] [end]</code>的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。</p>\r\n<p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p>\r\n<p>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。</p>\r\n<p>使用 <code>BITCOUNT key [start] [end]</code> 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</p>\r\n<hr>\r\n<p><code>BITPOS key bit [start] [end]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.8.7<br>时间复杂度： O(N)，其中 N 为位图包含的二进制位数量\r\n</blockquote>\r\n<p>返回位图中第一个值为 bit 的二进制位的位置。</p>\r\n<p>在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 start 参数和 end 参数指定要检测的范围。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>整数回复。</p>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">127.0.0.1:6379&gt; SETBIT bits 3 1    # 1000\r\n(integer) 0\r\n127.0.0.1:6379&gt; BITPOS bits 0\r\n(integer) 0\r\n127.0.0.1:6379&gt; BITPOS bits 1\r\n(integer) 3\r\n</code></pre>\r\n<hr>\r\n<p><code>BITOP operation destkey key [key …]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 2.6.0<br>时间复杂度： O(N)\r\n</blockquote>\r\n<p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p>\r\n<p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p>\r\n<p><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</p>\r\n<p><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</p>\r\n<p><code>BITOP XOR destkey key [key ...]</code>，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</p>\r\n<p><code>BITOP NOT destkey key</code> ，对给定 key 求逻辑非，并将结果保存到 destkey 。</p>\r\n<p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p>\r\n<p>处理不同长度的字符串<br>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。\r\n<p>空的 key 也被看作是包含 0 的字符串序列。</p>\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p>\r\n<blockquote>\r\n<p>Note<br>BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。\r\n</blockquote>\r\n<h4 id=\"h4-u4EE3u7801u793Au4F8B\"><a name=\"代码示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码示例</h4><pre><code class=\"lang-shell\">redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001\r\n(integer) 0\r\nredis&gt; SETBIT bits-1 3 1\r\n(integer) 0\r\nredis&gt; SETBIT bits-2 0 1        # bits-2 = 1011\r\n(integer) 0\r\nredis&gt; SETBIT bits-2 1 1\r\n(integer) 0\r\nredis&gt; SETBIT bits-2 3 1\r\n(integer) 0\r\nredis&gt; BITOP AND and-result bits-1 bits-2\r\n(integer) 1\r\nredis&gt; GETBIT and-result 0      # and-result = 1001\r\n(integer) 1\r\nredis&gt; GETBIT and-result 1\r\n(integer) 0\r\nredis&gt; GETBIT and-result 2\r\n(integer) 0\r\nredis&gt; GETBIT and-result 3\r\n(integer) 1\r\n</code></pre>\r\n<hr>\r\n<p><code>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</code></p>\r\n<blockquote>\r\n<p>可用版本： &gt;= 3.2.0<br>时间复杂度： 每个子命令的复杂度为 O(1) 。\r\n</blockquote>\r\n<p>BITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， BITFIELD 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。</p>\r\n<p>BITFIELD 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。</p>\r\n<p>比如以下命令就展示了如何对位于偏移量 100 的 8 位长有符号整数执行加法操作， 并获取位于偏移量 0 上的 4 位长无符号整数：</p>\r\n<blockquote>\r\n<p>BITFIELD mykey INCRBY i8 100 1 GET u4 0<br>1) (integer) 1<br>2) (integer) 0<br>注意：\r\n</blockquote>\r\n<p>使用 GET 子命令对超出字符串当前范围的二进制位进行访问（包括键不存在的情况）， 超出部分的二进制位的值将被当做是 0 。</p>\r\n<p>使用 SET 子命令或者 INCRBY 子命令对超出字符串当前范围的二进制位进行访问将导致字符串被扩大， 被扩大的部分会使用值为 0 的二进制位进行填充。 在对字符串进行扩展时， 命令会根据字符串目前已有的最远端二进制位， 计算出执行操作所需的最小长度。</p>\r\n<p>支持的子命令以及数字类型<br>以下是 BITFIELD 命令支持的子命令：\r\n<p><code>GET &lt;type&gt; &lt;offset&gt;</code> —— 返回指定的二进制位范围。</p>\r\n<p><code>SET &lt;type&gt; &lt;offset&gt; &lt;value&gt;</code> —— 对指定的二进制位范围进行设置，并返回它的旧值。</p>\r\n<p><code>INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt;</code> —— 对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向 increment 参数传入负值来实现相应的减法操作。</p>\r\n<p>除了以上三个子命令之外， 还有一个子命令， 它可以改变之后执行的 INCRBY 子命令在发生溢出情况时的行为：</p>\r\n<p><code>OVERFLOW [WRAP|SAT|FAIL]</code></p>\r\n<p>当被设置的二进制位范围值为整数时， 用户可以在类型参数的前面添加 i 来表示有符号整数， 或者使用 u 来表示无符号整数。 比如说， 我们可以使用 u8 来表示 8 位长的无符号整数， 也可以使用 i16 来表示 16 位长的有符号整数。</p>\r\n<p>BITFIELD 命令最大支持 64 位长的有符号整数以及 63 位长的无符号整数， 其中无符号整数的 63 位长度限制是由于 Redis 协议目前还无法返回 64 位长的无符号整数而导致的。</p>\r\n<p>二进制位和位置偏移量<br>在二进制位范围命令中， 用户有两种方法来设置偏移量：\r\n<p>如果用户给定的是一个没有任何前缀的数字， 那么这个数字指示的就是字符串以零为开始（zero-base）的偏移量。</p>\r\n<p>另一方面， 如果用户给定的是一个带有 # 前缀的偏移量， 那么命令将使用这个偏移量与被设置的数字类型的位长度相乘， 从而计算出真正的偏移量。</p>\r\n<p>比如说， 对于以下这个命令来说：</p>\r\n<p><code>BITFIELD mystring SET i8 #0 100 i8 #1 200</code><br>命令会把 mystring 键里面， 第一个 i8 长度的二进制位的值设置为 100 ， 并把第二个 i8 长度的二进制位的值设置为 200 。 当我们把一个字符串键当成数组来使用， 并且数组中储存的都是同等长度的整数时， 使用 # 前缀可以让我们免去手动计算被设置二进制位所在位置的麻烦。\r\n<h4 id=\"h4-u6EA2u51FAu63A7u5236\"><a name=\"溢出控制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>溢出控制</h4><p>用户可以通过 OVERFLOW 命令以及以下展示的三个参数， 指定 BITFIELD 命令在执行自增或者自减操作时， 碰上向上溢出（overflow）或者向下溢出（underflow）情况时的行为：</p>\r\n<p>WRAP ： 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 127 的 i8 整数执行加一操作， 那么将得到结果 -128 。</p>\r\n<p>SAT ： 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 120 的 i8 整数执行加 10 计算， 那么命令的结果将为 i8 类型所能储存的最大整数值 127 。 与此相反， 如果一个针对 i8 值的计算造成了下溢， 那么这个 i8 值将被设置为 -127 。</p>\r\n<p>FAIL ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。</p>\r\n<p>需要注意的是， OVERFLOW 子命令只会对紧随着它之后被执行的 INCRBY 命令产生效果， 这一效果将一直持续到与它一同被执行的下一个 OVERFLOW 命令为止。 在默认情况下， INCRBY 命令使用 WRAP 方式来处理溢出计算。</p>\r\n<p><strong>以下是一个使用 OVERFLOW 子命令来控制溢出行为的例子：</strong></p>\r\n<pre><code class=\"lang-shell\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 1\r\n2) (integer) 1\r\n&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 2\r\n2) (integer) 2\r\n&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 3\r\n2) (integer) 3\r\n&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\r\n1) (integer) 0  -- 使用默认的 WRAP 方式处理溢出\r\n2) (integer) 3  -- 使用 SAT 方式处理溢出\r\n</code></pre>\r\n<p><strong>而以下则是一个因为 OVERFLOW FAIL 行为而导致子命令返回空值的例子：</strong></p>\r\n<pre><code class=\"lang-shell\">&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1\r\n1) (nil)\r\n</code></pre>\r\n<p>作用<br>BITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域： BITFIELD 能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。\r\n<p>性能注意事项<br>BITFIELD 在一般情况下都是一个快速的命令， 需要注意的是， 访问一个长度较短的字符串的远端二进制位将引发一次内存分配操作， 这一操作花费的时间可能会比命令访问已有的字符串花费的时间要长。\r\n<p>二进制位的排列<br>BITFIELD 把位图第一个字节偏移量 0 上的二进制位看作是 most significant 位， 以此类推。 举个例子， 如果我们对一个已经预先被全部设置为 0 的位图进行设置， 将它在偏移量 7 的值设置为 5 位无符号整数值 23 （二进制位为 10111 ）， 那么命令将生产出以下这个位图表示：\r\n<p>+————+————+<br>|00000001|01110000|<br>+————+————+<br>当偏移量和整数长度与字节边界进行对齐时， BITFIELD 表示二进制位的方式跟大端表示法（big endian）一致， 但是在没有对齐的情况下， 理解这些二进制位是如何进行排列也是非常重要的。\r\n<h4 id=\"h4-u8FD4u56DEu503C\"><a name=\"返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>返回值</h4><p>BITFIELD 命令的返回值是一个数组， 数组中的每个元素对应一个被执行的子命令。 需要注意的是， OVERFLOW 子命令本身并不产生任何回复</p>\r\n', null, null, null, '2020-11-05 22:25:49', '2020-11-05 22:25:49', '1');
INSERT INTO `articles` VALUES ('83', '1', 'SpringBoot-Redis联合Mybatis实现分布式缓存', '', '#### 配置文件\r\n```xml\r\nspring.datasource.druid.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=false\r\nspring.datasource.druid.username=root\r\nspring.datasource.druid.password=sunyue\r\nspring.datasource.druid.initial-size=1\r\nspring.datasource.druid.min-idle=1\r\nspring.datasource.druid.max-active=20\r\nspring.datasource.druid.test-on-borrow=true\r\nspring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver\r\nmybatis.type-aliases-package=com.sunyue.test.entity\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n#打印数据库的操作\r\nlogging.level.com.sunyue.test.dao=debug\r\n#redis缓存\r\n### 配置Redis\r\nmybatis.configuration.cache-enabled=true\r\n# Redis数据库索引（默认为0）\r\nspring.redis.database=0\r\n# Redis服务器地址\r\nspring.redis.host=152.136.30.116\r\n# Redis服务器连接端口\r\nspring.redis.port=6379\r\n# Redis服务器连接密码（默认为空）\r\nspring.redis.password=sunyue\r\n# 连接池最大连接数（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-idle=200\r\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-wait=-1\r\n# 连接池中的最小空闲连接\r\nspring.redis.jedis.pool.min-idle=0\r\n# 连接超时时间（毫秒）\r\nspring.redis.timeout=1000\r\n```\r\n\r\n#### 缓存实体类\r\n这是我们要向Redis中缓存的对象\r\n```java\r\npackage com.sunyue.test.entity;\r\n\r\nimport lombok.Data;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\n\r\n@Data\r\n@Accessors(chain = true)\r\npublic class TestUser implements Serializable {\r\n    private String id;\r\n    private String name;\r\n    private Integer age;\r\n    private Date bir;\r\n}\r\n```\r\n#### Mybatis Dao & Mapper\r\n```java\r\npackage com.sunyue.test.dao;\r\n\r\nimport com.sunyue.test.entity.TestUser;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n@Mapper\r\npublic interface TestUserMapper {\r\n    List<TestUser> findAll();\r\n\r\n    TestUser selectOne(String id);\r\n\r\n    void insert(TestUser testUser);\r\n\r\n    void update(TestUser testUser);\r\n\r\n    void delete(String id);\r\n}\r\n```\r\nMapper:\r\n直接启用Mybatis的<-cache>标签，缓存是本机缓存，所以我们需要实现自定义Redis缓存\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.sunyue.test.dao.TestUserMapper\">\r\n    <!--  开启二级缓存 需要entity开启序列化 type指定自定义缓存策略 -->\r\n    <cache type=\"com.sunyue.test.redis.RedisCache\"/>\r\n    <!-- 关联查询时，需要保证各方缓存的数据都是最新的，采用共享缓存方案 -->\r\n    <!--  <cache-ref namespace=\"com.junsir.dao.PersonDao\"/>-->\r\n    <select id=\"findAll\"  resultType=\"TestUser\">\r\n       select * from test_user\r\n    </select>\r\n    <select id=\"selectOne\" resultType=\"TestUser\">\r\n       select * from test_user where id=#{id}\r\n    </select>\r\n\r\n    <insert id=\"insert\">\r\n        insert into test_user (id,name,age,bir) value (#{id},#{name},#{age},#{bir})\r\n    </insert>\r\n    <update id=\"update\" parameterType=\"com.sunyue.test.entity.TestUser\">\r\n		update test_user set name = #{name},age=#{age},bir=#{bir} where id = #{id}\r\n	</update>\r\n    <delete id=\"delete\">\r\n		delete from test_user where id = #{id}\r\n	</delete>\r\n</mapper>\r\n```\r\n#### RedisCache.java：\r\n此类需要实现org.apache.ibatis.cache.Cache接口，才可以在Mapper中进行指定\r\n```java\r\npackage com.sunyue.test.redis;\r\n\r\nimport com.sunyue.test.utils.ApplicationContextUtils;\r\nimport org.apache.ibatis.cache.Cache;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\nimport org.springframework.util.DigestUtils;\r\n\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\n\r\n/**\r\n * 本类由mybatis初始化 启动时并无法由spring容器管理（盲猜参数无法传递id），故无法注入拿到RedisTemplate\r\n * 要拿到RedisTemplate 需要动下工厂 在工厂启动时拿到RedisTemplate\r\n *\r\n * 实现细节:\r\n * 多表关联查询下的内容保持最新 - 由于DB增删改只会使Redis清空对应key的缓存 所以目的就是让有关联的缓存数据同时进同时出\r\n *\r\n * 实现完毕之后的优化问题:\r\n * 1.key过长会影响redis性能，采用MD5算法对key进行处理，这里利用的是MD5加密算法的唯一性\r\n * */\r\npublic class RedisCache implements Cache {\r\n\r\n    //自定义Cache必要条件\r\n    private final String id;\r\n\r\n    //根据断点 : id:mapper的namespace\r\n    public RedisCache(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    //返回cache的唯一标识\r\n    @Override\r\n    public String getId() {\r\n        return this.id;\r\n    }\r\n\r\n    //重点实现 加入缓存\r\n    @Override\r\n    public void putObject(Object key, Object value) {\r\n        System.out.println(\"加入缓存：key================》\" + key + \"值:value ===================》\" + value);\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        redisTemplate.opsForHash().put(id.toString(),keyToMd5(key.toString()),value);\r\n    }\r\n\r\n    //重点实现 查询缓存\r\n    @Override\r\n    public Object getObject(Object key) {\r\n        System.out.println(\"查询缓存：key================》\" + key );\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        return redisTemplate.opsForHash().get(id.toString(),keyToMd5(key.toString()));\r\n    }\r\n\r\n    //根据指定的key删除缓存 目前没有实现\r\n    @Override\r\n    public Object removeObject(Object o) {\r\n        return null;\r\n    }\r\n\r\n    //清空缓存 执行增删改的时候都会进行clear\r\n    @Override\r\n    public void clear() {\r\n        System.out.println(\"清空缓存\");\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        //清空缓存\r\n        redisTemplate.delete(id.toString());\r\n    }\r\n\r\n    //计算缓存数量\r\n    @Override\r\n    public int getSize() {\r\n\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        //获取哈希中的键值对数量\r\n        return redisTemplate.opsForHash().size(id.toString()).intValue();\r\n    }\r\n\r\n    @Override\r\n    public ReadWriteLock getReadWriteLock() {\r\n        return null;\r\n    }\r\n\r\n    //统一加工redisTemplate 并返回\r\n    private RedisTemplate getRedisTemplate(){\r\n        //获取redisTemplate\r\n        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\");\r\n        //设置序列化策略,因为设置了RedisConfig实例\r\n/*        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());*/\r\n        return redisTemplate;\r\n    }\r\n\r\n\r\n    //优化: 对key做MD5处理\r\n    private String keyToMd5(String key){\r\n        return  DigestUtils.md5DigestAsHex(key.getBytes());\r\n    }\r\n\r\n}\r\n```\r\n#### redis序列化\r\n```java\r\npackage com.sunyue.test.redis;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\r\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\n\r\n@Configuration\r\npublic class RedisConfig {\r\n    /**\r\n     * 由于原生的redis自动装配，在存储key和value时，没有设置序列化方式，故自己创建redisTemplate实例\r\n     * redis的默认方式是JdkSerializationRedisSerializer，key和value都是JdkSerializationRedisSerializer方式的序列化，好处是可以直接支持Object\r\n     * 但是如果需要取值则需要序列化  1) \"\\xac\\xed\\x00\\x05t\\x00\\\"com.sunyue.test.dao.TestUserMapper\"（没有序列化时）\r\n     *                               2) \"com.sunyue.test.dao.TestUserMapper\"（序列化好的）\r\n     *  RedisTemplate<Object, Object> ==> RedisTemplate<String, Object(通常需要key为String，则key设置为stringRedisSerializer这样，值不需要)\r\n     * @param factory\r\n     * @return\r\n     */\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\r\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n        template.setConnectionFactory(factory);\r\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\r\n        ObjectMapper om = new ObjectMapper();\r\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\r\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\r\n        jackson2JsonRedisSerializer.setObjectMapper(om);\r\n        // 使用StringRedisSerializer来序列化/反序列化redis的key值\r\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\r\n        // key采用String的序列化方式\r\n        template.setKeySerializer(stringRedisSerializer);\r\n        // hash的key也采用String的序列化方式\r\n        template.setHashKeySerializer(stringRedisSerializer);\r\n        // value序列化方式采用jackson\r\n        template.setValueSerializer(jackson2JsonRedisSerializer);\r\n        // hash的value序列化方式采用jackson\r\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\r\n        template.afterPropertiesSet();\r\n        return template;\r\n    }\r\n}\r\n```\r\n#### 业务层server实现\r\n```java\r\npackage com.sunyue.test.server.serverImpl;\r\n\r\nimport com.sunyue.test.dao.TestUserMapper;\r\nimport com.sunyue.test.entity.TestUser;\r\nimport com.sunyue.test.server.TestUserServer;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.List;\r\n\r\n@Service\r\n\r\npublic class TestUserServerImpl implements TestUserServer {\r\n    @Autowired\r\n    private TestUserMapper testUserMapper;\r\n\r\n    @Override\r\n    @Transactional\r\n    public List<TestUser> selectAll() {\r\n        return testUserMapper.findAll();\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public TestUser selectByOne(String id){\r\n        return testUserMapper.selectOne(id);\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public void insert(TestUser testUser) {\r\n        testUserMapper.insert(testUser);\r\n        //推荐：在业务层将异常抛出\r\n/*        throw new RuntimeException(\"添加发生异常了..\");*/\r\n    }\r\n\r\n    @Override\r\n    public void delete(String id) {\r\n        testUserMapper.delete(id);\r\n    }\r\n\r\n    @Override\r\n    public void update(TestUser testUser) {\r\n        testUserMapper.update(testUser);\r\n    }\r\n}\r\n```\r\n#### 测试类\r\n```java\r\nimport com.sunyue.test.TestApplication;\r\nimport com.sunyue.test.entity.TestUser;\r\nimport com.sunyue.test.server.TestUserServer;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\n\r\n@SpringBootTest(classes = TestApplication.class)\r\n@RunWith(SpringRunner.class)\r\npublic class RedisTest {\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    @Test\r\n    public void redisTest() {\r\n        TestUser testUser = new TestUser();\r\n        testUser.setId(UUID.randomUUID().toString());\r\n        testUser.setName(\"孙跃\");\r\n        testUser.setBir(new Date());\r\n        testUser.setAge(24);\r\n        testUserServer.insert(testUser);\r\n        TestUser testUser1 = new TestUser();\r\n        testUser1.setId(UUID.randomUUID().toString());\r\n        testUser1.setName(\"孙越\");\r\n        testUser1.setBir(new Date());\r\n        testUser1.setAge(22);\r\n        testUserServer.insert(testUser1);\r\n    }\r\n    @Test\r\n    public void delete(){\r\n        testUserServer.delete(\"93bc9818-a1fd-4012-9f75-f15d6653f912\");\r\n    }\r\n    @Test\r\n    public void update(){\r\n        TestUser testUser = new TestUser();\r\n        testUser.setId(\"1a88f8dc-b9aa-45cf-af53-38e5a6d52b38\");\r\n        testUser.setName(\"孙跃1w\");\r\n        testUser.setBir(new Date());\r\n        testUser.setAge(18);\r\n        testUserServer.update(testUser);\r\n    }\r\n    @Test\r\n    public void select() {\r\n        List<TestUser> testUsers = testUserServer.selectAll();\r\n        testUsers.forEach(System.out::println);\r\n        System.out.println(testUserServer.selectByOne(\"1a88f8dc-b9aa-45cf-af53-38e5a6d52b38\"));\r\n    }\r\n}\r\n```\r\n#### log查看\r\ninsert方法：\r\n```yaml\r\n2020-12-01 21:44:25.300  INFO 3424 --- [           main] RedisTest                                : Started RedisTest in 3.349 seconds (JVM running for 3.94)\r\n2020-12-01 21:44:25.416 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==>  Preparing: insert into test_user (id,name,age,bir) value (?,?,?,?) \r\n2020-12-01 21:44:25.439 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==> Parameters: 5d7af197-a25e-418a-a087-7717bd5d4483(String), 孙跃(String), 24(Integer), 2020-12-01 21:44:25.379(Timestamp)\r\n2020-12-01 21:44:25.446 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : <==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:44:25.510  INFO 3424 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:44:25.510  INFO 3424 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:44:25.794 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==>  Preparing: insert into test_user (id,name,age,bir) value (?,?,?,?) \r\n2020-12-01 21:44:25.794 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==> Parameters: 07222415-adc0-4117-8f85-4a19ea0633d2(String), 孙越(String), 22(Integer), 2020-12-01 21:44:25.792(Timestamp)\r\n2020-12-01 21:44:25.794 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : <==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:44:25.843  INFO 3424 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:44:22 CST 2020]; root of context hierarchy\r\n2020-12-01 21:44:26.976  INFO 3424 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n```\r\nupdate方法：\r\n```yaml\r\n2020-12-01 21:45:38.336  INFO 10076 --- [           main] RedisTest                                : Started RedisTest in 3.47 seconds (JVM running for 4.07)\r\n2020-12-01 21:45:38.457 DEBUG 10076 --- [           main] c.sunyue.test.dao.TestUserMapper.update  : ==>  Preparing: update test_user set name = ?,age=?,bir=? where id = ? \r\n2020-12-01 21:45:38.487 DEBUG 10076 --- [           main] c.sunyue.test.dao.TestUserMapper.update  : ==> Parameters: 孙跃1w(String), 18(Integer), 2020-12-01 21:45:38.427(Timestamp), 1a88f8dc-b9aa-45cf-af53-38e5a6d52b38(String)\r\n2020-12-01 21:45:38.497 DEBUG 10076 --- [           main] c.sunyue.test.dao.TestUserMapper.update  : <==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:45:38.568  INFO 10076 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:45:38.568  INFO 10076 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:45:38.852  INFO 10076 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:45:35 CST 2020]; root of context hierarchy\r\n2020-12-01 21:45:39.986  INFO 10076 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n```\r\ndelete方法：\r\n```yaml\r\n2020-12-01 21:46:29.897  INFO 6072 --- [           main] RedisTest                                : Started RedisTest in 3.391 seconds (JVM running for 3.992)\r\n2020-12-01 21:46:30.009 DEBUG 6072 --- [           main] c.sunyue.test.dao.TestUserMapper.delete  : ==>  Preparing: delete from test_user where id = ? \r\n2020-12-01 21:46:30.029 DEBUG 6072 --- [           main] c.sunyue.test.dao.TestUserMapper.delete  : ==> Parameters: 1a88f8dc-b9aa-45cf-af53-38e5a6d52b38(String)\r\n2020-12-01 21:46:30.036 DEBUG 6072 --- [           main] c.sunyue.test.dao.TestUserMapper.delete  : <==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:46:30.098  INFO 6072 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:46:30.098  INFO 6072 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:46:30.389  INFO 6072 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:46:26 CST 2020]; root of context hierarchy\r\n2020-12-01 21:46:31.522  INFO 6072 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n```\r\nselect方法：\r\n```yaml\r\n2020-12-01 21:48:13.949  INFO 2924 --- [           main] RedisTest                                : Started RedisTest in 3.355 seconds (JVM running for 3.974)\r\n查询缓存：key================》448135888:3833733049:com.sunyue.test.dao.TestUserMapper.findAll:0:2147483647:select * from test_user:SqlSessionFactoryBean\r\n2020-12-01 21:48:14.130  INFO 2924 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:48:14.132  INFO 2924 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:48:14.426 DEBUG 2924 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 0.0\r\n2020-12-01 21:48:14.434 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.findAll      : ==>  Preparing: select * from test_user \r\n2020-12-01 21:48:14.452 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.findAll      : ==> Parameters: \r\n2020-12-01 21:48:14.466 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.findAll      : <==      Total: 5\r\n加入缓存：key================》448135888:3833733049:com.sunyue.test.dao.TestUserMapper.findAll:0:2147483647:select * from test_user:SqlSessionFactoryBean值:value ===================》[TestUser(id=07222415-adc0-4117-8f85-4a19ea0633d2, name=孙越, age=22, bir=Tue Dec 01 00:00:00 CST 2020), TestUser(id=5d7af197-a25e-418a-a087-7717bd5d4483, name=孙跃, age=24, bir=Tue Dec 01 00:00:00 CST 2020), TestUser(id=695601aa-4ad4-449f-92a3-bbae5cc432b0, name=孙越, age=22, bir=Mon Nov 30 00:00:00 CST 2020), TestUser(id=8c2e2f28-d6f1-48e6-930b-0cf431667089, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020), TestUser(id=a2bf3c23-2024-43f1-a328-b09331606c56, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)]\r\nTestUser(id=07222415-adc0-4117-8f85-4a19ea0633d2, name=孙越, age=22, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=5d7af197-a25e-418a-a087-7717bd5d4483, name=孙跃, age=24, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=695601aa-4ad4-449f-92a3-bbae5cc432b0, name=孙越, age=22, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=8c2e2f28-d6f1-48e6-930b-0cf431667089, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=a2bf3c23-2024-43f1-a328-b09331606c56, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\n查询缓存：\r\nkey================》-1510582337:937263828:com.sunyue.test.dao.TestUserMapper.selectOne:0:2147483647:select * from test_user where id=?:1a88f8dc-b9aa-45cf-af53-38e5a6d52b38:SqlSessionFactoryBean\r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 0.0\r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.selectOne    : ==>  Preparing: select * from test_user where id=? \r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.selectOne    : ==> Parameters: 1a88f8dc-b9aa-45cf-af53-38e5a6d52b38(String)\r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.selectOne    : <==      Total: 0\r\n加入缓存：key================》-1510582337:937263828:com.sunyue.test.dao.TestUserMapper.selectOne:0:2147483647:select * from test_user where id=?:1a88f8dc-b9aa-45cf-af53-38e5a6d52b38:SqlSessionFactoryBean值:value ===================》[]\r\nnull\r\n2020-12-01 21:48:14.645  INFO 2924 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:48:10 CST 2020]; root of context hierarchy\r\n2020-12-01 21:48:15.766  INFO 2924 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n```\r\n\r\n再次select方法：\r\n```yaml\r\n2020-12-01 21:49:28.358  INFO 9744 --- [           main] RedisTest                                : Started RedisTest in 3.46 seconds (JVM running for 4.048)\r\n查询缓存：key================》448135888:3833733049:com.sunyue.test.dao.TestUserMapper.findAll:0:2147483647:select * from test_user:SqlSessionFactoryBean\r\n2020-12-01 21:49:28.548  INFO 9744 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:49:28.550  INFO 9744 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:49:28.887 DEBUG 9744 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 1.0\r\nTestUser(id=07222415-adc0-4117-8f85-4a19ea0633d2, name=孙越, age=22, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=5d7af197-a25e-418a-a087-7717bd5d4483, name=孙跃, age=24, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=695601aa-4ad4-449f-92a3-bbae5cc432b0, name=孙越, age=22, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=8c2e2f28-d6f1-48e6-930b-0cf431667089, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=a2bf3c23-2024-43f1-a328-b09331606c56, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\n查询缓存：key================》-1510582337:937263828:com.sunyue.test.dao.TestUserMapper.selectOne:0:2147483647:select * from test_user where id=?:1a88f8dc-b9aa-45cf-af53-38e5a6d52b38:SqlSessionFactoryBean\r\n2020-12-01 21:49:28.933 DEBUG 9744 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 1.0\r\nnull\r\n2020-12-01 21:49:28.936  INFO 9744 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:49:25 CST 2020]; root of context hierarchy\r\n2020-12-01 21:49:30.072  INFO 9744 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n```\r\n\r\n#### 总结一下\r\nmybatis实现分布式缓存中增删改会直接清空缓存，查询会去查redis数据库，如果没有再去查数据库获取，如果redis缓存中存在则不需要查询数据库直接可以在缓存中获取值\r\n', '<h4 id=\"h4-u914Du7F6Eu6587u4EF6\"><a name=\"配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置文件</h4><pre><code class=\"lang-xml\">spring.datasource.druid.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\r\nspring.datasource.druid.username=root\r\nspring.datasource.druid.password=sunyue\r\nspring.datasource.druid.initial-size=1\r\nspring.datasource.druid.min-idle=1\r\nspring.datasource.druid.max-active=20\r\nspring.datasource.druid.test-on-borrow=true\r\nspring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver\r\nmybatis.type-aliases-package=com.sunyue.test.entity\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n#打印数据库的操作\r\nlogging.level.com.sunyue.test.dao=debug\r\n#redis缓存\r\n### 配置Redis\r\nmybatis.configuration.cache-enabled=true\r\n# Redis数据库索引（默认为0）\r\nspring.redis.database=0\r\n# Redis服务器地址\r\nspring.redis.host=152.136.30.116\r\n# Redis服务器连接端口\r\nspring.redis.port=6379\r\n# Redis服务器连接密码（默认为空）\r\nspring.redis.password=sunyue\r\n# 连接池最大连接数（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-idle=200\r\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-wait=-1\r\n# 连接池中的最小空闲连接\r\nspring.redis.jedis.pool.min-idle=0\r\n# 连接超时时间（毫秒）\r\nspring.redis.timeout=1000\r\n</code></pre>\r\n<h4 id=\"h4-u7F13u5B58u5B9Eu4F53u7C7B\"><a name=\"缓存实体类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>缓存实体类</h4><p>这是我们要向Redis中缓存的对象</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.test.entity;\r\n\r\nimport lombok.Data;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\n\r\n@Data\r\n@Accessors(chain = true)\r\npublic class TestUser implements Serializable {\r\n    private String id;\r\n    private String name;\r\n    private Integer age;\r\n    private Date bir;\r\n}\r\n</code></pre>\r\n<h4 id=\"h4-mybatis-dao-amp-mapper\"><a name=\"Mybatis Dao &amp; Mapper\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis Dao &amp; Mapper</h4><pre><code class=\"lang-java\">package com.sunyue.test.dao;\r\n\r\nimport com.sunyue.test.entity.TestUser;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n@Mapper\r\npublic interface TestUserMapper {\r\n    List&lt;TestUser&gt; findAll();\r\n\r\n    TestUser selectOne(String id);\r\n\r\n    void insert(TestUser testUser);\r\n\r\n    void update(TestUser testUser);\r\n\r\n    void delete(String id);\r\n}\r\n</code></pre>\r\n<p>Mapper:<br>直接启用Mybatis的<-cache>标签，缓存是本机缓存，所以我们需要实现自定义Redis缓存\r\n<pre><code class=\"lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\r\n&lt;mapper namespace=\"com.sunyue.test.dao.TestUserMapper\"&gt;\r\n    &lt;!--  开启二级缓存 需要entity开启序列化 type指定自定义缓存策略 --&gt;\r\n    &lt;cache type=\"com.sunyue.test.redis.RedisCache\"/&gt;\r\n    &lt;!-- 关联查询时，需要保证各方缓存的数据都是最新的，采用共享缓存方案 --&gt;\r\n    &lt;!--  &lt;cache-ref namespace=\"com.junsir.dao.PersonDao\"/&gt;--&gt;\r\n    &lt;select id=\"findAll\"  resultType=\"TestUser\"&gt;\r\n       select * from test_user\r\n    &lt;/select&gt;\r\n    &lt;select id=\"selectOne\" resultType=\"TestUser\"&gt;\r\n       select * from test_user where id=#{id}\r\n    &lt;/select&gt;\r\n\r\n    &lt;insert id=\"insert\"&gt;\r\n        insert into test_user (id,name,age,bir) value (#{id},#{name},#{age},#{bir})\r\n    &lt;/insert&gt;\r\n    &lt;update id=\"update\" parameterType=\"com.sunyue.test.entity.TestUser\"&gt;\r\n        update test_user set name = #{name},age=#{age},bir=#{bir} where id = #{id}\r\n    &lt;/update&gt;\r\n    &lt;delete id=\"delete\"&gt;\r\n        delete from test_user where id = #{id}\r\n    &lt;/delete&gt;\r\n&lt;/mapper&gt;\r\n</code></pre>\r\n<h4 id=\"h4-rediscache-java-\"><a name=\"RedisCache.java：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>RedisCache.java：</h4><p>此类需要实现org.apache.ibatis.cache.Cache接口，才可以在Mapper中进行指定</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.test.redis;\r\n\r\nimport com.sunyue.test.utils.ApplicationContextUtils;\r\nimport org.apache.ibatis.cache.Cache;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\nimport org.springframework.util.DigestUtils;\r\n\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\n\r\n/**\r\n * 本类由mybatis初始化 启动时并无法由spring容器管理（盲猜参数无法传递id），故无法注入拿到RedisTemplate\r\n * 要拿到RedisTemplate 需要动下工厂 在工厂启动时拿到RedisTemplate\r\n *\r\n * 实现细节:\r\n * 多表关联查询下的内容保持最新 - 由于DB增删改只会使Redis清空对应key的缓存 所以目的就是让有关联的缓存数据同时进同时出\r\n *\r\n * 实现完毕之后的优化问题:\r\n * 1.key过长会影响redis性能，采用MD5算法对key进行处理，这里利用的是MD5加密算法的唯一性\r\n * */\r\npublic class RedisCache implements Cache {\r\n\r\n    //自定义Cache必要条件\r\n    private final String id;\r\n\r\n    //根据断点 : id:mapper的namespace\r\n    public RedisCache(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    //返回cache的唯一标识\r\n    @Override\r\n    public String getId() {\r\n        return this.id;\r\n    }\r\n\r\n    //重点实现 加入缓存\r\n    @Override\r\n    public void putObject(Object key, Object value) {\r\n        System.out.println(\"加入缓存：key================》\" + key + \"值:value ===================》\" + value);\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        redisTemplate.opsForHash().put(id.toString(),keyToMd5(key.toString()),value);\r\n    }\r\n\r\n    //重点实现 查询缓存\r\n    @Override\r\n    public Object getObject(Object key) {\r\n        System.out.println(\"查询缓存：key================》\" + key );\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        return redisTemplate.opsForHash().get(id.toString(),keyToMd5(key.toString()));\r\n    }\r\n\r\n    //根据指定的key删除缓存 目前没有实现\r\n    @Override\r\n    public Object removeObject(Object o) {\r\n        return null;\r\n    }\r\n\r\n    //清空缓存 执行增删改的时候都会进行clear\r\n    @Override\r\n    public void clear() {\r\n        System.out.println(\"清空缓存\");\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        //清空缓存\r\n        redisTemplate.delete(id.toString());\r\n    }\r\n\r\n    //计算缓存数量\r\n    @Override\r\n    public int getSize() {\r\n\r\n        RedisTemplate redisTemplate = getRedisTemplate();\r\n        //获取哈希中的键值对数量\r\n        return redisTemplate.opsForHash().size(id.toString()).intValue();\r\n    }\r\n\r\n    @Override\r\n    public ReadWriteLock getReadWriteLock() {\r\n        return null;\r\n    }\r\n\r\n    //统一加工redisTemplate 并返回\r\n    private RedisTemplate getRedisTemplate(){\r\n        //获取redisTemplate\r\n        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\");\r\n        //设置序列化策略,因为设置了RedisConfig实例\r\n/*        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());*/\r\n        return redisTemplate;\r\n    }\r\n\r\n\r\n    //优化: 对key做MD5处理\r\n    private String keyToMd5(String key){\r\n        return  DigestUtils.md5DigestAsHex(key.getBytes());\r\n    }\r\n\r\n}\r\n</code></pre>\r\n<h4 id=\"h4-redis-\"><a name=\"redis序列化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis序列化</h4><pre><code class=\"lang-java\">package com.sunyue.test.redis;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\r\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\n\r\n@Configuration\r\npublic class RedisConfig {\r\n    /**\r\n     * 由于原生的redis自动装配，在存储key和value时，没有设置序列化方式，故自己创建redisTemplate实例\r\n     * redis的默认方式是JdkSerializationRedisSerializer，key和value都是JdkSerializationRedisSerializer方式的序列化，好处是可以直接支持Object\r\n     * 但是如果需要取值则需要序列化  1) \"\\xac\\xed\\x00\\x05t\\x00\\\"com.sunyue.test.dao.TestUserMapper\"（没有序列化时）\r\n     *                               2) \"com.sunyue.test.dao.TestUserMapper\"（序列化好的）\r\n     *  RedisTemplate&lt;Object, Object&gt; ==&gt; RedisTemplate&lt;String, Object(通常需要key为String，则key设置为stringRedisSerializer这样，值不需要)\r\n     * @param factory\r\n     * @return\r\n     */\r\n    @Bean\r\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {\r\n        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();\r\n        template.setConnectionFactory(factory);\r\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\r\n        ObjectMapper om = new ObjectMapper();\r\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\r\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\r\n        jackson2JsonRedisSerializer.setObjectMapper(om);\r\n        // 使用StringRedisSerializer来序列化/反序列化redis的key值\r\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\r\n        // key采用String的序列化方式\r\n        template.setKeySerializer(stringRedisSerializer);\r\n        // hash的key也采用String的序列化方式\r\n        template.setHashKeySerializer(stringRedisSerializer);\r\n        // value序列化方式采用jackson\r\n        template.setValueSerializer(jackson2JsonRedisSerializer);\r\n        // hash的value序列化方式采用jackson\r\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\r\n        template.afterPropertiesSet();\r\n        return template;\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"h4--server-\"><a name=\"业务层server实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>业务层server实现</h4><pre><code class=\"lang-java\">package com.sunyue.test.server.serverImpl;\r\n\r\nimport com.sunyue.test.dao.TestUserMapper;\r\nimport com.sunyue.test.entity.TestUser;\r\nimport com.sunyue.test.server.TestUserServer;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.List;\r\n\r\n@Service\r\n\r\npublic class TestUserServerImpl implements TestUserServer {\r\n    @Autowired\r\n    private TestUserMapper testUserMapper;\r\n\r\n    @Override\r\n    @Transactional\r\n    public List&lt;TestUser&gt; selectAll() {\r\n        return testUserMapper.findAll();\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public TestUser selectByOne(String id){\r\n        return testUserMapper.selectOne(id);\r\n    }\r\n\r\n    @Override\r\n    @Transactional(rollbackFor = Exception.class)\r\n    public void insert(TestUser testUser) {\r\n        testUserMapper.insert(testUser);\r\n        //推荐：在业务层将异常抛出\r\n/*        throw new RuntimeException(\"添加发生异常了..\");*/\r\n    }\r\n\r\n    @Override\r\n    public void delete(String id) {\r\n        testUserMapper.delete(id);\r\n    }\r\n\r\n    @Override\r\n    public void update(TestUser testUser) {\r\n        testUserMapper.update(testUser);\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"h4-u6D4Bu8BD5u7C7B\"><a name=\"测试类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试类</h4><pre><code class=\"lang-java\">import com.sunyue.test.TestApplication;\r\nimport com.sunyue.test.entity.TestUser;\r\nimport com.sunyue.test.server.TestUserServer;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\n\r\n@SpringBootTest(classes = TestApplication.class)\r\n@RunWith(SpringRunner.class)\r\npublic class RedisTest {\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    @Test\r\n    public void redisTest() {\r\n        TestUser testUser = new TestUser();\r\n        testUser.setId(UUID.randomUUID().toString());\r\n        testUser.setName(\"孙跃\");\r\n        testUser.setBir(new Date());\r\n        testUser.setAge(24);\r\n        testUserServer.insert(testUser);\r\n        TestUser testUser1 = new TestUser();\r\n        testUser1.setId(UUID.randomUUID().toString());\r\n        testUser1.setName(\"孙越\");\r\n        testUser1.setBir(new Date());\r\n        testUser1.setAge(22);\r\n        testUserServer.insert(testUser1);\r\n    }\r\n    @Test\r\n    public void delete(){\r\n        testUserServer.delete(\"93bc9818-a1fd-4012-9f75-f15d6653f912\");\r\n    }\r\n    @Test\r\n    public void update(){\r\n        TestUser testUser = new TestUser();\r\n        testUser.setId(\"1a88f8dc-b9aa-45cf-af53-38e5a6d52b38\");\r\n        testUser.setName(\"孙跃1w\");\r\n        testUser.setBir(new Date());\r\n        testUser.setAge(18);\r\n        testUserServer.update(testUser);\r\n    }\r\n    @Test\r\n    public void select() {\r\n        List&lt;TestUser&gt; testUsers = testUserServer.selectAll();\r\n        testUsers.forEach(System.out::println);\r\n        System.out.println(testUserServer.selectByOne(\"1a88f8dc-b9aa-45cf-af53-38e5a6d52b38\"));\r\n    }\r\n}\r\n</code></pre>\r\n<h4 id=\"h4-log-\"><a name=\"log查看\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>log查看</h4><p>insert方法：</p>\r\n<pre><code class=\"lang-yaml\">2020-12-01 21:44:25.300  INFO 3424 --- [           main] RedisTest                                : Started RedisTest in 3.349 seconds (JVM running for 3.94)\r\n2020-12-01 21:44:25.416 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==&gt;  Preparing: insert into test_user (id,name,age,bir) value (?,?,?,?) \r\n2020-12-01 21:44:25.439 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==&gt; Parameters: 5d7af197-a25e-418a-a087-7717bd5d4483(String), 孙跃(String), 24(Integer), 2020-12-01 21:44:25.379(Timestamp)\r\n2020-12-01 21:44:25.446 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : &lt;==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:44:25.510  INFO 3424 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:44:25.510  INFO 3424 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:44:25.794 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==&gt;  Preparing: insert into test_user (id,name,age,bir) value (?,?,?,?) \r\n2020-12-01 21:44:25.794 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : ==&gt; Parameters: 07222415-adc0-4117-8f85-4a19ea0633d2(String), 孙越(String), 22(Integer), 2020-12-01 21:44:25.792(Timestamp)\r\n2020-12-01 21:44:25.794 DEBUG 3424 --- [           main] c.sunyue.test.dao.TestUserMapper.insert  : &lt;==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:44:25.843  INFO 3424 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:44:22 CST 2020]; root of context hierarchy\r\n2020-12-01 21:44:26.976  INFO 3424 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n</code></pre>\r\n<p>update方法：</p>\r\n<pre><code class=\"lang-yaml\">2020-12-01 21:45:38.336  INFO 10076 --- [           main] RedisTest                                : Started RedisTest in 3.47 seconds (JVM running for 4.07)\r\n2020-12-01 21:45:38.457 DEBUG 10076 --- [           main] c.sunyue.test.dao.TestUserMapper.update  : ==&gt;  Preparing: update test_user set name = ?,age=?,bir=? where id = ? \r\n2020-12-01 21:45:38.487 DEBUG 10076 --- [           main] c.sunyue.test.dao.TestUserMapper.update  : ==&gt; Parameters: 孙跃1w(String), 18(Integer), 2020-12-01 21:45:38.427(Timestamp), 1a88f8dc-b9aa-45cf-af53-38e5a6d52b38(String)\r\n2020-12-01 21:45:38.497 DEBUG 10076 --- [           main] c.sunyue.test.dao.TestUserMapper.update  : &lt;==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:45:38.568  INFO 10076 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:45:38.568  INFO 10076 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:45:38.852  INFO 10076 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:45:35 CST 2020]; root of context hierarchy\r\n2020-12-01 21:45:39.986  INFO 10076 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n</code></pre>\r\n<p>delete方法：</p>\r\n<pre><code class=\"lang-yaml\">2020-12-01 21:46:29.897  INFO 6072 --- [           main] RedisTest                                : Started RedisTest in 3.391 seconds (JVM running for 3.992)\r\n2020-12-01 21:46:30.009 DEBUG 6072 --- [           main] c.sunyue.test.dao.TestUserMapper.delete  : ==&gt;  Preparing: delete from test_user where id = ? \r\n2020-12-01 21:46:30.029 DEBUG 6072 --- [           main] c.sunyue.test.dao.TestUserMapper.delete  : ==&gt; Parameters: 1a88f8dc-b9aa-45cf-af53-38e5a6d52b38(String)\r\n2020-12-01 21:46:30.036 DEBUG 6072 --- [           main] c.sunyue.test.dao.TestUserMapper.delete  : &lt;==    Updates: 1\r\n清空缓存\r\n2020-12-01 21:46:30.098  INFO 6072 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:46:30.098  INFO 6072 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:46:30.389  INFO 6072 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:46:26 CST 2020]; root of context hierarchy\r\n2020-12-01 21:46:31.522  INFO 6072 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n</code></pre>\r\n<p>select方法：</p>\r\n<pre><code class=\"lang-yaml\">2020-12-01 21:48:13.949  INFO 2924 --- [           main] RedisTest                                : Started RedisTest in 3.355 seconds (JVM running for 3.974)\r\n查询缓存：key================》448135888:3833733049:com.sunyue.test.dao.TestUserMapper.findAll:0:2147483647:select * from test_user:SqlSessionFactoryBean\r\n2020-12-01 21:48:14.130  INFO 2924 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:48:14.132  INFO 2924 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:48:14.426 DEBUG 2924 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 0.0\r\n2020-12-01 21:48:14.434 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.findAll      : ==&gt;  Preparing: select * from test_user \r\n2020-12-01 21:48:14.452 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.findAll      : ==&gt; Parameters: \r\n2020-12-01 21:48:14.466 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.findAll      : &lt;==      Total: 5\r\n加入缓存：key================》448135888:3833733049:com.sunyue.test.dao.TestUserMapper.findAll:0:2147483647:select * from test_user:SqlSessionFactoryBean值:value ===================》[TestUser(id=07222415-adc0-4117-8f85-4a19ea0633d2, name=孙越, age=22, bir=Tue Dec 01 00:00:00 CST 2020), TestUser(id=5d7af197-a25e-418a-a087-7717bd5d4483, name=孙跃, age=24, bir=Tue Dec 01 00:00:00 CST 2020), TestUser(id=695601aa-4ad4-449f-92a3-bbae5cc432b0, name=孙越, age=22, bir=Mon Nov 30 00:00:00 CST 2020), TestUser(id=8c2e2f28-d6f1-48e6-930b-0cf431667089, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020), TestUser(id=a2bf3c23-2024-43f1-a328-b09331606c56, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)]\r\nTestUser(id=07222415-adc0-4117-8f85-4a19ea0633d2, name=孙越, age=22, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=5d7af197-a25e-418a-a087-7717bd5d4483, name=孙跃, age=24, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=695601aa-4ad4-449f-92a3-bbae5cc432b0, name=孙越, age=22, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=8c2e2f28-d6f1-48e6-930b-0cf431667089, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=a2bf3c23-2024-43f1-a328-b09331606c56, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\n查询缓存：\r\nkey================》-1510582337:937263828:com.sunyue.test.dao.TestUserMapper.selectOne:0:2147483647:select * from test_user where id=?:1a88f8dc-b9aa-45cf-af53-38e5a6d52b38:SqlSessionFactoryBean\r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 0.0\r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.selectOne    : ==&gt;  Preparing: select * from test_user where id=? \r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.selectOne    : ==&gt; Parameters: 1a88f8dc-b9aa-45cf-af53-38e5a6d52b38(String)\r\n2020-12-01 21:48:14.596 DEBUG 2924 --- [           main] c.s.test.dao.TestUserMapper.selectOne    : &lt;==      Total: 0\r\n加入缓存：key================》-1510582337:937263828:com.sunyue.test.dao.TestUserMapper.selectOne:0:2147483647:select * from test_user where id=?:1a88f8dc-b9aa-45cf-af53-38e5a6d52b38:SqlSessionFactoryBean值:value ===================》[]\r\nnull\r\n2020-12-01 21:48:14.645  INFO 2924 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:48:10 CST 2020]; root of context hierarchy\r\n2020-12-01 21:48:15.766  INFO 2924 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n</code></pre>\r\n<p>再次select方法：</p>\r\n<pre><code class=\"lang-yaml\">2020-12-01 21:49:28.358  INFO 9744 --- [           main] RedisTest                                : Started RedisTest in 3.46 seconds (JVM running for 4.048)\r\n查询缓存：key================》448135888:3833733049:com.sunyue.test.dao.TestUserMapper.findAll:0:2147483647:select * from test_user:SqlSessionFactoryBean\r\n2020-12-01 21:49:28.548  INFO 9744 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library\r\n2020-12-01 21:49:28.550  INFO 9744 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library\r\n2020-12-01 21:49:28.887 DEBUG 9744 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 1.0\r\nTestUser(id=07222415-adc0-4117-8f85-4a19ea0633d2, name=孙越, age=22, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=5d7af197-a25e-418a-a087-7717bd5d4483, name=孙跃, age=24, bir=Tue Dec 01 00:00:00 CST 2020)\r\nTestUser(id=695601aa-4ad4-449f-92a3-bbae5cc432b0, name=孙越, age=22, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=8c2e2f28-d6f1-48e6-930b-0cf431667089, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\nTestUser(id=a2bf3c23-2024-43f1-a328-b09331606c56, name=孙跃, age=24, bir=Mon Nov 30 00:00:00 CST 2020)\r\n查询缓存：key================》-1510582337:937263828:com.sunyue.test.dao.TestUserMapper.selectOne:0:2147483647:select * from test_user where id=?:1a88f8dc-b9aa-45cf-af53-38e5a6d52b38:SqlSessionFactoryBean\r\n2020-12-01 21:49:28.933 DEBUG 9744 --- [           main] com.sunyue.test.dao.TestUserMapper       : Cache Hit Ratio [com.sunyue.test.dao.TestUserMapper]: 1.0\r\nnull\r\n2020-12-01 21:49:28.936  INFO 9744 --- [       Thread-5] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@1f760b47: startup date [Tue Dec 01 21:49:25 CST 2020]; root of context hierarchy\r\n2020-12-01 21:49:30.072  INFO 9744 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed\r\n</code></pre>\r\n<h4 id=\"h4-u603Bu7ED3u4E00u4E0B\"><a name=\"总结一下\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结一下</h4><p>mybatis实现分布式缓存中增删改会直接清空缓存，查询会去查redis数据库，如果没有再去查数据库获取，如果redis缓存中存在则不需要查询数据库直接可以在缓存中获取值</p>\r\n', null, null, null, '2020-12-01 21:52:58', '2020-12-01 21:52:58', '1');
INSERT INTO `articles` VALUES ('84', '1', 'Ubuntu16.04安装Redis并配置', '', '> Ubuntu16.04安装Redis并配置\r\n\r\n#### 1):安装:\r\n1:终端命令下载redis-4.0.9.tar.gz包\r\nwget http://download.redis.io/releases/redis-4.0.9.tar.gz包\r\n2:解压\r\ntar xzf redis-4.0.9.tar.gz\r\n3:移动，放到usr/local⽬录下\r\nsudo mv ./redis-4.0.9 /usr/local/redis/\r\n4:进⼊redis⽬录\r\ncd /usr/local/redis/\r\n5:生成\r\nsudo make\r\n6:测试,这段运⾏时间会较⻓\r\nsudo make test\r\n7:安装,将redis的命令安装到/usr/local/bin/⽬录\r\nsudo make install\r\n8:安装完成后，进入目录/usr/local/bin中查看\r\ncd /usr/local/bin\r\nls -all\r\n\r\nredis-server redis服务器\r\nredis-cli redis命令行客户端\r\nredis-benchmark redis性能测试工具\r\nredis-check-aof AOF文件修复工具\r\nredis-check-rdb RDB文件检索工具\r\n\r\n9:把配置⽂件移动到/etc/redis⽬录下\r\n配置⽂件⽬录为/usr/local/redis/redis.conf\r\n在/etc/目录下创建redis目录,然后移动配置文件\r\nsudo cp /usr/local/redis/redis.conf /etc/redis/\r\n#### 2):配置\r\n1:查看\r\nRedis的配置信息在/etc/redis/redis.conf下\r\nsudo vim /etc/redis/redis.conf\r\n2:核心配置\r\n绑定ip：如果需要远程访问，可将此⾏注释，或绑定⼀个真实ip\r\nbind 127.0.0.1\r\n端⼝，默认为6379\r\nport 6379\r\n**是否以守护进程运⾏**\r\n如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务\r\n如果以⾮守护进程运⾏，则当前终端被阻塞\r\n设置为yes表示守护进程，设置为no表示⾮守护进程\r\n推荐设置为yes\r\ndaemonize yes\r\n数据⽂件\r\ndbfilename dump.rdb\r\n数据⽂件存储路径\r\ndir /var/lib/redis\r\n⽇志⽂件\r\nlogfile \"/var/log/redis/redis-server.log\"\r\n数据库，默认有16个\r\ndatabase 16\r\n#### 3）：注\r\n在安装redis过程中make会报错，原因是ubuntu16.04系统gcc版本低\r\n**解决方案**\r\n1 首先添加ppa到库\r\n\r\n    sudo add-apt-repository ppa:ubuntu-toolchain-r/test\r\n    sudo apt-get update\r\n如果提示未安装，还需要先安装它的包\r\n`sudo apt-get install software-properties-common`\r\n现在我的系统中安装的是gcc-4.7，前面提到过，由于我的误操作，删除了我本身系统的8.0的gcc，所以我现在要先下载安装\r\n`sudo apt-get install gcc-8 g++-8`\r\n安装成功！\r\n更新一下链接\r\n```shell\r\nupdate-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 53 \\\r\n--slave /usr/bin/g++ g++ /usr/bin/g++-8 \\\r\n--slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-8 \\\r\n--slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-8 \\\r\n--slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-8\r\n```\r\nOK！完成！\r\n输入gcc --version\r\n我就看到自己的gcc版本已经是8版本了！', '<blockquote>\r\n<p>Ubuntu16.04安装Redis并配置</p>\r\n</blockquote>\r\n<h4 id=\"h4-1-\"><a name=\"1):安装:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1):安装:</h4><p>1:终端命令下载redis-4.0.9.tar.gz包<br>wget <a href=\"http://download.redis.io/releases/redis-4.0.9.tar.gz包\">http://download.redis.io/releases/redis-4.0.9.tar.gz包</a><br>2:解压<br>tar xzf redis-4.0.9.tar.gz<br>3:移动，放到usr/local⽬录下<br>sudo mv ./redis-4.0.9 /usr/local/redis/<br>4:进⼊redis⽬录<br>cd /usr/local/redis/<br>5:生成<br>sudo make<br>6:测试,这段运⾏时间会较⻓<br>sudo make test<br>7:安装,将redis的命令安装到/usr/local/bin/⽬录<br>sudo make install<br>8:安装完成后，进入目录/usr/local/bin中查看<br>cd /usr/local/bin<br>ls -all\r\n<p>redis-server redis服务器<br>redis-cli redis命令行客户端<br>redis-benchmark redis性能测试工具<br>redis-check-aof AOF文件修复工具<br>redis-check-rdb RDB文件检索工具\r\n<p>9:把配置⽂件移动到/etc/redis⽬录下<br>配置⽂件⽬录为/usr/local/redis/redis.conf<br>在/etc/目录下创建redis目录,然后移动配置文件<br>sudo cp /usr/local/redis/redis.conf /etc/redis/\r\n<h4 id=\"h4-2-\"><a name=\"2):配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2):配置</h4><p>1:查看<br>Redis的配置信息在/etc/redis/redis.conf下<br>sudo vim /etc/redis/redis.conf<br>2:核心配置<br>绑定ip：如果需要远程访问，可将此⾏注释，或绑定⼀个真实ip<br>bind 127.0.0.1<br>端⼝，默认为6379<br>port 6379<br><strong>是否以守护进程运⾏</strong><br>如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务<br>如果以⾮守护进程运⾏，则当前终端被阻塞<br>设置为yes表示守护进程，设置为no表示⾮守护进程<br>推荐设置为yes<br>daemonize yes<br>数据⽂件<br>dbfilename dump.rdb<br>数据⽂件存储路径<br>dir /var/lib/redis<br>⽇志⽂件<br>logfile “/var/log/redis/redis-server.log”<br>数据库，默认有16个<br>database 16\r\n<h4 id=\"h4-3-\"><a name=\"3）：注\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3）：注</h4><p>在安装redis过程中make会报错，原因是ubuntu16.04系统gcc版本低<br><strong>解决方案</strong><br>1 首先添加ppa到库\r\n<pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test\r\nsudo apt-get update\r\n</code></pre><p>如果提示未安装，还需要先安装它的包<br><code>sudo apt-get install software-properties-common</code><br>现在我的系统中安装的是gcc-4.7，前面提到过，由于我的误操作，删除了我本身系统的8.0的gcc，所以我现在要先下载安装<br><code>sudo apt-get install gcc-8 g++-8</code><br>安装成功！<br>更新一下链接\r\n<pre><code class=\"lang-shell\">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 53 \\\r\n--slave /usr/bin/g++ g++ /usr/bin/g++-8 \\\r\n--slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-8 \\\r\n--slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-8 \\\r\n--slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-8\r\n</code></pre>\r\n<p>OK！完成！<br>输入gcc —version<br>我就看到自己的gcc版本已经是8版本了！\r\n', null, null, null, '2020-12-01 22:04:39', '2020-12-01 22:04:39', '1');
INSERT INTO `articles` VALUES ('85', '1', 'Springboot+Shiro+Mybatis+mysql实现权限安全认证', 'https://blog.csdn.net/BLU_111/article/details/107511886', '> Shiro是Apache 的一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。Shiro 主要分为两个部分就是认证和授权两部分\r\n\r\n### 一、介绍\r\n\r\n1.Subject代表了当前用户的安全操作\r\n\r\n\r\n2.SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。\r\n\r\n\r\n3.Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。\r\n\r\n\r\n4.Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。\r\n\r\n\r\n5.Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。\r\n\r\n\r\n6.sessionManager即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上。\r\n\r\nShiro相关类介绍\r\n（1）Authentication 认证 ---- 用户登录\r\n（2）Authorization 授权 --- 用户具有哪些权限\r\n（3）Cryptography 安全数据加密\r\n（4）Session Management 会话管理\r\n（5）Web Integration web系统集成\r\n（6）Interations 集成其它应用，spring、缓存框架\r\n\r\n### 二、依赖引入\r\n完整的pom文件如下：\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.4.1</version>\r\n        <relativePath></relativePath> <!-- lookup parent from repository -->\r\n    </parent>\r\n    <groupId>com.sunyue.shiro</groupId>\r\n    <artifactId>com.sunyue.shiro</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <packaging>jar</packaging>\r\n    <properties>\r\n        <java.version>1.8</java.version>\r\n        <druid.verzion>1.1.10</druid.verzion>\r\n        <pagehelper.version>1.2.10</pagehelper.version>\r\n        <mybatis.version>2.1.4</mybatis.version>\r\n        <thymeleaf-layout-dialect.version>2.0.4</thymeleaf-layout-dialect.version>\r\n    </properties>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n            <!-- 排除默认的tomcat -->\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.springframework.boot</groupId>\r\n                    <artifactId>spring-boot-starter-tomcat</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n\r\n        <!-- 重新依赖Jetty的starter -->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-jetty</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.mybatis.spring.boot</groupId>\r\n            <artifactId>mybatis-spring-boot-starter</artifactId>\r\n            <version>${mybatis.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>com.github.theborakompanioni</groupId>\r\n            <artifactId>thymeleaf-extras-shiro</artifactId>\r\n            <version>2.0.0</version>\r\n        </dependency>\r\n\r\n        <!--shiro整合spring-->\r\n        <dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-spring</artifactId>\r\n            <version>1.4.0</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>druid-spring-boot-starter</artifactId>\r\n            <version>${druid.verzion}</version>\r\n        </dependency>\r\n\r\n        <!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter -->\r\n        <dependency>\r\n            <groupId>com.github.pagehelper</groupId>\r\n            <artifactId>pagehelper-spring-boot-starter</artifactId>\r\n            <version>${pagehelper.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <scope>runtime</scope>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <build>\r\n        <plugins>\r\n            <!-- spring boot maven插件 -->\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n                <configuration>\r\n                    <mainClass>com.sunyue.shiro.SpringShiroApplication</mainClass>\r\n                </configuration>\r\n            </plugin>\r\n\r\n        </plugins>\r\n    </build>\r\n</project>\r\n```\r\n\r\n### 三、配置文件\r\n```xml\r\napplication.yml配置文件：\r\n# 开发时关闭缓存,不然没法看到实时页面\r\nspring.thymeleaf.cache=false\r\n# 用非严格的 HTML\r\nspring.thymeleaf.mode=HTML\r\nspring.thymeleaf.encoding=utf-8\r\nspring.thymeleaf.servlet.content-type=text/html\r\nspring.datasource.druid.url=jdbc:mysql://localhost:3306/shiro?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC\r\nspring.datasource.druid.username=root\r\nspring.datasource.druid.password=sunyue\r\nspring.datasource.druid.initial-size=1\r\nspring.datasource.druid.min-idle=1\r\nspring.datasource.druid.max-active=20\r\nspring.datasource.druid.test-on-borrow=true\r\n#springbootjdbc导入包不和以前一样\r\nspring.datasource.druid.driver-class-name= com.mysql.cj.jdbc.Driver\r\nmybatis.type-aliases-package=com.sunyue.shiro.entity\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n#打印数据库的操作\r\nlogging.level.com.example.springsecurity.dao=debug\r\n#redis缓存\r\n### 配置Redis\r\nmybatis.configuration.cache-enabled=true\r\n# Redis数据库索引（默认为0）\r\nspring.redis.database=0\r\n# Redis服务器地址\r\nspring.redis.host=152.136.30.116\r\n# Redis服务器连接端口\r\nspring.redis.port=6379\r\n# Redis服务器连接密码（默认为空）\r\nspring.redis.password=sunyue\r\n# 连接池最大连接数（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-idle=200\r\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-wait=-1\r\n# 连接池中的最小空闲连接\r\nspring.redis.jedis.pool.min-idle=0\r\n# 连接超时时间（毫秒）\r\nspring.redis.timeout=1000\r\n```\r\n\r\nShiro两个重要的配置类：\r\n1.UserRealm\r\n```java\r\npackage com.sunyue.shiro.config;\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport com.sunyue.shiro.server.TestUserServer;\r\nimport org.apache.shiro.SecurityUtils;\r\nimport org.apache.shiro.authc.*;\r\nimport org.apache.shiro.authz.AuthorizationInfo;\r\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\r\nimport org.apache.shiro.realm.AuthorizingRealm;\r\nimport org.apache.shiro.subject.PrincipalCollection;\r\nimport org.apache.shiro.subject.Subject;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class UserRealm extends AuthorizingRealm {\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    /**\r\n     * 执行授权逻辑\r\n     *\r\n     * @param principalCollection\r\n     * @return\r\n     */\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        System.out.println(\"执行授权逻辑\");\r\n        /*获取当前登录的用户信息*/\r\n        Subject subject = SecurityUtils.getSubject();\r\n        TestUser testUser = (TestUser) subject.getPrincipal();\r\n        //设置角色,多个角色\r\n        /*Set<String> rolesSet = new HashSet<>();\r\n        rolesSet.add(testUser.getRole());*/\r\n        //SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(rolesSet);\r\n        //给资源进行授权\r\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\r\n        /*可以在以下list加入多个权限*/\r\n        /*List<String> roles = new ArrayList<>();\r\n        roles.add(testUser.getPerms());\r\n        info.addRoles(roles);*/\r\n        //设置权限\r\n        info.addRole(testUser.getRole());\r\n        //需要判断权限是否为空值（null是没有地址，\"\"是有地址但是里面的内容是空的）\r\n        if (testUser.getPerms() != null && !testUser.getPerms().equals(\"\")) {\r\n            info.addStringPermission(testUser.getPerms());\r\n        }\r\n        return info;\r\n    }\r\n\r\n    /**\r\n     * 执行认证逻辑\r\n     *\r\n     * @param authenticationToken\r\n     * @return\r\n     * @throws AuthenticationException\r\n     */\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\r\n        System.out.println(\"执行认证逻辑\");\r\n        /*获取令牌*/\r\n        UsernamePasswordToken passwordToken = (UsernamePasswordToken) authenticationToken;\r\n        //取出用户名并且判断用户名是否和数据库一致\r\n        TestUser testUser = testUserServer.selectOneByName(passwordToken.getUsername());\r\n        if (testUser != null) {\r\n            //进行认证，将正确数据给shiro处理\r\n            //密码不用自己比对，AuthenticationInfo认证信息对象，一个接口，new他的实现类对象SimpleAuthenticationInfo\r\n            /*	第一个参数随便放，可以放user对象，程序可在任意位置获取 放入的对象\r\n             * 第二个参数必须放密码，\r\n             * 第三个参数放 当前realm的名字，因为可能有多个realm*/\r\n            //若密码不正确则返回IncorrectCredentialsException异常\r\n            return new SimpleAuthenticationInfo(testUser, testUser.getPassword(), this.getName());\r\n        }\r\n        //若用户名不存在则返回UnknownAccountException异常\r\n        return null;\r\n    }\r\n}\r\n```\r\n2.ShiroConfig\r\n```java\r\npackage com.sunyue.shiro.config;\r\n\r\nimport at.pollux.thymeleaf.shiro.dialect.ShiroDialect;\r\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\r\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\r\n\r\nimport org.apache.shiro.mgt.SecurityManager;\r\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\r\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;\r\n\r\nimport java.util.LinkedHashMap;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n@Configuration\r\npublic class ShiroConfig {\r\n    @Bean\r\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager) {\r\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\r\n        //设置安全管理器\r\n        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);\r\n        //添加一些Shiro的内置过滤器\r\n        /**\r\n         * Shiro 的内置过滤器可以实现权限的相关拦截\r\n         * 常用过滤器\r\n         * 1.anon:无需认证\r\n         * 2.authc:必须认证才能访问\r\n         * 3.user：如果使用rememberme功能可以访问\r\n         * 4.perms：对应权限才能访问\r\n         * 5.role：对应角色才能访问\r\n         */\r\n        //登录状态下才可以访问main页面，manage权限可访问manage页面，admin角色可访问admin页面\r\n        Map<String, String> filterMap = new LinkedHashMap<String, String>();\r\n        filterMap.put(\"/main\", \"authc\");\r\n        filterMap.put(\"/manage\", \"perms[manage]\");\r\n        filterMap.put(\"/admin\", \"roles[admin]\");\r\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);\r\n        //未登录状态下访问将跳转至login页面\r\n        // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面\r\n        shiroFilterFactoryBean.setLoginUrl(\"/login\");\r\n        // 登录成功后要跳转的链接\r\n        shiroFilterFactoryBean.setSuccessUrl(\"/\");\r\n        //无授限状态下访问将请求unauthor\r\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/unAuth\");\r\n        return shiroFilterFactoryBean;\r\n    }\r\n\r\n    @Bean(name = \"securityManager\")\r\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) {\r\n        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\r\n        //DefaultWebSecurityManager需要关联一个Realm\r\n        defaultWebSecurityManager.setRealm(userRealm);\r\n        return defaultWebSecurityManager;\r\n    }\r\n\r\n    /**\r\n     * 创建realm\r\n     */\r\n    @Bean(name = \"userRealm\")\r\n    public UserRealm getRealm() {\r\n        return new UserRealm();\r\n    }\r\n\r\n    @Bean\r\n    public ShiroDialect shiroDialect() {\r\n        return new ShiroDialect();\r\n    }\r\n\r\n    /**\r\n     * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions)\r\n     * 配置以下两个bean(DefaultAdvisorAutoProxyCreator和AuthorizationAttributeSourceAdvisor)即可实现此功能\r\n     *\r\n     * @return\r\n     */\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        advisorAutoProxyCreator.setProxyTargetClass(true);\r\n        return advisorAutoProxyCreator;\r\n    }\r\n\r\n    /**\r\n     * 开启 shiro 的@RequiresPermissions注解\r\n     *\r\n     * @param securityManager\r\n     * @return\r\n     */\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();\r\n        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);\r\n        return authorizationAttributeSourceAdvisor;\r\n    }\r\n\r\n    /**\r\n     * shiro出现权限异常可通过此异常实现制定页面的跳转(或接口跳转)\r\n     *\r\n     * @return\r\n     */\r\n    @Bean\r\n    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() {\r\n        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();\r\n        Properties properties = new Properties();\r\n        /*未授权处理页*/\r\n        properties.setProperty(\"org.apache.shiro.authz.UnauthorizedException\", \"/error.html\");\r\n        /*身份没有验证*/\r\n        properties.setProperty(\"org.apache.shiro.authz.UnauthenticatedException\", \"/error.html\");\r\n        resolver.setExceptionMappings(properties);\r\n        return resolver;\r\n    }\r\n}\r\n```\r\n### 四、数据连接和业务逻辑\r\n\r\n1.实体类\r\n```java\r\npackage com.sunyue.shiro.entity;\r\n\r\nimport lombok.Data;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\n\r\n@Data\r\n@Accessors(chain = true)\r\npublic class TestUser implements Serializable {\r\n    private Integer id;\r\n    private String username;\r\n    private String password;\r\n    /*权限*/\r\n    private String perms;\r\n    /*角色*/\r\n    private String role;\r\n    /*加盐密码*/\r\n    private String salt;\r\n}\r\n```\r\n2.Dao和Mapper\r\n```java\r\npackage com.sunyue.shiro.dao;\r\n\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n@Mapper\r\npublic interface TestUserMapper {\r\n    List<TestUser> findAll();\r\n\r\n    TestUser selectOne(Integer id);\r\n\r\n    TestUser selectOneByName(String username);\r\n\r\n    void insert(TestUser testUser);\r\n\r\n    void update(TestUser testUser);\r\n\r\n    void delete(Integer id);\r\n}\r\n```\r\n\r\n------------\r\n\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.sunyue.shiro.dao.TestUserMapper\">\r\n\r\n    <select id=\"findAll\"  resultType=\"TestUser\">\r\n       select * from test_user\r\n    </select>\r\n    <select id=\"selectOne\" resultType=\"TestUser\">\r\n       select * from test_user where id=#{id}\r\n    </select>\r\n    <select id=\"selectOneByName\" resultType=\"TestUser\">\r\n       select * from test_user where username=#{username}\r\n    </select>\r\n\r\n    <insert id=\"insert\">\r\n        insert into test_user (id,username,password,perms,role,salt) value (#{id},#{username},#{password},#{perms},#{role},#{salt})\r\n    </insert>\r\n    <update id=\"update\">\r\n		update test_user set username = #{username},password=#{password},perms=#{perms},role=#{role},salt=#{salt} where id = #{id}\r\n	</update>\r\n    <delete id=\"delete\">\r\n		delete from test_user where id = #{id}\r\n	</delete>\r\n</mapper>\r\n```\r\n3.业务层及其实现\r\n```java\r\npackage com.sunyue.shiro.server;\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.List;\r\n\r\n@Service\r\npublic interface TestUserServer {\r\n    /*查询所有*/\r\n    List<TestUser> selectAll();\r\n\r\n    /*查询一个用户*/\r\n    TestUser selectByOne(Integer id);\r\n\r\n    /*通过名字查询一个用户*/\r\n    TestUser selectOneByName(String name);\r\n\r\n    /*增加一个用户*/\r\n    void insert(TestUser testUser);\r\n\r\n    /*删除一个用户*/\r\n    void delete(Integer id);\r\n\r\n    /*更新一个用户*/\r\n    void update(TestUser testUser);\r\n}\r\n```\r\n\r\n------------\r\n```java\r\n\r\npackage com.sunyue.shiro.server.serverImpl;\r\n\r\n\r\nimport com.sunyue.shiro.dao.TestUserMapper;\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\r\nimport org.apache.shiro.crypto.hash.SimpleHash;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport com.sunyue.shiro.server.TestUserServer;\r\n\r\nimport java.util.List;\r\n\r\n@Service\r\npublic class TestUserServerImpl implements TestUserServer {\r\n    @Autowired\r\n    private TestUserMapper testUserMapper;\r\n\r\n    @Override\r\n    public List<TestUser> selectAll() {\r\n        return testUserMapper.findAll();\r\n    }\r\n\r\n    @Override\r\n    public TestUser selectByOne(Integer id) {\r\n        return testUserMapper.selectOne(id);\r\n    }\r\n\r\n    @Override\r\n    public TestUser selectOneByName(String name) {\r\n        return testUserMapper.selectOneByName(name);\r\n    }\r\n\r\n    @Override\r\n    public void insert(TestUser testUser) {\r\n        //加密写法\r\n        String salt = new SecureRandomNumberGenerator().nextBytes().toString();\r\n        String password= new SimpleHash(\"md5\",testUser.getPassword(),salt,2).toString();\r\n        testUser.setPassword(password);\r\n        testUser.setSalt(salt);\r\n        testUserMapper.insert(testUser);\r\n    }\r\n\r\n    @Override\r\n    public void delete(Integer id) {\r\n        testUserMapper.delete(id);\r\n    }\r\n\r\n    @Override\r\n    public void update(TestUser testUser) {\r\n        testUserMapper.update(testUser);\r\n    }\r\n}\r\n```\r\n4.控制层\r\n```java\r\npackage com.sunyue.shiro.controller;\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport com.sunyue.shiro.server.TestUserServer;\r\nimport org.apache.shiro.SecurityUtils;\r\nimport org.apache.shiro.authc.IncorrectCredentialsException;\r\nimport org.apache.shiro.authc.UnknownAccountException;\r\nimport org.apache.shiro.authc.UsernamePasswordToken;\r\nimport org.apache.shiro.crypto.hash.SimpleHash;\r\nimport org.apache.shiro.subject.Subject;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.ui.Model;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n@Controller\r\npublic class indexController {\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    @GetMapping(\"/{url}\")\r\n    public String redirect(@PathVariable(\"url\") String url) {\r\n        return url;\r\n    }\r\n\r\n    @RequestMapping(value = {\"/\", \"/index\"}, method = RequestMethod.GET)\r\n    private String index() {\r\n        return \"index\";\r\n    }\r\n\r\n    @PostMapping(\"/login\")\r\n    public String login(String username, String password, Model model) {\r\n        Subject subject = SecurityUtils.getSubject();\r\n        TestUser testUser = testUserServer.selectOneByName(username);\r\n        if (testUser != null) {\r\n            //根据salt值和用户输入的密码计算加密后的密码\r\n            String salt = testUser.getSalt();\r\n            password = new SimpleHash(\"md5\", password, salt, 2).toString();\r\n            System.out.println(password);\r\n        }\r\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n        //UsernamePasswordToken token = new UsernamePasswordToken(username, testUser.getPassword());(不加密写法)\r\n        try {\r\n            //将用户名和密码通过token传给shiro进行认证\r\n            subject.login(token);\r\n            TestUser user = (TestUser) subject.getPrincipal();\r\n            subject.getSession().setAttribute(\"testUser\", user);\r\n            return \"index\";\r\n        } catch (UnknownAccountException e) {\r\n            e.printStackTrace();\r\n            model.addAttribute(\"msg\", \"用户名不存在\");\r\n            return \"login\";\r\n        } catch (IncorrectCredentialsException e) {\r\n            e.printStackTrace();\r\n            model.addAttribute(\"msg\", \"密码有误\");\r\n            return \"login\";\r\n        }\r\n\r\n    }\r\n\r\n    @ResponseBody\r\n    @GetMapping(\"/unauthor\")\r\n    public String unauthor() {\r\n        return \"权限不足，无法访问\";\r\n    }\r\n\r\n    @GetMapping(\"/logout\")\r\n    public String logout() {\r\n        Subject subject = SecurityUtils.getSubject();\r\n        subject.logout();\r\n        return \"login\";\r\n    }\r\n\r\n    @PostMapping(\"/register\")\r\n    public String register(TestUser testUser, Model model) {\r\n        String username = testUser.getUsername();\r\n        String password = testUser.getPassword();\r\n        if (username == null || username.equals(\"\")) {\r\n            model.addAttribute(\"msg\", \"用户名不能为空\");\r\n            return \"register\";\r\n        } else if (password == null || password.equals(\"\")) {\r\n            model.addAttribute(\"msg\", \"密码不能为空\");\r\n            return \"register\";\r\n        } else if (testUserServer.selectOneByName(username) != null) {\r\n            model.addAttribute(\"msg\", \"用户名已被占用\");\r\n            return \"register\";\r\n        } else {\r\n            testUserServer.insert(testUser);\r\n            return \"login\";\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n5.前端页面\r\n（1）index.html\r\n```html\r\n<!DOCTYPE html>\r\n<html xmlns:th=\"http://www.thymeleaf.org\" xmlns:shiro=\"http://www.thymrleaf.org/thymeleaf-extras-shiro\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Insert title here</title>\r\n    <link rel=\"shortcut icon\" href=\"#\"/>\r\n</head>\r\n<body>\r\n<div th:if=\"${session.testUser != null}\">\r\n		<span th:text=\"\'欢迎回来 \'+${session.testUser.username}+\'!  \'\">\r\n		</span><a href=\"/logout\">退出</a>\r\n</div>\r\n\r\n<a href=\"/main\">main</a>\r\n<span shiro:hasPermission=\"manage\"> | <a href=\"/manage\">manage</a></span>\r\n<span shiro:hasRole=\"admin\"> | <a href=\"/admin\">admin</a></span>\r\n<br>\r\n\r\n</body>\r\n</html>\r\n```\r\n（2）login.html\r\n```html\r\n<!DOCTYPE html>\r\n<html xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Insert title here</title>\r\n    <link rel=\"shortcut icon\" href=\"#\"/>\r\n</head>\r\n<body>\r\n<form action=\"/login\" method=\"post\">\r\n    <span th:text=\"${msg}\" style=\"color: red\"></span>\r\n    <table>\r\n        <tr>\r\n            <td>用户名：</td>\r\n            <td><input type=\"text\" name=\"username\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>密码：</td>\r\n            <td><input type=\"password\" name=\"password\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"submit\" value=\"登录\"/></td>\r\n            <td><a href=\"/register\">\r\n                <button type=\"button\" value=\"注册\">注册</button>\r\n            </a>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n（3）register.html\r\n```html\r\n<!DOCTYPE html>\r\n<html xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Insert title here</title>\r\n    <link rel=\"shortcut icon\" href=\"#\"/>\r\n</head>\r\n<body>\r\n<form action=\"/register\" method=\"post\">\r\n    <span th:text=\"${msg}\" style=\"color: red\"></span>\r\n    <table>\r\n        <tr>\r\n            <td>用户名：</td>\r\n            <td><input type=\"text\" name=\"username\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>密码：</td>\r\n            <td><input type=\"password\" name=\"password\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"submit\" value=\"注册\"/></td>\r\n        </tr>\r\n    </table>\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n（4）main.html\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Insert title here</title>\r\n    <link rel=\"shortcut icon\" href=\"#\"/>\r\n</head>\r\n<body>\r\n<h1>main</h1>\r\n</body>\r\n</html>\r\n```\r\n（5）manage.html\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Insert title here</title>\r\n    <link rel=\"shortcut icon\" href=\"#\"/>\r\n</head>\r\n<body>\r\n<h1>manage</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n（6）admin.html\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Insert title here</title>\r\n    <link rel=\"shortcut icon\" href=\"#\"/>\r\n</head>\r\n<body>\r\n<h1>admin</h1>\r\n</body>\r\n</html>\r\n```\r\n6.数据库文件\r\n```sql\r\n/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : sunyue\r\nSource Server Version : 50724\r\nSource Host           : localhost:3306\r\nSource Database       : shiro\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50724\r\nFile Encoding         : 65001\r\n\r\nDate: 2021-01-11 22:00:47\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for test_user\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `test_user`;\r\nCREATE TABLE `test_user` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(120) DEFAULT NULL,\r\n  `password` varchar(120) DEFAULT NULL,\r\n  `perms` varchar(120) DEFAULT NULL,\r\n  `role` varchar(120) DEFAULT NULL,\r\n  `salt` varchar(100) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Records of test_user\r\n-- ----------------------------\r\nINSERT INTO `test_user` VALUES (\'4\', \'admin\', \'4867df2e009d0096c4cd8d9be8cc104c\', \'manage\', \'admin\', \'GQR2m1N1o3nSLjtOzMITRQ==\');\r\nINSERT INTO `test_user` VALUES (\'5\', \'user\', \'636502f40cf197dd2f4b19f56f475b24\', \'\', \'\', \'Kxw3HZiFmgnlUu8fmjMY7Q==\');\r\nINSERT INTO `test_user` VALUES (\'6\', \'user1\', \'43f3133aa7e0ef9cf8373521dff8d8e8\', \'manage\', null, \'J8fn4HpauvNOrlUaRl/Spg==\');\r\nINSERT INTO `test_user` VALUES (\'7\', \'1\', \'1\', \'manage\', null, null);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<blockquote>\r\n<p>Shiro是Apache 的一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。Shiro 主要分为两个部分就是认证和授权两部分</p>\r\n</blockquote>\r\n<h3 id=\"h3--\"><a name=\"一、介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、介绍</h3><p>1.Subject代表了当前用户的安全操作</p>\r\n<p>2.SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。</p>\r\n<p>3.Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。</p>\r\n<p>4.Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。</p>\r\n<p>5.Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</p>\r\n<p>6.sessionManager即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上。</p>\r\n<p>Shiro相关类介绍<br>（1）Authentication 认证 —— 用户登录<br>（2）Authorization 授权 —- 用户具有哪些权限<br>（3）Cryptography 安全数据加密<br>（4）Session Management 会话管理<br>（5）Web Integration web系统集成<br>（6）Interations 集成其它应用，spring、缓存框架\r\n<h3 id=\"h3--\"><a name=\"二、依赖引入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、依赖引入</h3><p>完整的pom文件如下：</p>\r\n<pre><code class=\"lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\r\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\r\n    &lt;parent&gt;\r\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\r\n        &lt;version&gt;2.4.1&lt;/version&gt;\r\n        &lt;relativePath&gt;&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt;\r\n    &lt;/parent&gt;\r\n    &lt;groupId&gt;com.sunyue.shiro&lt;/groupId&gt;\r\n    &lt;artifactId&gt;com.sunyue.shiro&lt;/artifactId&gt;\r\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\r\n    &lt;packaging&gt;jar&lt;/packaging&gt;\r\n    &lt;properties&gt;\r\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\r\n        &lt;druid.verzion&gt;1.1.10&lt;/druid.verzion&gt;\r\n        &lt;pagehelper.version&gt;1.2.10&lt;/pagehelper.version&gt;\r\n        &lt;mybatis.version&gt;2.1.4&lt;/mybatis.version&gt;\r\n        &lt;thymeleaf-layout-dialect.version&gt;2.0.4&lt;/thymeleaf-layout-dialect.version&gt;\r\n    &lt;/properties&gt;\r\n    &lt;dependencies&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\r\n            &lt;!-- 排除默认的tomcat --&gt;\r\n            &lt;exclusions&gt;\r\n                &lt;exclusion&gt;\r\n                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\r\n                &lt;/exclusion&gt;\r\n            &lt;/exclusions&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;!-- 重新依赖Jetty的starter --&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;${mybatis.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;\r\n            &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;\r\n            &lt;version&gt;2.0.0&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;!--shiro整合spring--&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\r\n            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\r\n            &lt;version&gt;1.4.0&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\r\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;${druid.verzion}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\r\n            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;${pagehelper.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\r\n            &lt;scope&gt;runtime&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\r\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\r\n            &lt;optional&gt;true&lt;/optional&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\r\n            &lt;scope&gt;test&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n    &lt;/dependencies&gt;\r\n\r\n    &lt;build&gt;\r\n        &lt;plugins&gt;\r\n            &lt;!-- spring boot maven插件 --&gt;\r\n            &lt;plugin&gt;\r\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\r\n                &lt;configuration&gt;\r\n                    &lt;mainClass&gt;com.sunyue.shiro.SpringShiroApplication&lt;/mainClass&gt;\r\n                &lt;/configuration&gt;\r\n            &lt;/plugin&gt;\r\n\r\n        &lt;/plugins&gt;\r\n    &lt;/build&gt;\r\n&lt;/project&gt;\r\n</code></pre>\r\n<h3 id=\"h3--\"><a name=\"三、配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、配置文件</h3><pre><code class=\"lang-xml\">application.yml配置文件：\r\n# 开发时关闭缓存,不然没法看到实时页面\r\nspring.thymeleaf.cache=false\r\n# 用非严格的 HTML\r\nspring.thymeleaf.mode=HTML\r\nspring.thymeleaf.encoding=utf-8\r\nspring.thymeleaf.servlet.content-type=text/html\r\nspring.datasource.druid.url=jdbc:mysql://localhost:3306/shiro?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC\r\nspring.datasource.druid.username=root\r\nspring.datasource.druid.password=sunyue\r\nspring.datasource.druid.initial-size=1\r\nspring.datasource.druid.min-idle=1\r\nspring.datasource.druid.max-active=20\r\nspring.datasource.druid.test-on-borrow=true\r\n#springbootjdbc导入包不和以前一样\r\nspring.datasource.druid.driver-class-name= com.mysql.cj.jdbc.Driver\r\nmybatis.type-aliases-package=com.sunyue.shiro.entity\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n#打印数据库的操作\r\nlogging.level.com.example.springsecurity.dao=debug\r\n#redis缓存\r\n### 配置Redis\r\nmybatis.configuration.cache-enabled=true\r\n# Redis数据库索引（默认为0）\r\nspring.redis.database=0\r\n# Redis服务器地址\r\nspring.redis.host=152.136.30.116\r\n# Redis服务器连接端口\r\nspring.redis.port=6379\r\n# Redis服务器连接密码（默认为空）\r\nspring.redis.password=sunyue\r\n# 连接池最大连接数（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-idle=200\r\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-wait=-1\r\n# 连接池中的最小空闲连接\r\nspring.redis.jedis.pool.min-idle=0\r\n# 连接超时时间（毫秒）\r\nspring.redis.timeout=1000\r\n</code></pre>\r\n<p>Shiro两个重要的配置类：<br>1.UserRealm\r\n<pre><code class=\"lang-java\">package com.sunyue.shiro.config;\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport com.sunyue.shiro.server.TestUserServer;\r\nimport org.apache.shiro.SecurityUtils;\r\nimport org.apache.shiro.authc.*;\r\nimport org.apache.shiro.authz.AuthorizationInfo;\r\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\r\nimport org.apache.shiro.realm.AuthorizingRealm;\r\nimport org.apache.shiro.subject.PrincipalCollection;\r\nimport org.apache.shiro.subject.Subject;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class UserRealm extends AuthorizingRealm {\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    /**\r\n     * 执行授权逻辑\r\n     *\r\n     * @param principalCollection\r\n     * @return\r\n     */\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        System.out.println(\"执行授权逻辑\");\r\n        /*获取当前登录的用户信息*/\r\n        Subject subject = SecurityUtils.getSubject();\r\n        TestUser testUser = (TestUser) subject.getPrincipal();\r\n        //设置角色,多个角色\r\n        /*Set&lt;String&gt; rolesSet = new HashSet&lt;&gt;();\r\n        rolesSet.add(testUser.getRole());*/\r\n        //SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(rolesSet);\r\n        //给资源进行授权\r\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\r\n        /*可以在以下list加入多个权限*/\r\n        /*List&lt;String&gt; roles = new ArrayList&lt;&gt;();\r\n        roles.add(testUser.getPerms());\r\n        info.addRoles(roles);*/\r\n        //设置权限\r\n        info.addRole(testUser.getRole());\r\n        //需要判断权限是否为空值（null是没有地址，\"\"是有地址但是里面的内容是空的）\r\n        if (testUser.getPerms() != null &amp;&amp; !testUser.getPerms().equals(\"\")) {\r\n            info.addStringPermission(testUser.getPerms());\r\n        }\r\n        return info;\r\n    }\r\n\r\n    /**\r\n     * 执行认证逻辑\r\n     *\r\n     * @param authenticationToken\r\n     * @return\r\n     * @throws AuthenticationException\r\n     */\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\r\n        System.out.println(\"执行认证逻辑\");\r\n        /*获取令牌*/\r\n        UsernamePasswordToken passwordToken = (UsernamePasswordToken) authenticationToken;\r\n        //取出用户名并且判断用户名是否和数据库一致\r\n        TestUser testUser = testUserServer.selectOneByName(passwordToken.getUsername());\r\n        if (testUser != null) {\r\n            //进行认证，将正确数据给shiro处理\r\n            //密码不用自己比对，AuthenticationInfo认证信息对象，一个接口，new他的实现类对象SimpleAuthenticationInfo\r\n            /*    第一个参数随便放，可以放user对象，程序可在任意位置获取 放入的对象\r\n             * 第二个参数必须放密码，\r\n             * 第三个参数放 当前realm的名字，因为可能有多个realm*/\r\n            //若密码不正确则返回IncorrectCredentialsException异常\r\n            return new SimpleAuthenticationInfo(testUser, testUser.getPassword(), this.getName());\r\n        }\r\n        //若用户名不存在则返回UnknownAccountException异常\r\n        return null;\r\n    }\r\n}\r\n</code></pre>\r\n<p>2.ShiroConfig</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.shiro.config;\r\n\r\nimport at.pollux.thymeleaf.shiro.dialect.ShiroDialect;\r\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\r\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\r\n\r\nimport org.apache.shiro.mgt.SecurityManager;\r\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\r\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;\r\n\r\nimport java.util.LinkedHashMap;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n@Configuration\r\npublic class ShiroConfig {\r\n    @Bean\r\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager) {\r\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\r\n        //设置安全管理器\r\n        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);\r\n        //添加一些Shiro的内置过滤器\r\n        /**\r\n         * Shiro 的内置过滤器可以实现权限的相关拦截\r\n         * 常用过滤器\r\n         * 1.anon:无需认证\r\n         * 2.authc:必须认证才能访问\r\n         * 3.user：如果使用rememberme功能可以访问\r\n         * 4.perms：对应权限才能访问\r\n         * 5.role：对应角色才能访问\r\n         */\r\n        //登录状态下才可以访问main页面，manage权限可访问manage页面，admin角色可访问admin页面\r\n        Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;String, String&gt;();\r\n        filterMap.put(\"/main\", \"authc\");\r\n        filterMap.put(\"/manage\", \"perms[manage]\");\r\n        filterMap.put(\"/admin\", \"roles[admin]\");\r\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);\r\n        //未登录状态下访问将跳转至login页面\r\n        // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面\r\n        shiroFilterFactoryBean.setLoginUrl(\"/login\");\r\n        // 登录成功后要跳转的链接\r\n        shiroFilterFactoryBean.setSuccessUrl(\"/\");\r\n        //无授限状态下访问将请求unauthor\r\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/unAuth\");\r\n        return shiroFilterFactoryBean;\r\n    }\r\n\r\n    @Bean(name = \"securityManager\")\r\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) {\r\n        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\r\n        //DefaultWebSecurityManager需要关联一个Realm\r\n        defaultWebSecurityManager.setRealm(userRealm);\r\n        return defaultWebSecurityManager;\r\n    }\r\n\r\n    /**\r\n     * 创建realm\r\n     */\r\n    @Bean(name = \"userRealm\")\r\n    public UserRealm getRealm() {\r\n        return new UserRealm();\r\n    }\r\n\r\n    @Bean\r\n    public ShiroDialect shiroDialect() {\r\n        return new ShiroDialect();\r\n    }\r\n\r\n    /**\r\n     * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions)\r\n     * 配置以下两个bean(DefaultAdvisorAutoProxyCreator和AuthorizationAttributeSourceAdvisor)即可实现此功能\r\n     *\r\n     * @return\r\n     */\r\n    @Bean\r\n    public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\r\n        advisorAutoProxyCreator.setProxyTargetClass(true);\r\n        return advisorAutoProxyCreator;\r\n    }\r\n\r\n    /**\r\n     * 开启 shiro 的@RequiresPermissions注解\r\n     *\r\n     * @param securityManager\r\n     * @return\r\n     */\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\r\n        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();\r\n        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);\r\n        return authorizationAttributeSourceAdvisor;\r\n    }\r\n\r\n    /**\r\n     * shiro出现权限异常可通过此异常实现制定页面的跳转(或接口跳转)\r\n     *\r\n     * @return\r\n     */\r\n    @Bean\r\n    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() {\r\n        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();\r\n        Properties properties = new Properties();\r\n        /*未授权处理页*/\r\n        properties.setProperty(\"org.apache.shiro.authz.UnauthorizedException\", \"/error.html\");\r\n        /*身份没有验证*/\r\n        properties.setProperty(\"org.apache.shiro.authz.UnauthenticatedException\", \"/error.html\");\r\n        resolver.setExceptionMappings(properties);\r\n        return resolver;\r\n    }\r\n}\r\n</code></pre>\r\n<h3 id=\"h3--\"><a name=\"四、数据连接和业务逻辑\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、数据连接和业务逻辑</h3><p>1.实体类</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.shiro.entity;\r\n\r\nimport lombok.Data;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\n\r\n@Data\r\n@Accessors(chain = true)\r\npublic class TestUser implements Serializable {\r\n    private Integer id;\r\n    private String username;\r\n    private String password;\r\n    /*权限*/\r\n    private String perms;\r\n    /*角色*/\r\n    private String role;\r\n    /*加盐密码*/\r\n    private String salt;\r\n}\r\n</code></pre>\r\n<p>2.Dao和Mapper</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.shiro.dao;\r\n\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n@Mapper\r\npublic interface TestUserMapper {\r\n    List&lt;TestUser&gt; findAll();\r\n\r\n    TestUser selectOne(Integer id);\r\n\r\n    TestUser selectOneByName(String username);\r\n\r\n    void insert(TestUser testUser);\r\n\r\n    void update(TestUser testUser);\r\n\r\n    void delete(Integer id);\r\n}\r\n</code></pre>\r\n<hr>\r\n<pre><code class=\"lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\r\n&lt;mapper namespace=\"com.sunyue.shiro.dao.TestUserMapper\"&gt;\r\n\r\n    &lt;select id=\"findAll\"  resultType=\"TestUser\"&gt;\r\n       select * from test_user\r\n    &lt;/select&gt;\r\n    &lt;select id=\"selectOne\" resultType=\"TestUser\"&gt;\r\n       select * from test_user where id=#{id}\r\n    &lt;/select&gt;\r\n    &lt;select id=\"selectOneByName\" resultType=\"TestUser\"&gt;\r\n       select * from test_user where username=#{username}\r\n    &lt;/select&gt;\r\n\r\n    &lt;insert id=\"insert\"&gt;\r\n        insert into test_user (id,username,password,perms,role,salt) value (#{id},#{username},#{password},#{perms},#{role},#{salt})\r\n    &lt;/insert&gt;\r\n    &lt;update id=\"update\"&gt;\r\n        update test_user set username = #{username},password=#{password},perms=#{perms},role=#{role},salt=#{salt} where id = #{id}\r\n    &lt;/update&gt;\r\n    &lt;delete id=\"delete\"&gt;\r\n        delete from test_user where id = #{id}\r\n    &lt;/delete&gt;\r\n&lt;/mapper&gt;\r\n</code></pre>\r\n<p>3.业务层及其实现</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.shiro.server;\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.List;\r\n\r\n@Service\r\npublic interface TestUserServer {\r\n    /*查询所有*/\r\n    List&lt;TestUser&gt; selectAll();\r\n\r\n    /*查询一个用户*/\r\n    TestUser selectByOne(Integer id);\r\n\r\n    /*通过名字查询一个用户*/\r\n    TestUser selectOneByName(String name);\r\n\r\n    /*增加一个用户*/\r\n    void insert(TestUser testUser);\r\n\r\n    /*删除一个用户*/\r\n    void delete(Integer id);\r\n\r\n    /*更新一个用户*/\r\n    void update(TestUser testUser);\r\n}\r\n</code></pre>\r\n<hr>\r\n<pre><code class=\"lang-java\">\r\npackage com.sunyue.shiro.server.serverImpl;\r\n\r\n\r\nimport com.sunyue.shiro.dao.TestUserMapper;\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\r\nimport org.apache.shiro.crypto.hash.SimpleHash;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport com.sunyue.shiro.server.TestUserServer;\r\n\r\nimport java.util.List;\r\n\r\n@Service\r\npublic class TestUserServerImpl implements TestUserServer {\r\n    @Autowired\r\n    private TestUserMapper testUserMapper;\r\n\r\n    @Override\r\n    public List&lt;TestUser&gt; selectAll() {\r\n        return testUserMapper.findAll();\r\n    }\r\n\r\n    @Override\r\n    public TestUser selectByOne(Integer id) {\r\n        return testUserMapper.selectOne(id);\r\n    }\r\n\r\n    @Override\r\n    public TestUser selectOneByName(String name) {\r\n        return testUserMapper.selectOneByName(name);\r\n    }\r\n\r\n    @Override\r\n    public void insert(TestUser testUser) {\r\n        //加密写法\r\n        String salt = new SecureRandomNumberGenerator().nextBytes().toString();\r\n        String password= new SimpleHash(\"md5\",testUser.getPassword(),salt,2).toString();\r\n        testUser.setPassword(password);\r\n        testUser.setSalt(salt);\r\n        testUserMapper.insert(testUser);\r\n    }\r\n\r\n    @Override\r\n    public void delete(Integer id) {\r\n        testUserMapper.delete(id);\r\n    }\r\n\r\n    @Override\r\n    public void update(TestUser testUser) {\r\n        testUserMapper.update(testUser);\r\n    }\r\n}\r\n</code></pre>\r\n<p>4.控制层</p>\r\n<pre><code class=\"lang-java\">package com.sunyue.shiro.controller;\r\n\r\nimport com.sunyue.shiro.entity.TestUser;\r\nimport com.sunyue.shiro.server.TestUserServer;\r\nimport org.apache.shiro.SecurityUtils;\r\nimport org.apache.shiro.authc.IncorrectCredentialsException;\r\nimport org.apache.shiro.authc.UnknownAccountException;\r\nimport org.apache.shiro.authc.UsernamePasswordToken;\r\nimport org.apache.shiro.crypto.hash.SimpleHash;\r\nimport org.apache.shiro.subject.Subject;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.ui.Model;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n@Controller\r\npublic class indexController {\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    @GetMapping(\"/{url}\")\r\n    public String redirect(@PathVariable(\"url\") String url) {\r\n        return url;\r\n    }\r\n\r\n    @RequestMapping(value = {\"/\", \"/index\"}, method = RequestMethod.GET)\r\n    private String index() {\r\n        return \"index\";\r\n    }\r\n\r\n    @PostMapping(\"/login\")\r\n    public String login(String username, String password, Model model) {\r\n        Subject subject = SecurityUtils.getSubject();\r\n        TestUser testUser = testUserServer.selectOneByName(username);\r\n        if (testUser != null) {\r\n            //根据salt值和用户输入的密码计算加密后的密码\r\n            String salt = testUser.getSalt();\r\n            password = new SimpleHash(\"md5\", password, salt, 2).toString();\r\n            System.out.println(password);\r\n        }\r\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n        //UsernamePasswordToken token = new UsernamePasswordToken(username, testUser.getPassword());(不加密写法)\r\n        try {\r\n            //将用户名和密码通过token传给shiro进行认证\r\n            subject.login(token);\r\n            TestUser user = (TestUser) subject.getPrincipal();\r\n            subject.getSession().setAttribute(\"testUser\", user);\r\n            return \"index\";\r\n        } catch (UnknownAccountException e) {\r\n            e.printStackTrace();\r\n            model.addAttribute(\"msg\", \"用户名不存在\");\r\n            return \"login\";\r\n        } catch (IncorrectCredentialsException e) {\r\n            e.printStackTrace();\r\n            model.addAttribute(\"msg\", \"密码有误\");\r\n            return \"login\";\r\n        }\r\n\r\n    }\r\n\r\n    @ResponseBody\r\n    @GetMapping(\"/unauthor\")\r\n    public String unauthor() {\r\n        return \"权限不足，无法访问\";\r\n    }\r\n\r\n    @GetMapping(\"/logout\")\r\n    public String logout() {\r\n        Subject subject = SecurityUtils.getSubject();\r\n        subject.logout();\r\n        return \"login\";\r\n    }\r\n\r\n    @PostMapping(\"/register\")\r\n    public String register(TestUser testUser, Model model) {\r\n        String username = testUser.getUsername();\r\n        String password = testUser.getPassword();\r\n        if (username == null || username.equals(\"\")) {\r\n            model.addAttribute(\"msg\", \"用户名不能为空\");\r\n            return \"register\";\r\n        } else if (password == null || password.equals(\"\")) {\r\n            model.addAttribute(\"msg\", \"密码不能为空\");\r\n            return \"register\";\r\n        } else if (testUserServer.selectOneByName(username) != null) {\r\n            model.addAttribute(\"msg\", \"用户名已被占用\");\r\n            return \"register\";\r\n        } else {\r\n            testUserServer.insert(testUser);\r\n            return \"login\";\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>5.前端页面<br>（1）index.html\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html xmlns:th=\"http://www.thymeleaf.org\" xmlns:shiro=\"http://www.thymrleaf.org/thymeleaf-extras-shiro\"&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;Insert title here&lt;/title&gt;\r\n    &lt;link rel=\"shortcut icon\" href=\"#\"/&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;div th:if=\"${session.testUser != null}\"&gt;\r\n        &lt;span th:text=\"\'欢迎回来 \'+${session.testUser.username}+\'!  \'\"&gt;\r\n        &lt;/span&gt;&lt;a href=\"/logout\"&gt;退出&lt;/a&gt;\r\n&lt;/div&gt;\r\n\r\n&lt;a href=\"/main\"&gt;main&lt;/a&gt;\r\n&lt;span shiro:hasPermission=\"manage\"&gt; | &lt;a href=\"/manage\"&gt;manage&lt;/a&gt;&lt;/span&gt;\r\n&lt;span shiro:hasRole=\"admin\"&gt; | &lt;a href=\"/admin\"&gt;admin&lt;/a&gt;&lt;/span&gt;\r\n&lt;br&gt;\r\n\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>（2）login.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;Insert title here&lt;/title&gt;\r\n    &lt;link rel=\"shortcut icon\" href=\"#\"/&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;form action=\"/login\" method=\"post\"&gt;\r\n    &lt;span th:text=\"${msg}\" style=\"color: red\"&gt;&lt;/span&gt;\r\n    &lt;table&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;用户名：&lt;/td&gt;\r\n            &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;密码：&lt;/td&gt;\r\n            &lt;td&gt;&lt;input type=\"password\" name=\"password\"/&gt;&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;&lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/td&gt;\r\n            &lt;td&gt;&lt;a href=\"/register\"&gt;\r\n                &lt;button type=\"button\" value=\"注册\"&gt;注册&lt;/button&gt;\r\n            &lt;/a&gt;\r\n            &lt;/td&gt;\r\n        &lt;/tr&gt;\r\n    &lt;/table&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>（3）register.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;Insert title here&lt;/title&gt;\r\n    &lt;link rel=\"shortcut icon\" href=\"#\"/&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;form action=\"/register\" method=\"post\"&gt;\r\n    &lt;span th:text=\"${msg}\" style=\"color: red\"&gt;&lt;/span&gt;\r\n    &lt;table&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;用户名：&lt;/td&gt;\r\n            &lt;td&gt;&lt;input type=\"text\" name=\"username\"/&gt;&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;密码：&lt;/td&gt;\r\n            &lt;td&gt;&lt;input type=\"password\" name=\"password\"/&gt;&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;&lt;input type=\"submit\" value=\"注册\"/&gt;&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n    &lt;/table&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>（4）main.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;Insert title here&lt;/title&gt;\r\n    &lt;link rel=\"shortcut icon\" href=\"#\"/&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;h1&gt;main&lt;/h1&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>（5）manage.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;Insert title here&lt;/title&gt;\r\n    &lt;link rel=\"shortcut icon\" href=\"#\"/&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;h1&gt;manage&lt;/h1&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>（6）admin.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;Insert title here&lt;/title&gt;\r\n    &lt;link rel=\"shortcut icon\" href=\"#\"/&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;h1&gt;admin&lt;/h1&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>6.数据库文件</p>\r\n<pre><code class=\"lang-sql\">/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : sunyue\r\nSource Server Version : 50724\r\nSource Host           : localhost:3306\r\nSource Database       : shiro\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50724\r\nFile Encoding         : 65001\r\n\r\nDate: 2021-01-11 22:00:47\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for test_user\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `test_user`;\r\nCREATE TABLE `test_user` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(120) DEFAULT NULL,\r\n  `password` varchar(120) DEFAULT NULL,\r\n  `perms` varchar(120) DEFAULT NULL,\r\n  `role` varchar(120) DEFAULT NULL,\r\n  `salt` varchar(100) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Records of test_user\r\n-- ----------------------------\r\nINSERT INTO `test_user` VALUES (\'4\', \'admin\', \'4867df2e009d0096c4cd8d9be8cc104c\', \'manage\', \'admin\', \'GQR2m1N1o3nSLjtOzMITRQ==\');\r\nINSERT INTO `test_user` VALUES (\'5\', \'user\', \'636502f40cf197dd2f4b19f56f475b24\', \'\', \'\', \'Kxw3HZiFmgnlUu8fmjMY7Q==\');\r\nINSERT INTO `test_user` VALUES (\'6\', \'user1\', \'43f3133aa7e0ef9cf8373521dff8d8e8\', \'manage\', null, \'J8fn4HpauvNOrlUaRl/Spg==\');\r\nINSERT INTO `test_user` VALUES (\'7\', \'1\', \'1\', \'manage\', null, null);\r\n</code></pre>\r\n', null, null, null, '2021-01-11 22:03:04', '2021-01-11 22:04:00', '1');
INSERT INTO `articles` VALUES ('86', '1', 'Springboot+Security+Mybatis+mysql实现权限安全认证', '', '> SpringSecurity是Spring下的一个安全框架，与shiro 类似，一般用于用户认证（Authentication）和用户授权（Authorization）两个部分，常与与SpringBoot相整合。\r\n\r\n### 一、介绍\r\n**SpringSecurity 过滤器链**\r\nSpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:\r\n\r\n1.WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。\r\n\r\n2.SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\r\n\r\n3.HeaderWriterFilter：用于将头信息加入响应中。\r\n\r\n4.CsrfFilter：用于处理跨站请求伪造。\r\n\r\n5.LogoutFilter：用于处理退出登录。\r\n\r\n6.UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\r\n\r\n7.DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\r\n\r\n8.BasicAuthenticationFilter：检测和处理 http basic 认证。\r\n\r\n9.RequestCacheAwareFilter：用来处理请求的缓存。\r\n\r\n10.SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。\r\n\r\n11.AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。\r\n\r\n12.SessionManagementFilter：管理 session 的过滤器\r\n\r\n13.ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。\r\n\r\n14.FilterSecurityInterceptor：可以看做过滤器链的出口。\r\n\r\n15.RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。\r\n\r\n**流程说明**\r\n1.客户端发起一个请求，进入 Security 过滤器链。\r\n\r\n2.当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。\r\n\r\n3.当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。\r\n\r\n4.当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。\r\n\r\n### 二、依赖引入\r\n完整的pom文件如下：\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.4.1</version>\r\n        <relativePath></relativePath> <!-- lookup parent from repository -->\r\n    </parent>\r\n    <groupId>com.example</groupId>\r\n    <artifactId>spring-security</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <name>spring-security</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n    <properties>\r\n        <java.version>1.8</java.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>druid-spring-boot-starter</artifactId>\r\n            <version>1.2.4</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-data-redis</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-jdbc</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-security</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.mybatis.spring.boot</groupId>\r\n            <artifactId>mybatis-spring-boot-starter</artifactId>\r\n            <version>2.1.4</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.thymeleaf.extras</groupId>\r\n            <artifactId>thymeleaf-extras-springsecurity5</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-devtools</artifactId>\r\n            <scope>runtime</scope>\r\n            <optional>true</optional>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <scope>runtime</scope>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.security</groupId>\r\n            <artifactId>spring-security-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n                <configuration>\r\n                    <mainClass>com.example.springsecurity.SpringSecurityApplication</mainClass>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n</project>\r\n```\r\n### 三、配置文件\r\n```xml\r\n# 开发时关闭缓存,不然没法看到实时页面\r\nspring.thymeleaf.cache=false\r\n# 用非严格的 HTML\r\nspring.thymeleaf.mode=HTML\r\nspring.thymeleaf.encoding=utf-8\r\nspring.thymeleaf.servlet.content-type=text/html\r\nspring.datasource.druid.url=jdbc:mysql://localhost:3306/security?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC\r\nspring.datasource.druid.username=root\r\nspring.datasource.druid.password=sunyue\r\nspring.datasource.druid.initial-size=1\r\nspring.datasource.druid.min-idle=1\r\nspring.datasource.druid.max-active=20\r\nspring.datasource.druid.test-on-borrow=true\r\n#springbootjdbc导入包不和以前一样\r\nspring.datasource.druid.driver-class-name= com.mysql.cj.jdbc.Driver\r\nmybatis.type-aliases-package=com.example.springsecurity.entity\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n#打印数据库的操作\r\nlogging.level.com.example.springsecurity.dao=debug\r\n#redis缓存\r\n### 配置Redis\r\nmybatis.configuration.cache-enabled=true\r\n# Redis数据库索引（默认为0）\r\nspring.redis.database=0\r\n# Redis服务器地址\r\nspring.redis.host=152.136.30.116\r\n# Redis服务器连接端口\r\nspring.redis.port=6379\r\n# Redis服务器连接密码（默认为空）\r\nspring.redis.password=sunyue\r\n# 连接池最大连接数（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-idle=200\r\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-wait=-1\r\n# 连接池中的最小空闲连接\r\nspring.redis.jedis.pool.min-idle=0\r\n# 连接超时时间（毫秒）\r\nspring.redis.timeout=1000\r\n```\r\n\r\n### 四、Security 配置类\r\nSecurityConfig：\r\n```java\r\npackage com.example.springsecurity;\r\n\r\nimport com.example.springsecurity.server.serverImpl.TestUserServer;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.WebSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\n\r\n@EnableWebSecurity    //注解开启Spring Security的功能\r\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r\n\r\n    //明文加密器,只需要在内存中有这个管理对象,如果不添加，从前端登录时会抛出异常Bad credentials（数据库操作需要这个bean，内存不需要，只需要将密码加密就可以）\r\n    /*内置的PasswordEncoder实现列表\r\n    NoOpPasswordEncoder（已废除）\r\n    明文密码加密方式，该方式已被废除（不建议在生产环境使用），不过还是支持开发阶段测试Spring Security的时候使用。\r\n    BCryptPasswordEncoder\r\n    Argon2PasswordEncoder\r\n    Pbkdf2PasswordEncoder\r\n    SCryptPasswordEncoder */\r\n    //使用以上四个方法都可以解密，但是数据库中得密码也是对应方法得加密（添加用户数据是需要password加密new BCryptPasswordEncoder().encode(\"123456\")）\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();//passwordEncoder的实现类\r\n    }\r\n\r\n    //构造一个内存框架对象，获取数据库中的数据\r\n/*    @Bean\r\n    public UserDetailsService myUserDetailsService(){\r\n        return new TestUserServerImpl();\r\n    }*/\r\n    //也可以自动注入\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    //用户授权\r\n    @Override\r\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\r\n        //基于内存来存储用户信息(需要加密不然会报错---Encoded password does not look like BCrypt)\r\n        /*auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\r\n                .withUser(\"user\").password(new BCryptPasswordEncoder().encode(\"password\")).authorities(\"user\").and()          //设置\r\n                .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"password\")).authorities(\"admin\", \"user\");*/\r\n        //基于数据库来存储用户信息\r\n        //auth.userDetailsService(myUserDetailsService());\r\n        auth.userDetailsService(testUserServer);\r\n    }\r\n\r\n    //用户权限认证\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        http\r\n                //这是认证的请求\r\n                .authorizeRequests()\r\n                .antMatchers(\"/\", \"/home\", \"/login\", \"/index\", \"/error\").permitAll()  //这些请求 不需要认证\r\n                //hasRole和hasAuthority的区别：我们在调用 hasAuthority 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，\r\n                // 可以不加 ROLE_ 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin。\r\n                //也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！\r\n                // 而 hasRole 则不同，代码里如果写的是 USER，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_USER\r\n                .antMatchers(\"/user/**\").hasRole(\"USER\")       //user及以下路径，需要ROLE_USER角色权限\r\n                .antMatchers(\"/admin/**\").hasAuthority(\"admin\")//admin及以下路径，需要admin权限\r\n                .and()\r\n                //loginPage定制自定义登录页，相当于/toLogin其实自动转到/login，loginProcessingUr指定为login-》toLogin（表单提交只能为login）,加了这个需要接受用户名和密码，登录成功跳转  \"/\"\r\n                //.formLogin().loginPage(\"/toLogin\").usernameParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/login\").defaultSuccessUrl(\"/\")\r\n                .formLogin()//自带的login\r\n                .and()\r\n                .csrf().disable()//关闭csrf\r\n                //等出路径为logout，登出成功跳转 \"/\"\r\n                .logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/\")\r\n                .and()\r\n                .rememberMe().rememberMeParameter(\"rememberMe\");\r\n    }\r\n\r\n    /**\r\n     * 核心过滤器配置，更多使用ignoring()用来忽略对静态资源的控制\r\n     */\r\n    @Override\r\n    public void configure(WebSecurity web) throws Exception {\r\n        web\r\n                .ignoring()\r\n                .antMatchers(\"/image/**\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n   AuthenticationManager 的建造器，配置 AuthenticationManagerBuilder 会让Security 自动构建一个 AuthenticationManager；如果想要使用该功能你需要配置一个 UserDetailService 和 PasswordEncoder。UserDetailsService 用于在认证器中根据用户传过来的用户名查找一个用户， PasswordEncoder 用于密码的加密与比对，我们存储用户密码的时候用PasswordEncoder.encode() 加密存储，在认证器里会调用 PasswordEncoder.matches() 方法进行密码比对。如果重写了该方法，Security 会启用 DaoAuthenticationProvider 这个认证器，该认证就是先调用 UserDetailsService.loadUserByUsername 然后使用 PasswordEncoder.matches() 进行密码比对，如果认证成功成功则返回一个 Authentication 对象。\r\n\r\n### 五、自定义的UserDetailService\r\nTestUserServer：\r\n```java\r\npackage com.example.springsecurity.server.serverImpl;\r\n\r\nimport com.example.springsecurity.dao.TestUserMapper;\r\nimport com.example.springsecurity.entity.TestUser;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.User;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Service\r\npublic class TestUserServer implements UserDetailsService {\r\n    @Autowired\r\n    private TestUserMapper testUserMapper;\r\n\r\n    @Override\r\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\r\n        //username参数,是在登陆时,用户传递的表单数据username\r\n        //主要读取数据库3个值 username password authorities\r\n        TestUser testUser = testUserMapper.selectOne(username);\r\n        String authorityName = testUser.getAuthority();\r\n        //为了返回一个UserDetails 使用User\r\n        List<GrantedAuthority> authorities = new ArrayList<>();\r\n        GrantedAuthority authority = new SimpleGrantedAuthority(authorityName);\r\n        authorities.add(authority);\r\n        //这里的User 是这个包下的 org.springframework.security.core.userdetails.User;\r\n        return new User(\r\n                testUser.getUsername(),\r\n                testUser.getPassword(),\r\n                authorities);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 六、实体类和DAO等\r\n实体类：\r\n```java\r\npackage com.example.springsecurity.entity;\r\n\r\nimport lombok.Data;\r\nimport lombok.experimental.Accessors;\r\n\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\n\r\n@Data\r\n@Accessors(chain = true)\r\npublic class TestUser implements Serializable {\r\n    private Long id;\r\n    private String username;\r\n    private String password;\r\n    private String authority;\r\n    private Date created;\r\n    private Date updated;\r\n}\r\n```\r\n\r\nDAO\r\n```java\r\npackage com.example.springsecurity.dao;\r\n\r\nimport com.example.springsecurity.entity.TestUser;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n@Mapper\r\npublic interface TestUserMapper {\r\n    List<TestUser> findAll();\r\n\r\n    TestUser selectOne(String username);\r\n\r\n    void insert(TestUser testUser);\r\n\r\n    void update(TestUser testUser);\r\n\r\n    void delete(String id);\r\n}\r\n```\r\nMapper\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.springsecurity.dao.TestUserMapper\">\r\n\r\n    <select id=\"findAll\"  resultType=\"TestUser\">\r\n       select * from test_user\r\n    </select>\r\n    <select id=\"selectOne\" resultType=\"TestUser\">\r\n       select * from test_user where username=#{username}\r\n    </select>\r\n\r\n    <insert id=\"insert\">\r\n        insert into test_user (username,password,authority,created,updated) value (#{username},#{password},#{authority},#{created},#{updated})\r\n    </insert>\r\n    <update id=\"update\">\r\n		update test_user set username = #{username},password=#{password},authority=#{authority} where id = #{id}\r\n	</update>\r\n    <delete id=\"delete\">\r\n		delete from test_user where id = #{id}\r\n	</delete>\r\n</mapper>\r\n```\r\n\r\n### 七、前台代码\r\n1.index.html\r\n```html\r\n<!DOCTYPE html>\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\r\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"> \r\n<head>\r\n     <title>Spring Security Example</title>   \r\n</head>\r\n<body>\r\n   <h1>Welcome!</h1>\r\n<!--自带登录页-->\r\n   <p><a th:href=\"@{/login}\">登录</a></p>\r\n<!--自定义登录页-->\r\n   <!--<p><a th:href=\"@{/toLogin}\">登录</a></p>-->\r\n   <p><a th:href=\"@{/user}\">用户</a></p>\r\n   <p><a th:href=\"@{/admin}\">管理员</a></p>\r\n   <p><a th:href=\"@{/logout}\">退出</a></p>\r\n</body>\r\n</html>\r\n```\r\n2.login.html\r\n```html\r\n<!DOCTYPE html>\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\r\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"> \r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>登录</title>\r\n</head>\r\n<body>\r\n<form th:action=\"@{/login}\" method=\"post\">\r\n    <input type=\"text\" name=\"username\" placeholder=\"UserName\"/>\r\n    <input type=\"password\" name=\"password\" placeholder=\"PassWord\"/>\r\n    <input type=\"checkbox\" name=\"rememberMe\"/>\r\n    <input type=\"submit\" value=\"提交\"/>\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n3.user.html\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>user</title>\r\n</head>\r\n<body>\r\nuser\r\n</body>\r\n</html>\r\n```\r\n4.admin.html\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>admin</title>\r\n</head>\r\n<body>\r\nadmin\r\n</body>\r\n</html>\r\n```\r\n\r\n5.数据库sql文\r\n```sql\r\n/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : sunyue\r\nSource Server Version : 50724\r\nSource Host           : localhost:3306\r\nSource Database       : security\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50724\r\nFile Encoding         : 65001\r\n\r\nDate: 2021-01-13 23:33:57\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for test_user\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `test_user`;\r\nCREATE TABLE `test_user` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(100) DEFAULT NULL,\r\n  `password` varchar(100) DEFAULT NULL,\r\n  `authority` varchar(100) DEFAULT NULL,\r\n  `created` date DEFAULT NULL,\r\n  `updated` date DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\r\n\r\n-- ----------------------------\r\n-- Records of test_user\r\n-- ----------------------------\r\nINSERT INTO `test_user` VALUES (\'3\', \'user\', \'$2a$10$Skjo8i3cSopkOtVsvfX5I.eOPCOFm2B/CD4t0VjUDXfTZk6aSAvia\', \'ROLE_USER\', \'2021-01-12\', \'2021-01-12\');\r\nINSERT INTO `test_user` VALUES (\'4\', \'admin\', \'$2a$10$3rzQ1Pn.Onx9N/Dy6a5O8.TZfB/kqo/Z1UOj9udQl4ne0AZDaxn4O\', \'admin\', \'2021-01-12\', \'2021-01-12\');\r\n\r\n```\r\n\r\n总结：当数据库中`authority`字段为ROLE_USER则拥有USER角色权限，可以访问路径/user下，为admin则拥有\r\n/admin下\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '<blockquote>\r\n<p>SpringSecurity是Spring下的一个安全框架，与shiro 类似，一般用于用户认证（Authentication）和用户授权（Authorization）两个部分，常与与SpringBoot相整合。</p>\r\n</blockquote>\r\n<h3 id=\"h3--\"><a name=\"一、介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、介绍</h3><p><strong>SpringSecurity 过滤器链</strong><br>SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明:\r\n<p>1.WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</p>\r\n<p>2.SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p>\r\n<p>3.HeaderWriterFilter：用于将头信息加入响应中。</p>\r\n<p>4.CsrfFilter：用于处理跨站请求伪造。</p>\r\n<p>5.LogoutFilter：用于处理退出登录。</p>\r\n<p>6.UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p>\r\n<p>7.DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p>\r\n<p>8.BasicAuthenticationFilter：检测和处理 http basic 认证。</p>\r\n<p>9.RequestCacheAwareFilter：用来处理请求的缓存。</p>\r\n<p>10.SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p>\r\n<p>11.AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。</p>\r\n<p>12.SessionManagementFilter：管理 session 的过滤器</p>\r\n<p>13.ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。</p>\r\n<p>14.FilterSecurityInterceptor：可以看做过滤器链的出口。</p>\r\n<p>15.RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p>\r\n<p><strong>流程说明</strong><br>1.客户端发起一个请求，进入 Security 过滤器链。\r\n<p>2.当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。</p>\r\n<p>3.当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。</p>\r\n<p>4.当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。</p>\r\n<h3 id=\"h3--\"><a name=\"二、依赖引入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、依赖引入</h3><p>完整的pom文件如下：</p>\r\n<pre><code class=\"lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\r\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\r\n    &lt;parent&gt;\r\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\r\n        &lt;version&gt;2.4.1&lt;/version&gt;\r\n        &lt;relativePath&gt;&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt;\r\n    &lt;/parent&gt;\r\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\r\n    &lt;artifactId&gt;spring-security&lt;/artifactId&gt;\r\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\r\n    &lt;name&gt;spring-security&lt;/name&gt;\r\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\r\n\r\n    &lt;properties&gt;\r\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\r\n    &lt;/properties&gt;\r\n\r\n    &lt;dependencies&gt;\r\n        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\r\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;1.2.4&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\r\n            &lt;version&gt;2.1.4&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;\r\n            &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\r\n            &lt;scope&gt;runtime&lt;/scope&gt;\r\n            &lt;optional&gt;true&lt;/optional&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\r\n            &lt;scope&gt;runtime&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\r\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\r\n            &lt;optional&gt;true&lt;/optional&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\r\n            &lt;scope&gt;test&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;\r\n            &lt;scope&gt;test&lt;/scope&gt;\r\n        &lt;/dependency&gt;\r\n    &lt;/dependencies&gt;\r\n\r\n    &lt;build&gt;\r\n        &lt;plugins&gt;\r\n            &lt;plugin&gt;\r\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\r\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\r\n                &lt;configuration&gt;\r\n                    &lt;mainClass&gt;com.example.springsecurity.SpringSecurityApplication&lt;/mainClass&gt;\r\n                &lt;/configuration&gt;\r\n            &lt;/plugin&gt;\r\n        &lt;/plugins&gt;\r\n    &lt;/build&gt;\r\n\r\n&lt;/project&gt;\r\n</code></pre>\r\n<h3 id=\"h3--\"><a name=\"三、配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、配置文件</h3><pre><code class=\"lang-xml\"># 开发时关闭缓存,不然没法看到实时页面\r\nspring.thymeleaf.cache=false\r\n# 用非严格的 HTML\r\nspring.thymeleaf.mode=HTML\r\nspring.thymeleaf.encoding=utf-8\r\nspring.thymeleaf.servlet.content-type=text/html\r\nspring.datasource.druid.url=jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC\r\nspring.datasource.druid.username=root\r\nspring.datasource.druid.password=sunyue\r\nspring.datasource.druid.initial-size=1\r\nspring.datasource.druid.min-idle=1\r\nspring.datasource.druid.max-active=20\r\nspring.datasource.druid.test-on-borrow=true\r\n#springbootjdbc导入包不和以前一样\r\nspring.datasource.druid.driver-class-name= com.mysql.cj.jdbc.Driver\r\nmybatis.type-aliases-package=com.example.springsecurity.entity\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n#打印数据库的操作\r\nlogging.level.com.example.springsecurity.dao=debug\r\n#redis缓存\r\n### 配置Redis\r\nmybatis.configuration.cache-enabled=true\r\n# Redis数据库索引（默认为0）\r\nspring.redis.database=0\r\n# Redis服务器地址\r\nspring.redis.host=152.136.30.116\r\n# Redis服务器连接端口\r\nspring.redis.port=6379\r\n# Redis服务器连接密码（默认为空）\r\nspring.redis.password=sunyue\r\n# 连接池最大连接数（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-idle=200\r\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\r\nspring.redis.jedis.pool.max-wait=-1\r\n# 连接池中的最小空闲连接\r\nspring.redis.jedis.pool.min-idle=0\r\n# 连接超时时间（毫秒）\r\nspring.redis.timeout=1000\r\n</code></pre>\r\n<h3 id=\"h3--security-\"><a name=\"四、Security 配置类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、Security 配置类</h3><p>SecurityConfig：</p>\r\n<pre><code class=\"lang-java\">package com.example.springsecurity;\r\n\r\nimport com.example.springsecurity.server.serverImpl.TestUserServer;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.WebSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\n\r\n@EnableWebSecurity    //注解开启Spring Security的功能\r\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r\n\r\n    //明文加密器,只需要在内存中有这个管理对象,如果不添加，从前端登录时会抛出异常Bad credentials（数据库操作需要这个bean，内存不需要，只需要将密码加密就可以）\r\n    /*内置的PasswordEncoder实现列表\r\n    NoOpPasswordEncoder（已废除）\r\n    明文密码加密方式，该方式已被废除（不建议在生产环境使用），不过还是支持开发阶段测试Spring Security的时候使用。\r\n    BCryptPasswordEncoder\r\n    Argon2PasswordEncoder\r\n    Pbkdf2PasswordEncoder\r\n    SCryptPasswordEncoder */\r\n    //使用以上四个方法都可以解密，但是数据库中得密码也是对应方法得加密（添加用户数据是需要password加密new BCryptPasswordEncoder().encode(\"123456\")）\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();//passwordEncoder的实现类\r\n    }\r\n\r\n    //构造一个内存框架对象，获取数据库中的数据\r\n/*    @Bean\r\n    public UserDetailsService myUserDetailsService(){\r\n        return new TestUserServerImpl();\r\n    }*/\r\n    //也可以自动注入\r\n    @Autowired\r\n    private TestUserServer testUserServer;\r\n\r\n    //用户授权\r\n    @Override\r\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\r\n        //基于内存来存储用户信息(需要加密不然会报错---Encoded password does not look like BCrypt)\r\n        /*auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\r\n                .withUser(\"user\").password(new BCryptPasswordEncoder().encode(\"password\")).authorities(\"user\").and()          //设置\r\n                .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"password\")).authorities(\"admin\", \"user\");*/\r\n        //基于数据库来存储用户信息\r\n        //auth.userDetailsService(myUserDetailsService());\r\n        auth.userDetailsService(testUserServer);\r\n    }\r\n\r\n    //用户权限认证\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        http\r\n                //这是认证的请求\r\n                .authorizeRequests()\r\n                .antMatchers(\"/\", \"/home\", \"/login\", \"/index\", \"/error\").permitAll()  //这些请求 不需要认证\r\n                //hasRole和hasAuthority的区别：我们在调用 hasAuthority 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，\r\n                // 可以不加 ROLE_ 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin。\r\n                //也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！\r\n                // 而 hasRole 则不同，代码里如果写的是 USER，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_USER\r\n                .antMatchers(\"/user/**\").hasRole(\"USER\")       //user及以下路径，需要ROLE_USER角色权限\r\n                .antMatchers(\"/admin/**\").hasAuthority(\"admin\")//admin及以下路径，需要admin权限\r\n                .and()\r\n                //loginPage定制自定义登录页，相当于/toLogin其实自动转到/login，loginProcessingUr指定为login-》toLogin（表单提交只能为login）,加了这个需要接受用户名和密码，登录成功跳转  \"/\"\r\n                //.formLogin().loginPage(\"/toLogin\").usernameParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/login\").defaultSuccessUrl(\"/\")\r\n                .formLogin()//自带的login\r\n                .and()\r\n                .csrf().disable()//关闭csrf\r\n                //等出路径为logout，登出成功跳转 \"/\"\r\n                .logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/\")\r\n                .and()\r\n                .rememberMe().rememberMeParameter(\"rememberMe\");\r\n    }\r\n\r\n    /**\r\n     * 核心过滤器配置，更多使用ignoring()用来忽略对静态资源的控制\r\n     */\r\n    @Override\r\n    public void configure(WebSecurity web) throws Exception {\r\n        web\r\n                .ignoring()\r\n                .antMatchers(\"/image/**\");\r\n    }\r\n}\r\n</code></pre>\r\n<p>   AuthenticationManager 的建造器，配置 AuthenticationManagerBuilder 会让Security 自动构建一个 AuthenticationManager；如果想要使用该功能你需要配置一个 UserDetailService 和 PasswordEncoder。UserDetailsService 用于在认证器中根据用户传过来的用户名查找一个用户， PasswordEncoder 用于密码的加密与比对，我们存储用户密码的时候用PasswordEncoder.encode() 加密存储，在认证器里会调用 PasswordEncoder.matches() 方法进行密码比对。如果重写了该方法，Security 会启用 DaoAuthenticationProvider 这个认证器，该认证就是先调用 UserDetailsService.loadUserByUsername 然后使用 PasswordEncoder.matches() 进行密码比对，如果认证成功成功则返回一个 Authentication 对象。</p>\r\n<h3 id=\"h3--userdetailservice\"><a name=\"五、自定义的UserDetailService\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、自定义的UserDetailService</h3><p>TestUserServer：</p>\r\n<pre><code class=\"lang-java\">package com.example.springsecurity.server.serverImpl;\r\n\r\nimport com.example.springsecurity.dao.TestUserMapper;\r\nimport com.example.springsecurity.entity.TestUser;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.User;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Service\r\npublic class TestUserServer implements UserDetailsService {\r\n    @Autowired\r\n    private TestUserMapper testUserMapper;\r\n\r\n    @Override\r\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\r\n        //username参数,是在登陆时,用户传递的表单数据username\r\n        //主要读取数据库3个值 username password authorities\r\n        TestUser testUser = testUserMapper.selectOne(username);\r\n        String authorityName = testUser.getAuthority();\r\n        //为了返回一个UserDetails 使用User\r\n        List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\r\n        GrantedAuthority authority = new SimpleGrantedAuthority(authorityName);\r\n        authorities.add(authority);\r\n        //这里的User 是这个包下的 org.springframework.security.core.userdetails.User;\r\n        return new User(\r\n                testUser.getUsername(),\r\n                testUser.getPassword(),\r\n                authorities);\r\n    }\r\n\r\n}\r\n</code></pre>\r\n<h3 id=\"h3--dao-\"><a name=\"六、实体类和DAO等\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、实体类和DAO等</h3><p>实体类：</p>\r\n<pre><code class=\"lang-java\">package com.example.springsecurity.entity;\r\n\r\nimport lombok.Data;\r\nimport lombok.experimental.Accessors;\r\n\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\n\r\n@Data\r\n@Accessors(chain = true)\r\npublic class TestUser implements Serializable {\r\n    private Long id;\r\n    private String username;\r\n    private String password;\r\n    private String authority;\r\n    private Date created;\r\n    private Date updated;\r\n}\r\n</code></pre>\r\n<p>DAO</p>\r\n<pre><code class=\"lang-java\">package com.example.springsecurity.dao;\r\n\r\nimport com.example.springsecurity.entity.TestUser;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n@Mapper\r\npublic interface TestUserMapper {\r\n    List&lt;TestUser&gt; findAll();\r\n\r\n    TestUser selectOne(String username);\r\n\r\n    void insert(TestUser testUser);\r\n\r\n    void update(TestUser testUser);\r\n\r\n    void delete(String id);\r\n}\r\n</code></pre>\r\n<p>Mapper</p>\r\n<pre><code class=\"lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\r\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\r\n&lt;mapper namespace=\"com.example.springsecurity.dao.TestUserMapper\"&gt;\r\n\r\n    &lt;select id=\"findAll\"  resultType=\"TestUser\"&gt;\r\n       select * from test_user\r\n    &lt;/select&gt;\r\n    &lt;select id=\"selectOne\" resultType=\"TestUser\"&gt;\r\n       select * from test_user where username=#{username}\r\n    &lt;/select&gt;\r\n\r\n    &lt;insert id=\"insert\"&gt;\r\n        insert into test_user (username,password,authority,created,updated) value (#{username},#{password},#{authority},#{created},#{updated})\r\n    &lt;/insert&gt;\r\n    &lt;update id=\"update\"&gt;\r\n        update test_user set username = #{username},password=#{password},authority=#{authority} where id = #{id}\r\n    &lt;/update&gt;\r\n    &lt;delete id=\"delete\"&gt;\r\n        delete from test_user where id = #{id}\r\n    &lt;/delete&gt;\r\n&lt;/mapper&gt;\r\n</code></pre>\r\n<h3 id=\"h3--\"><a name=\"七、前台代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、前台代码</h3><p>1.index.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\r\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; \r\n&lt;head&gt;\r\n     &lt;title&gt;Spring Security Example&lt;/title&gt;   \r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n   &lt;h1&gt;Welcome!&lt;/h1&gt;\r\n&lt;!--自带登录页--&gt;\r\n   &lt;p&gt;&lt;a th:href=\"@{/login}\"&gt;登录&lt;/a&gt;&lt;/p&gt;\r\n&lt;!--自定义登录页--&gt;\r\n   &lt;!--&lt;p&gt;&lt;a th:href=\"@{/toLogin}\"&gt;登录&lt;/a&gt;&lt;/p&gt;--&gt;\r\n   &lt;p&gt;&lt;a th:href=\"@{/user}\"&gt;用户&lt;/a&gt;&lt;/p&gt;\r\n   &lt;p&gt;&lt;a th:href=\"@{/admin}\"&gt;管理员&lt;/a&gt;&lt;/p&gt;\r\n   &lt;p&gt;&lt;a th:href=\"@{/logout}\"&gt;退出&lt;/a&gt;&lt;/p&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>2.login.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"\r\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; \r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;登录&lt;/title&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;form th:action=\"@{/login}\" method=\"post\"&gt;\r\n    &lt;input type=\"text\" name=\"username\" placeholder=\"UserName\"/&gt;\r\n    &lt;input type=\"password\" name=\"password\" placeholder=\"PassWord\"/&gt;\r\n    &lt;input type=\"checkbox\" name=\"rememberMe\"/&gt;\r\n    &lt;input type=\"submit\" value=\"提交\"/&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>3.user.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html lang=\"en\"&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;user&lt;/title&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\nuser\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>4.admin.html</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html lang=\"en\"&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=\"UTF-8\"&gt;\r\n    &lt;title&gt;admin&lt;/title&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\nadmin\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>5.数据库sql文</p>\r\n<pre><code class=\"lang-sql\">/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : sunyue\r\nSource Server Version : 50724\r\nSource Host           : localhost:3306\r\nSource Database       : security\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50724\r\nFile Encoding         : 65001\r\n\r\nDate: 2021-01-13 23:33:57\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for test_user\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `test_user`;\r\nCREATE TABLE `test_user` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(100) DEFAULT NULL,\r\n  `password` varchar(100) DEFAULT NULL,\r\n  `authority` varchar(100) DEFAULT NULL,\r\n  `created` date DEFAULT NULL,\r\n  `updated` date DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\r\n\r\n-- ----------------------------\r\n-- Records of test_user\r\n-- ----------------------------\r\nINSERT INTO `test_user` VALUES (\'3\', \'user\', \'$2a$10$Skjo8i3cSopkOtVsvfX5I.eOPCOFm2B/CD4t0VjUDXfTZk6aSAvia\', \'ROLE_USER\', \'2021-01-12\', \'2021-01-12\');\r\nINSERT INTO `test_user` VALUES (\'4\', \'admin\', \'$2a$10$3rzQ1Pn.Onx9N/Dy6a5O8.TZfB/kqo/Z1UOj9udQl4ne0AZDaxn4O\', \'admin\', \'2021-01-12\', \'2021-01-12\');\r\n</code></pre>\r\n<p>总结：当数据库中<code>authority</code>字段为ROLE_USER则拥有USER角色权限，可以访问路径/user下，为admin则拥有<br>/admin下\r\n', null, null, null, '2021-01-13 23:37:46', '2021-01-13 23:37:46', '1');

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `parent_id` bigint(20) DEFAULT NULL COMMENT '父评论ID',
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `comment_content` longtext NOT NULL COMMENT '评论内容',
  `comment_likes` bigint(20) NOT NULL COMMENT '评论点赞数',
  `comment_create_time` datetime NOT NULL COMMENT '评论创建时间',
  `comment_status` int(1) NOT NULL COMMENT '评论状态',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of comments
-- ----------------------------
INSERT INTO `comments` VALUES ('29', null, '38', '9', '来自作者的提示：需要在服务器上先安装好MySQL和Java才能部署，而且项目配置文件也需要修改连接数据库地址为自己服务器公网ip，并且服务器的安全组需要打开3306端口', '0', '2020-09-24 23:06:04', '0');
INSERT INTO `comments` VALUES ('30', null, '37', '9', '十四版本号的虚拟机', '0', '2020-09-30 08:21:03', '0');
INSERT INTO `comments` VALUES ('31', null, '37', '10', '膜拜大佬', '0', '2020-10-10 12:34:03', '0');
INSERT INTO `comments` VALUES ('32', null, '46', '9', '尽量使用国内加速链接，不然可能会报超时错误!', '0', '2020-10-16 09:36:54', '0');

-- ----------------------------
-- Table structure for labels
-- ----------------------------
DROP TABLE IF EXISTS `labels`;
CREATE TABLE `labels` (
  `label_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '标签ID',
  `label_name` varchar(50) NOT NULL COMMENT '标签名',
  `label_alias` varchar(50) DEFAULT NULL COMMENT '标签别名',
  `label_descripation` text COMMENT '标签描述',
  `label_status` int(1) NOT NULL COMMENT '标签状态',
  PRIMARY KEY (`label_id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of labels
-- ----------------------------
INSERT INTO `labels` VALUES ('10', 'spring boot项目网站部署', '网站部署', '用于介绍网站部署', '1');
INSERT INTO `labels` VALUES ('11', '程序语言', '各类程序语言', '各类程序语言介绍', '1');
INSERT INTO `labels` VALUES ('12', 'Linux服务器', 'Linux服务器', 'Linux服务器介绍', '1');
INSERT INTO `labels` VALUES ('13', '心情', '心情', '记录此刻心情', '1');
INSERT INTO `labels` VALUES ('14', 'MySQL', 'MySQL', 'MySQL数据库', '1');
INSERT INTO `labels` VALUES ('15', '虚拟机', '虚拟机操作', '虚拟机技术', '1');
INSERT INTO `labels` VALUES ('16', 'tomcat', 'tomcat服务器', '关于tomcat', '1');
INSERT INTO `labels` VALUES ('17', '日语', '日语学习', '有关日语的学习', '1');
INSERT INTO `labels` VALUES ('18', 'Docker', 'Docker', '有关Docker', '1');
INSERT INTO `labels` VALUES ('19', 'Spring boot', 'Spring boot 技术', 'Spring boot相关技术', '1');
INSERT INTO `labels` VALUES ('20', 'redis', 'redis', '关于redis', '1');
INSERT INTO `labels` VALUES ('21', 'shiro', 'shiro', 'shiro', '1');
INSERT INTO `labels` VALUES ('22', 'security', 'security', 'security', '1');

-- ----------------------------
-- Table structure for messages
-- ----------------------------
DROP TABLE IF EXISTS `messages`;
CREATE TABLE `messages` (
  `message_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '留言ID',
  `parent_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `message_content` longtext NOT NULL COMMENT '留言内容',
  `message_create_time` datetime DEFAULT NULL COMMENT '留言创建时间',
  `message_status` int(1) NOT NULL COMMENT '留言状态',
  PRIMARY KEY (`message_id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of messages
-- ----------------------------
INSERT INTO `messages` VALUES ('12', null, '9', '手机测试', '2020-09-17 10:02:29', '0');
INSERT INTO `messages` VALUES ('13', null, '9', '手机测试一下', '2020-09-17 10:02:38', '0');
INSERT INTO `messages` VALUES ('14', null, '9', '留意', '2020-09-22 13:20:15', '0');
INSERT INTO `messages` VALUES ('15', null, '9', '测试', '2020-09-22 13:20:26', '0');
INSERT INTO `messages` VALUES ('16', null, '9', '留言', '2020-10-06 20:06:24', '0');
INSERT INTO `messages` VALUES ('17', null, '10', '前排', '2020-10-10 12:31:31', '0');

-- ----------------------------
-- Table structure for sorts
-- ----------------------------
DROP TABLE IF EXISTS `sorts`;
CREATE TABLE `sorts` (
  `sort_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '分类ID',
  `parent_id` bigint(20) DEFAULT NULL COMMENT '父分类ID',
  `sort_name` varchar(50) NOT NULL COMMENT '分类名',
  `sort_alias` varchar(50) DEFAULT NULL COMMENT '分类别名',
  `sort_descripation` text COMMENT '分类描述',
  `sort_status` int(1) NOT NULL COMMENT '分类状态',
  PRIMARY KEY (`sort_id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sorts
-- ----------------------------
INSERT INTO `sorts` VALUES ('12', null, 'Linux', 'Linux服务器', '用于Linux系统的各种操作', '1');
INSERT INTO `sorts` VALUES ('13', null, 'Java', 'Java语言', '用于Java的程序介绍', '1');
INSERT INTO `sorts` VALUES ('14', null, 'python', 'python语言', '用于python的程序介绍', '1');
INSERT INTO `sorts` VALUES ('15', null, '算法', '算法程序', '用于介绍各类算法程序', '1');
INSERT INTO `sorts` VALUES ('16', null, '闲暇琐事', '琐事', '记录平时趣事', '1');
INSERT INTO `sorts` VALUES ('17', null, '日语', '日语学习', '有关日语的学习', '1');
INSERT INTO `sorts` VALUES ('18', null, 'cobol', 'cobol语言', '有关cobol的学习', '1');
INSERT INTO `sorts` VALUES ('19', null, 'Spring', 'Spring系列', 'Spring全家桶', '1');
INSERT INTO `sorts` VALUES ('20', null, '数据库', '数据库设计', '有关数据库的知识', '1');
INSERT INTO `sorts` VALUES ('21', null, 'redis', 'redis', '关于redis', '1');

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `user_name` varchar(20) NOT NULL COMMENT '用户名',
  `user_nickname` varchar(20) DEFAULT NULL COMMENT '用户昵称',
  `user_password` varchar(15) NOT NULL COMMENT '用户密码',
  `user_photo` varchar(255) DEFAULT NULL COMMENT '用户头像',
  `user_sex` varchar(10) DEFAULT NULL COMMENT '性别',
  `user_age` varchar(3) DEFAULT NULL COMMENT '用户年龄',
  `user_email` varchar(30) NOT NULL COMMENT '用户邮箱',
  `user_phone` varchar(11) NOT NULL COMMENT '用户手机号',
  `user_create_time` datetime NOT NULL COMMENT '注册时间',
  `user_login_time` datetime NOT NULL COMMENT '上次登录时间',
  `user_status` int(1) NOT NULL COMMENT '用户状态',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES ('9', '孙跃', '落叶的悲伤', 'yao960408', '../images/582ff6b5-4fa1-4595-945a-38144de75d61.jpg', '男', '24', '873777654@qq.com', '17713430236', '2020-09-17 10:02:13', '2020-09-17 10:02:13', '1');
INSERT INTO `users` VALUES ('10', 'wdf', '王德发', '1230456abc', '../images/7195596f-55bc-4cb3-8faa-82049a57c3b7.jpg', '男', '99', '1543929722@qq.com', '15892227105', '2020-10-10 12:30:32', '2020-10-10 12:30:32', '1');
INSERT INTO `users` VALUES ('11', '管理员', 'admin', 'yao960408', '../images/ab1d8645-784b-4735-ade3-0a1873f28e6f.jpeg', '男', '22', '394945324@qq.com', '13982795632', '2020-10-22 22:42:10', '2020-10-22 22:42:10', '1');
